{"version":3,"file":"conditional.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/conditional.ts"],"names":[],"mappings":";;;;;;;;AAAA,iCAAiC;AAEjC,8CAA2D;AAC3D,8CAAiF;AAIjF,IAAa,oBAAoB,GAAjC,MAAa,oBAAqB,SAAQ,mCAAsB;IAI5D,YAAY,CAAC,OAAgB,EAAE,IAA4B;QACvD,OAAO,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC;IACvD,CAAC;IAKD,YAAY,CAAC,OAAgB,EAAE,IAAwB;QACnD,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;IACrD,CAAC;IAWD,WAAW,CAAC,OAAgB,EAAE,IAA4B;QACtD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;QAClH,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACpB,OAAO,SAAS,CAAC;SACpB;QACD,OAAO,IAAI,uBAAe,CAAC,GAAG,KAAiC,CAAC,CAAC;IACrE,CAAC;IAWD,WAAW,CAAC,OAAgB,EAAE,IAAwB;QAClD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC;QACtI,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACpB,OAAO,SAAS,CAAC;SACpB;QACD,OAAO,IAAI,uBAAe,CAAC,GAAG,KAAiC,CAAC,CAAC;IACrE,CAAC;CACJ,CAAA;AAhDY,oBAAoB;IADhC,sBAAS,CAAC,EAAC,IAAI,EAAE,kBAAkB,EAAC,CAAC;GACzB,oBAAoB,CAgDhC;AAhDY,oDAAoB","sourcesContent":["import * as ts from 'typescript';\n\nimport { ConditionalType, Type } from '../../models/types';\nimport { Component, ConverterTypeComponent, TypeConverter } from '../components';\nimport { Context } from '../context';\n\n@Component({name: 'type:conditional'})\nexport class ConditionalConverter extends ConverterTypeComponent implements TypeConverter<ts.ConditionalType, ts.ConditionalTypeNode> {\n    /**\n     * Test whether this converter can handle the given TypeScript node.\n     */\n    supportsNode(context: Context, node: ts.ConditionalTypeNode): boolean {\n        return node.kind === ts.SyntaxKind.ConditionalType;\n    }\n\n    /**\n     * Test whether this converter can handle the given TypeScript type.\n     */\n    supportsType(context: Context, type: ts.ConditionalType): boolean {\n        return !!(type.flags & ts.TypeFlags.Conditional);\n    }\n\n    /**\n     * Convert the given conditional type node to its type reflection.\n     *\n     * This is a node based converter, see [[convertType]] for the type equivalent.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The conditional or intersection type node that should be converted.\n     * @returns The type reflection representing the given conditional type node.\n     */\n    convertNode(context: Context, node: ts.ConditionalTypeNode): ConditionalType | undefined {\n        const types = this.owner.convertTypes(context, [node.checkType, node.extendsType, node.trueType, node.falseType]);\n        if (types.length !== 4) {\n            return undefined;\n        }\n        return new ConditionalType(...types as [Type, Type, Type, Type]);\n    }\n\n    /**\n     * Convert the given conditional type to its type reflection.\n     *\n     * This is a type based converter, see [[convertNode]] for the node equivalent.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param type  The conditional type that should be converted.\n     * @returns The type reflection representing the given conditional type.\n     */\n    convertType(context: Context, type: ts.ConditionalType): ConditionalType | undefined {\n        const types = this.owner.convertTypes(context, [], [type.checkType, type.extendsType, type.resolvedTrueType, type.resolvedFalseType]);\n        if (types.length !== 4) {\n            return undefined;\n        }\n        return new ConditionalType(...types as [Type, Type, Type, Type]);\n    }\n}\n"]}