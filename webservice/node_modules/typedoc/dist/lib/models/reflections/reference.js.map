{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/models/reflections/reference.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, ReflectionFlag } from './abstract';\nimport { ProjectReflection } from './project';\nimport { DeclarationReflection } from './declaration';\n\nexport enum ReferenceState {\n    Unresolved,\n    Resolved\n}\n\n/**\n * Describes a reflection which does not exist at this location, but is referenced. Used for imported reflections.\n *\n * ```ts\n * // a.ts\n * export const a = 1;\n * // b.ts\n * import { a } from './a';\n * // Here to avoid extra work we create a reference to the original reflection in module a instead\n * // of copying the reflection.\n * export { a };\n * ```\n */\nexport class ReferenceReflection extends DeclarationReflection {\n    private _state: [ReferenceState.Unresolved, number] | [ReferenceState.Resolved, number];\n    private _project?: ProjectReflection;\n\n    /**\n     * Creates a reference reflection. Should only be used within the factory function.\n     * @param name\n     * @param state\n     * @param parent\n     *\n     * @internal\n     */\n    constructor(name: string, state: ReferenceReflection['_state'], parent?: Reflection) {\n        super(name, ReflectionKind.Reference, parent);\n        // References are only created for re-exported items, so they must be exported.\n        this.flags.setFlag(ReflectionFlag.Exported, true);\n        this._state = state;\n    }\n\n    /**\n     * Helper to check if this reflection is a reference for themes.\n     */\n    get isReference() {\n        return true;\n    }\n\n    /**\n     * Tries to get the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use [[tryGetTargetReflectionDeep]].\n     */\n    tryGetTargetReflection(): Reflection | undefined {\n        this._ensureProject();\n        this._ensureResolved(false);\n        return this._state[0] === ReferenceState.Resolved ? this._project!.reflections[this._state[1]] : undefined;\n    }\n\n    /**\n     * Tries to get the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use [[tryGetTargetReflection]].\n     */\n    tryGetTargetReflectionDeep(): Reflection | undefined {\n        let result = this.tryGetTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.tryGetTargetReflection();\n        }\n        return result;\n    }\n\n    /**\n     * Gets the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use [[getTargetReflectionDeep]].\n     */\n    getTargetReflection(): Reflection {\n        this._ensureProject();\n        this._ensureResolved(true);\n\n        return this._project!.reflections[this._state[1]];\n    }\n\n    /**\n     * Gets the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use [[getTargetReflection]].\n     */\n    getTargetReflectionDeep(): Reflection {\n        let result = this.getTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.getTargetReflection();\n        }\n        return result;\n    }\n\n    /**\n     * Get a raw object representation of this reflection.\n     * @deprecated use serializers instead.\n     */\n    toObject() {\n        return {\n            ...super.toObject(),\n            target: this.tryGetTargetReflection()?.id ?? -1\n        };\n    }\n\n    private _ensureResolved(throwIfFail: boolean) {\n        if (this._state[0] === ReferenceState.Unresolved) {\n            const target = this._project!.symbolMapping[this._state[1]];\n            if (!target) {\n                if (throwIfFail) {\n                    throw new Error(`Tried to reference reflection for ${this.name} that does not exist.`);\n                }\n                return;\n            }\n            this._state = [ReferenceState.Resolved, target];\n        }\n    }\n\n    private _ensureProject() {\n        if (this._project) { return; }\n\n        let project = this.parent;\n        while (project && !project.isProject()) {\n            project = project.parent;\n        }\n        this._project = project;\n\n        if (!this._project) {\n            throw new Error('Reference reflection has no project and is unable to resolve.');\n        }\n    }\n}\n"]}