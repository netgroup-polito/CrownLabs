{"ast":null,"code":"/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash\").clone,\n    merge = require(\"../util/merge\"),\n    base64url = require(\"../util/base64url\"),\n    AlgConfig = require(\"../util/algconfig\"),\n    JWK = require(\"../jwk\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\n\nvar JWSVerifier = function (ks, globalOpts) {\n  var assumedKey, keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"verify\", {\n    value: function (input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [{\n            protected: input[0],\n            signature: input[2]\n          }]\n        };\n      } else if (!input || \"object\" !== typeof input) {\n        throw new Error(\"invalid input\");\n      } // fixup \"flattened JSON\" to look like \"general JSON\"\n\n\n      if (input.signature) {\n        input.signatures = [{\n          protected: input.protected || undefined,\n          header: input.header || undefined,\n          signature: input.signature\n        }];\n      } // ensure signatories exists\n\n\n      var sigList = input.signatures || [{}]; // combine fields and decode signature per signatory\n\n      sigList = sigList.map(function (s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ? JSON.parse(base64url.decode(s.protected, \"utf8\")) : {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature); // process allowed algorithims\n\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        } // process \"crit\" first\n\n\n        var crit = protect.crit;\n\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\"Critical extension is not supported: \" + crit[idx]));\n            }\n          }\n        }\n\n        protect = Object.keys(protect);\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n      var promise = Promise.all(sigList);\n      promise = promise.then(function (sigList) {\n        return new Promise(function (resolve, reject) {\n          var processSig = function () {\n            var sig = sigList.shift();\n\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig); // find the key\n\n            p = p.then(function (sig) {\n              var algKey; // TODO: resolve jku, x5c, x5u\n\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = Buffer.from(algKey, \"base64\"); // TODO: callback to validate chain\n\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n\n              return algKey.then(function (k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n\n                sig.key = k;\n                return sig;\n              });\n            }); // process any prepare-verify handlers\n\n            p = p.then(function (sig) {\n              var processing = [];\n              handlerKeys.forEach(function (h) {\n                h = extraHandlers[h];\n                var p;\n\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function () {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            }); // prepare verify inputs\n\n            p = p.then(function (sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = Buffer.alloc(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n\n              sig.content = content;\n              return sig;\n            });\n            p = p.then(function (sig) {\n              return sig.key.verify(sig.header.alg, sig.content, sig.signature);\n            });\n            p = p.then(function (result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            }); // process any post-verify handlers\n\n            p = p.then(function (jws) {\n              var processing = [];\n              handlerKeys.forEach(function (h) {\n                h = extraHandlers[h];\n                var p;\n\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function () {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\n\n\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/jws/verify.js"],"names":["clone","require","merge","base64url","AlgConfig","JWK","DEFAULT_OPTIONS","algorithms","allowEmbeddedKey","JWSVerifier","ks","globalOpts","assumedKey","keystore","isKey","isKeyStore","createKeyStore","Object","defineProperty","value","undefined","enumerable","input","opts","extraHandlers","handlers","handlerKeys","keys","algSpec","split","payload","signatures","protected","signature","Error","header","sigList","map","s","protect","JSON","parse","decode","match","alg","Promise","reject","crit","Array","isArray","idx","length","indexOf","resolve","aad","promise","all","then","processSig","sig","shift","p","algKey","jwk","asKey","x5c","Buffer","from","get","use","kid","k","key","processing","forEach","h","prepare","push","content","alloc","pos","write","isBuffer","copy","verify","result","mac","jws","complete","createVerify","vfy","module","exports","verifier"],"mappings":"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","sourcesContent":["/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash\").clone,\n    merge = require(\"../util/merge\"),\n    base64url = require(\"../util/base64url\"),\n    AlgConfig = require(\"../util/algconfig\"),\n    JWK = require(\"../jwk\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\nvar JWSVerifier = function(ks, globalOpts) {\n  var assumedKey,\n      keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n\n  Object.defineProperty(this, \"verify\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [\n            {\n              protected: input[0],\n              signature: input[2]\n            }\n          ]\n        };\n      } else if (!input || \"object\" !== typeof input) {\n        throw new Error(\"invalid input\");\n      }\n\n      // fixup \"flattened JSON\" to look like \"general JSON\"\n      if (input.signature) {\n        input.signatures = [\n          {\n            protected: input.protected || undefined,\n            header: input.header || undefined,\n            signature: input.signature\n          }\n        ];\n      }\n\n      // ensure signatories exists\n      var sigList = input.signatures || [{}];\n\n      // combine fields and decode signature per signatory\n      sigList = sigList.map(function(s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ?\n                      JSON.parse(base64url.decode(s.protected, \"utf8\")) :\n                      {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature);\n\n        // process allowed algorithims\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        }\n\n        // process \"crit\" first\n        var crit = protect.crit;\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\n                  \"Critical extension is not supported: \" + crit[idx]\n              ));\n            }\n          }\n        }\n        protect = Object.keys(protect);\n\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n\n      var promise = Promise.all(sigList);\n      promise = promise.then(function(sigList) {\n        return new Promise(function(resolve, reject) {\n          var processSig = function() {\n            var sig = sigList.shift();\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig);\n            // find the key\n            p = p.then(function(sig) {\n              var algKey;\n              // TODO: resolve jku, x5c, x5u\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = Buffer.from(algKey, \"base64\");\n                // TODO: callback to validate chain\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n              return algKey.then(function(k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n                sig.key = k;\n                return sig;\n              });\n            });\n\n            // process any prepare-verify handlers\n            p = p.then(function(sig) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            });\n\n            // prepare verify inputs\n            p = p.then(function(sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = Buffer.alloc(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n              sig.content = content;\n              return sig;\n            });\n\n            p = p.then(function(sig) {\n              return sig.key.verify(sig.header.alg,\n                                    sig.content,\n                                    sig.signature);\n            });\n\n            p = p.then(function(result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            });\n\n            // process any post-verify handlers\n            p = p.then(function(jws) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};\n"]},"metadata":{},"sourceType":"script"}