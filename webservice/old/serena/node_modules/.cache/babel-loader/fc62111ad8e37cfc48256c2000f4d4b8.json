{"ast":null,"code":"/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  } // Build the character lookup table:\n\n\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new (opts.out || Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\n\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\n\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\nexport { base16, base32, base32hex, base64, base64url, codec };","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/rfc4648/lib/index.js"],"names":["parse","string","encoding","opts","codes","i","chars","length","loose","bits","SyntaxError","end","out","Uint8Array","buffer","written","_i","value","undefined","stringify","data","_opts","_opts$pad","pad","mask","base16Encoding","base32Encoding","base32HexEncoding","base64Encoding","base64UrlEncoding","base16","parse$1","toUpperCase","stringify$1","base32","replace","base32hex","base64","base64url","codec"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new (opts.out || Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\n\nexport { base16, base32, base32hex, base64, base64url, codec };\n"]},"metadata":{},"sourceType":"module"}