{"ast":null,"code":"// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\nvar assert = require('assert');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar ASN1 = require('./types');\n\nvar errors = require('./errors'); // --- Globals\n\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n}; // --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof from, 'object');\n  assert.ok(to);\n  assert.equal(typeof to, 'object');\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key]) return;\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n  return to;\n} // --- API\n\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options; // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n    return this._buf.slice(0, this._offset);\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof b !== 'number') throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n\n  this._buf[this._offset++] = b;\n};\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof i !== 'number') throw new TypeError('argument must be a Number');\n  if (typeof tag !== 'number') tag = ASN1.Integer;\n  var sz = 4;\n\n  while (((i & 0xff800000) === 0 || (i & 0xff800000) === 0xff800000 >> 0) && sz > 1) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4) throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = (i & 0xff000000) >>> 24;\n    i <<= 8;\n  }\n};\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof i !== 'number') throw new TypeError('argument must be a Number');\n  if (typeof tag !== 'number') tag = ASN1.Enumeration;\n  return this.writeInt(i, tag);\n};\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof b !== 'boolean') throw new TypeError('argument must be a Boolean');\n  if (typeof tag !== 'number') tag = ASN1.Boolean;\n\n  this._ensure(3);\n\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof s !== 'string') throw new TypeError('argument must be a string (was: ' + typeof s + ')');\n  if (typeof tag !== 'number') tag = ASN1.OctetString;\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n\n  if (len) {\n    this._ensure(len);\n\n    this._buf.write(s, this._offset);\n\n    this._offset += len;\n  }\n};\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof tag !== 'number') throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf)) throw new TypeError('argument must be a buffer');\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n\n  this._ensure(buf.length);\n\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\nWriter.prototype.writeStringArray = function (strings) {\n  if (!strings instanceof Array) throw new TypeError('argument must be an Array[String]');\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n}; // This is really to solve DER cases, but whatever for now\n\n\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof s !== 'string') throw new TypeError('argument must be a string');\n  if (typeof tag !== 'number') tag = ASN1.OID;\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s)) throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n      bytes.push(octet);\n    } else if (octet < 16384) {\n      bytes.push(octet >>> 7 | 0x80);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push(octet >>> 14 | 0x80);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push(octet >>> 21 | 0x80);\n      bytes.push((octet >>> 14 | 0x80) & 0xFF);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push((octet >>> 28 | 0x80) & 0xFF);\n      bytes.push((octet >>> 21 | 0x80) & 0xFF);\n      bytes.push((octet >>> 14 | 0x80) & 0xFF);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n  var self = this;\n\n  this._ensure(2 + bytes.length);\n\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof len !== 'number') throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof tag !== 'number') tag = ASN1.Sequence | ASN1.Constructor;\n  this.writeByte(tag);\n\n  this._seq.push(this._offset);\n\n  this._ensure(3);\n\n  this._offset += 3;\n};\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len) sz += len;\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n\n    this._buf = buf;\n    this._size = sz;\n  }\n}; // --- Exported API\n\n\nmodule.exports = Writer;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/asn1/lib/ber/writer.js"],"names":["assert","require","Buffer","ASN1","errors","newInvalidAsn1Error","DEFAULT_OPTS","size","growthFactor","merge","from","to","ok","equal","keys","Object","getOwnPropertyNames","forEach","key","value","getOwnPropertyDescriptor","defineProperty","Writer","options","_buf","alloc","_size","length","_offset","_options","_seq","prototype","get","slice","writeByte","b","TypeError","_ensure","writeInt","i","tag","Integer","sz","writeNull","Null","writeEnumeration","Enumeration","writeBoolean","Boolean","writeString","s","OctetString","len","byteLength","writeLength","write","writeBuffer","buf","isBuffer","copy","writeStringArray","strings","Array","self","writeOID","OID","test","Error","encodeOctet","bytes","octet","push","tmp","split","parseInt","startSequence","Sequence","Constructor","endSequence","seq","pop","start","_shift","shift","undefined","module","exports"],"mappings":"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","sourcesContent":["// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n"]},"metadata":{},"sourceType":"script"}