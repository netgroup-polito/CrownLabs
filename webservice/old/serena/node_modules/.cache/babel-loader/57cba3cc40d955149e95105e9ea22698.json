{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = (iterable, opts) => new Promise((resolve, reject) => {\n  opts = Object.assign({}, opts);\n\n  if (!Number.isFinite(opts.count)) {\n    throw new TypeError(`Expected a finite number, got ${typeof opts.count}`);\n  }\n\n  const values = [];\n  const errors = [];\n  let elCount = 0;\n  let maxErrors = -opts.count + 1;\n  let maxFiltered = -opts.count + 1;\n  let done = false;\n\n  const fulfilled = value => {\n    if (done) {\n      return;\n    }\n\n    if (typeof opts.filter === 'function' && !opts.filter(value)) {\n      if (--maxFiltered === 0) {\n        done = true;\n        reject(new RangeError(`Not enough values pass the \\`filter\\` option`));\n      }\n\n      return;\n    }\n\n    values.push(value);\n\n    if (--opts.count === 0) {\n      done = true;\n      resolve(values);\n    }\n  };\n\n  const rejected = error => {\n    if (done) {\n      return;\n    }\n\n    errors.push(error);\n\n    if (--maxErrors === 0) {\n      done = true;\n      reject(new AggregateError(errors));\n    }\n  };\n\n  for (const el of iterable) {\n    maxErrors++;\n    maxFiltered++;\n    elCount++;\n    Promise.resolve(el).then(fulfilled, rejected);\n  }\n\n  if (opts.count > elCount) {\n    throw new RangeError(`Expected input to contain at least ${opts.count} items, but contains ${elCount} items`);\n  }\n});\n\nmodule.exports.AggregateError = AggregateError;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/p-some/index.js"],"names":["AggregateError","require","module","exports","iterable","opts","Promise","resolve","reject","Object","assign","Number","isFinite","count","TypeError","values","errors","elCount","maxErrors","maxFiltered","done","fulfilled","value","filter","RangeError","push","rejected","error","el","then"],"mappings":"AAAA;;AACA,MAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAD,CAA9B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAACC,QAAD,EAAWC,IAAX,KAAoB,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrEH,EAAAA,IAAI,GAAGI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,CAAP;;AAEA,MAAI,CAACM,MAAM,CAACC,QAAP,CAAgBP,IAAI,CAACQ,KAArB,CAAL,EAAkC;AACjC,UAAM,IAAIC,SAAJ,CAAe,iCAAgC,OAAOT,IAAI,CAACQ,KAAM,EAAjE,CAAN;AACA;;AAED,QAAME,MAAM,GAAG,EAAf;AACA,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,SAAS,GAAG,CAACb,IAAI,CAACQ,KAAN,GAAc,CAA9B;AACA,MAAIM,WAAW,GAAG,CAACd,IAAI,CAACQ,KAAN,GAAc,CAAhC;AACA,MAAIO,IAAI,GAAG,KAAX;;AAEA,QAAMC,SAAS,GAAGC,KAAK,IAAI;AAC1B,QAAIF,IAAJ,EAAU;AACT;AACA;;AAED,QAAI,OAAOf,IAAI,CAACkB,MAAZ,KAAuB,UAAvB,IAAqC,CAAClB,IAAI,CAACkB,MAAL,CAAYD,KAAZ,CAA1C,EAA8D;AAC7D,UAAI,EAAEH,WAAF,KAAkB,CAAtB,EAAyB;AACxBC,QAAAA,IAAI,GAAG,IAAP;AACAZ,QAAAA,MAAM,CAAC,IAAIgB,UAAJ,CAAgB,8CAAhB,CAAD,CAAN;AACA;;AAED;AACA;;AAEDT,IAAAA,MAAM,CAACU,IAAP,CAAYH,KAAZ;;AAEA,QAAI,EAAEjB,IAAI,CAACQ,KAAP,KAAiB,CAArB,EAAwB;AACvBO,MAAAA,IAAI,GAAG,IAAP;AACAb,MAAAA,OAAO,CAACQ,MAAD,CAAP;AACA;AACD,GApBD;;AAsBA,QAAMW,QAAQ,GAAGC,KAAK,IAAI;AACzB,QAAIP,IAAJ,EAAU;AACT;AACA;;AAEDJ,IAAAA,MAAM,CAACS,IAAP,CAAYE,KAAZ;;AAEA,QAAI,EAAET,SAAF,KAAgB,CAApB,EAAuB;AACtBE,MAAAA,IAAI,GAAG,IAAP;AACAZ,MAAAA,MAAM,CAAC,IAAIR,cAAJ,CAAmBgB,MAAnB,CAAD,CAAN;AACA;AACD,GAXD;;AAaA,OAAK,MAAMY,EAAX,IAAiBxB,QAAjB,EAA2B;AAC1Bc,IAAAA,SAAS;AACTC,IAAAA,WAAW;AACXF,IAAAA,OAAO;AACPX,IAAAA,OAAO,CAACC,OAAR,CAAgBqB,EAAhB,EAAoBC,IAApB,CAAyBR,SAAzB,EAAoCK,QAApC;AACA;;AAED,MAAIrB,IAAI,CAACQ,KAAL,GAAaI,OAAjB,EAA0B;AACzB,UAAM,IAAIO,UAAJ,CAAgB,sCAAqCnB,IAAI,CAACQ,KAAM,wBAAuBI,OAAQ,QAA/F,CAAN;AACA;AACD,CA3DoC,CAArC;;AA6DAf,MAAM,CAACC,OAAP,CAAeH,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = (iterable, opts) => new Promise((resolve, reject) => {\n\topts = Object.assign({}, opts);\n\n\tif (!Number.isFinite(opts.count)) {\n\t\tthrow new TypeError(`Expected a finite number, got ${typeof opts.count}`);\n\t}\n\n\tconst values = [];\n\tconst errors = [];\n\tlet elCount = 0;\n\tlet maxErrors = -opts.count + 1;\n\tlet maxFiltered = -opts.count + 1;\n\tlet done = false;\n\n\tconst fulfilled = value => {\n\t\tif (done) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof opts.filter === 'function' && !opts.filter(value)) {\n\t\t\tif (--maxFiltered === 0) {\n\t\t\t\tdone = true;\n\t\t\t\treject(new RangeError(`Not enough values pass the \\`filter\\` option`));\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.push(value);\n\n\t\tif (--opts.count === 0) {\n\t\t\tdone = true;\n\t\t\tresolve(values);\n\t\t}\n\t};\n\n\tconst rejected = error => {\n\t\tif (done) {\n\t\t\treturn;\n\t\t}\n\n\t\terrors.push(error);\n\n\t\tif (--maxErrors === 0) {\n\t\t\tdone = true;\n\t\t\treject(new AggregateError(errors));\n\t\t}\n\t};\n\n\tfor (const el of iterable) {\n\t\tmaxErrors++;\n\t\tmaxFiltered++;\n\t\telCount++;\n\t\tPromise.resolve(el).then(fulfilled, rejected);\n\t}\n\n\tif (opts.count > elCount) {\n\t\tthrow new RangeError(`Expected input to contain at least ${opts.count} items, but contains ${elCount} items`);\n\t}\n});\n\nmodule.exports.AggregateError = AggregateError;\n"]},"metadata":{},"sourceType":"script"}