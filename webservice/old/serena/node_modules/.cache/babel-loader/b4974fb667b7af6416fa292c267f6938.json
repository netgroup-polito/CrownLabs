{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar common = require('./common');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force'\n  }\n}); // Checks if cureent file was created recently\n\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n} //@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\n\n\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest); // Dest is not existing dir, but multiple sources given\n\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  } // Dest is an existing file, but no -f given\n\n\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    } // If here, src exists\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n\n\n    var thisDest = dest;\n\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    var thisDestExists = fs.existsSync(thisDest);\n\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n          continue: true\n        });\n      }\n\n      return;\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n\n  return '';\n} // mv\n\n\nmodule.exports = _mv;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/shelljs/src/mv.js"],"names":["fs","require","path","common","cp","rm","register","_mv","cmdOptions","checkRecentCreated","sources","index","lookedSource","slice","some","src","basename","options","dest","arguments","length","error","call","exists","existsSync","stats","statFollowLinks","isDirectory","isFile","no_force","forEach","srcIndex","continue","thisDest","normalize","thisDestExists","resolve","dirname","renameSync","e","code","module","exports"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar cp = require('./cp');\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n  },\n});\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    var thisDestExists = fs.existsSync(thisDest);\n\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n      }\n      return;\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, { continue: true });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;\n"]},"metadata":{},"sourceType":"script"}