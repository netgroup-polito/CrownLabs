{"ast":null,"code":"// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy;\n\nfunction wrappy(fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb);\n  if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k];\n  });\n  return wrapper;\n\n  function wrapper() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var ret = fn.apply(this, args);\n    var cb = args[args.length - 1];\n\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k];\n      });\n    }\n\n    return ret;\n  }\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/wrappy/wrappy.js"],"names":["module","exports","wrappy","fn","cb","TypeError","Object","keys","forEach","k","wrapper","args","Array","arguments","length","i","ret","apply"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,GAAiBC,MAAjB;;AACA,SAASA,MAAT,CAAiBC,EAAjB,EAAqBC,EAArB,EAAyB;AACvB,MAAID,EAAE,IAAIC,EAAV,EAAc,OAAOF,MAAM,CAACC,EAAD,CAAN,CAAWC,EAAX,CAAP;AAEd,MAAI,OAAOD,EAAP,KAAc,UAAlB,EACE,MAAM,IAAIE,SAAJ,CAAc,uBAAd,CAAN;AAEFC,EAAAA,MAAM,CAACC,IAAP,CAAYJ,EAAZ,EAAgBK,OAAhB,CAAwB,UAAUC,CAAV,EAAa;AACnCC,IAAAA,OAAO,CAACD,CAAD,CAAP,GAAaN,EAAE,CAACM,CAAD,CAAf;AACD,GAFD;AAIA,SAAOC,OAAP;;AAEA,WAASA,OAAT,GAAmB;AACjB,QAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUC,SAAS,CAACC,MAApB,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACG,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACpCJ,MAAAA,IAAI,CAACI,CAAD,CAAJ,GAAUF,SAAS,CAACE,CAAD,CAAnB;AACD;;AACD,QAAIC,GAAG,GAAGb,EAAE,CAACc,KAAH,CAAS,IAAT,EAAeN,IAAf,CAAV;AACA,QAAIP,EAAE,GAAGO,IAAI,CAACA,IAAI,CAACG,MAAL,GAAY,CAAb,CAAb;;AACA,QAAI,OAAOE,GAAP,KAAe,UAAf,IAA6BA,GAAG,KAAKZ,EAAzC,EAA6C;AAC3CE,MAAAA,MAAM,CAACC,IAAP,CAAYH,EAAZ,EAAgBI,OAAhB,CAAwB,UAAUC,CAAV,EAAa;AACnCO,QAAAA,GAAG,CAACP,CAAD,CAAH,GAASL,EAAE,CAACK,CAAD,CAAX;AACD,OAFD;AAGD;;AACD,WAAOO,GAAP;AACD;AACF","sourcesContent":["// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n"]},"metadata":{},"sourceType":"script"}