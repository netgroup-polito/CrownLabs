{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst byline = require(\"byline\");\n\nconst request = require(\"request\");\n\nclass DefaultRequest {\n  webRequest(opts, callback) {\n    return request(opts, callback);\n  }\n\n}\n\nexports.DefaultRequest = DefaultRequest;\n\nclass Watch {\n  constructor(config, requestImpl) {\n    this.config = config;\n\n    if (requestImpl) {\n      this.requestImpl = requestImpl;\n    } else {\n      this.requestImpl = new DefaultRequest();\n    }\n  }\n\n  watch(path, queryParams, callback, done) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const cluster = this.config.getCurrentCluster();\n\n      if (!cluster) {\n        throw new Error('No currently active cluster');\n      }\n\n      const url = cluster.server + path;\n      queryParams.watch = true;\n      const headerParams = {};\n      const requestOptions = {\n        method: 'GET',\n        qs: queryParams,\n        headers: headerParams,\n        uri: url,\n        useQuerystring: true,\n        json: true\n      };\n      yield this.config.applyToRequest(requestOptions);\n      const stream = byline.createStream();\n      stream.on('data', line => {\n        try {\n          const data = JSON.parse(line);\n          callback(data.type, data.object);\n        } catch (ignore) {// ignore parse errors\n        }\n      });\n      let errOut = null;\n      stream.on('error', err => {\n        errOut = err;\n        done(err);\n      });\n      stream.on('close', () => done(errOut));\n      const req = this.requestImpl.webRequest(requestOptions, (error, response, body) => {\n        if (error) {\n          done(error);\n        } else if (response && response.statusCode !== 200) {\n          done(new Error(response.statusMessage));\n        } else {\n          done(null);\n        }\n      });\n      req.pipe(stream);\n      return req;\n    });\n  }\n\n}\n\nWatch.SERVER_SIDE_CLOSE = {\n  error: 'Connection closed on server'\n};\nexports.Watch = Watch;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/@kubernetes/client-node/dist/watch.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","byline","request","DefaultRequest","webRequest","opts","callback","Watch","constructor","config","requestImpl","watch","path","queryParams","done","__awaiter","cluster","getCurrentCluster","Error","url","server","headerParams","requestOptions","method","qs","headers","uri","useQuerystring","json","applyToRequest","stream","createStream","on","line","data","JSON","parse","type","object","ignore","errOut","err","req","error","response","body","statusCode","statusMessage","pipe","SERVER_SIDE_CLOSE"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst byline = require(\"byline\");\nconst request = require(\"request\");\nclass DefaultRequest {\n    webRequest(opts, callback) {\n        return request(opts, callback);\n    }\n}\nexports.DefaultRequest = DefaultRequest;\nclass Watch {\n    constructor(config, requestImpl) {\n        this.config = config;\n        if (requestImpl) {\n            this.requestImpl = requestImpl;\n        }\n        else {\n            this.requestImpl = new DefaultRequest();\n        }\n    }\n    watch(path, queryParams, callback, done) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const cluster = this.config.getCurrentCluster();\n            if (!cluster) {\n                throw new Error('No currently active cluster');\n            }\n            const url = cluster.server + path;\n            queryParams.watch = true;\n            const headerParams = {};\n            const requestOptions = {\n                method: 'GET',\n                qs: queryParams,\n                headers: headerParams,\n                uri: url,\n                useQuerystring: true,\n                json: true,\n            };\n            yield this.config.applyToRequest(requestOptions);\n            const stream = byline.createStream();\n            stream.on('data', (line) => {\n                try {\n                    const data = JSON.parse(line);\n                    callback(data.type, data.object);\n                }\n                catch (ignore) {\n                    // ignore parse errors\n                }\n            });\n            let errOut = null;\n            stream.on('error', (err) => {\n                errOut = err;\n                done(err);\n            });\n            stream.on('close', () => done(errOut));\n            const req = this.requestImpl.webRequest(requestOptions, (error, response, body) => {\n                if (error) {\n                    done(error);\n                }\n                else if (response && response.statusCode !== 200) {\n                    done(new Error(response.statusMessage));\n                }\n                else {\n                    done(null);\n                }\n            });\n            req.pipe(stream);\n            return req;\n        });\n    }\n}\nWatch.SERVER_SIDE_CLOSE = { error: 'Connection closed on server' };\nexports.Watch = Watch;\n//# sourceMappingURL=watch.js.map"]},"metadata":{},"sourceType":"script"}