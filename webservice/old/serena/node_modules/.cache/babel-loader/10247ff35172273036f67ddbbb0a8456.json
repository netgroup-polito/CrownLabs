{"ast":null,"code":"var xor = require('buffer-xor');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar incr32 = require('../incr32');\n\nfunction getBlock(self) {\n  var out = self._cipher.encryptBlockRaw(self._prev);\n\n  incr32(self._prev);\n  return out;\n}\n\nvar blockSize = 16;\n\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize);\n  var start = self._cache.length;\n  self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);\n\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self);\n    var offset = start + i * blockSize;\n\n    self._cache.writeUInt32BE(out[0], offset + 0);\n\n    self._cache.writeUInt32BE(out[1], offset + 4);\n\n    self._cache.writeUInt32BE(out[2], offset + 8);\n\n    self._cache.writeUInt32BE(out[3], offset + 12);\n  }\n\n  var pad = self._cache.slice(0, chunk.length);\n\n  self._cache = self._cache.slice(chunk.length);\n  return xor(chunk, pad);\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/browserify-aes/modes/ctr.js"],"names":["xor","require","Buffer","incr32","getBlock","self","out","_cipher","encryptBlockRaw","_prev","blockSize","exports","encrypt","chunk","chunkNum","Math","ceil","length","start","_cache","concat","allocUnsafe","i","offset","writeUInt32BE","pad","slice"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,YAAD,CAAjB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAP,CAAuBC,MAApC;;AACA,IAAIC,MAAM,GAAGF,OAAO,CAAC,WAAD,CAApB;;AAEA,SAASG,QAAT,CAAmBC,IAAnB,EAAyB;AACvB,MAAIC,GAAG,GAAGD,IAAI,CAACE,OAAL,CAAaC,eAAb,CAA6BH,IAAI,CAACI,KAAlC,CAAV;;AACAN,EAAAA,MAAM,CAACE,IAAI,CAACI,KAAN,CAAN;AACA,SAAOH,GAAP;AACD;;AAED,IAAII,SAAS,GAAG,EAAhB;;AACAC,OAAO,CAACC,OAAR,GAAkB,UAAUP,IAAV,EAAgBQ,KAAhB,EAAuB;AACvC,MAAIC,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAUH,KAAK,CAACI,MAAN,GAAeP,SAAzB,CAAf;AACA,MAAIQ,KAAK,GAAGb,IAAI,CAACc,MAAL,CAAYF,MAAxB;AACAZ,EAAAA,IAAI,CAACc,MAAL,GAAcjB,MAAM,CAACkB,MAAP,CAAc,CAC1Bf,IAAI,CAACc,MADqB,EAE1BjB,MAAM,CAACmB,WAAP,CAAmBP,QAAQ,GAAGJ,SAA9B,CAF0B,CAAd,CAAd;;AAIA,OAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,QAApB,EAA8BQ,CAAC,EAA/B,EAAmC;AACjC,QAAIhB,GAAG,GAAGF,QAAQ,CAACC,IAAD,CAAlB;AACA,QAAIkB,MAAM,GAAGL,KAAK,GAAGI,CAAC,GAAGZ,SAAzB;;AACAL,IAAAA,IAAI,CAACc,MAAL,CAAYK,aAAZ,CAA0BlB,GAAG,CAAC,CAAD,CAA7B,EAAkCiB,MAAM,GAAG,CAA3C;;AACAlB,IAAAA,IAAI,CAACc,MAAL,CAAYK,aAAZ,CAA0BlB,GAAG,CAAC,CAAD,CAA7B,EAAkCiB,MAAM,GAAG,CAA3C;;AACAlB,IAAAA,IAAI,CAACc,MAAL,CAAYK,aAAZ,CAA0BlB,GAAG,CAAC,CAAD,CAA7B,EAAkCiB,MAAM,GAAG,CAA3C;;AACAlB,IAAAA,IAAI,CAACc,MAAL,CAAYK,aAAZ,CAA0BlB,GAAG,CAAC,CAAD,CAA7B,EAAkCiB,MAAM,GAAG,EAA3C;AACD;;AACD,MAAIE,GAAG,GAAGpB,IAAI,CAACc,MAAL,CAAYO,KAAZ,CAAkB,CAAlB,EAAqBb,KAAK,CAACI,MAA3B,CAAV;;AACAZ,EAAAA,IAAI,CAACc,MAAL,GAAcd,IAAI,CAACc,MAAL,CAAYO,KAAZ,CAAkBb,KAAK,CAACI,MAAxB,CAAd;AACA,SAAOjB,GAAG,CAACa,KAAD,EAAQY,GAAR,CAAV;AACD,CAlBD","sourcesContent":["var xor = require('buffer-xor')\nvar Buffer = require('safe-buffer').Buffer\nvar incr32 = require('../incr32')\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n"]},"metadata":{},"sourceType":"script"}