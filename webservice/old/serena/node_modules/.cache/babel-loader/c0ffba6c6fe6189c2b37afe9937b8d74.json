{"ast":null,"code":"/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar lodash = require(\"lodash\"),\n    merge = require(\"../util/merge\"),\n    uuid = require(\"uuid\");\n\nvar assign = lodash.assign;\nvar clone = lodash.clone;\nvar flatten = lodash.flatten;\nvar intersection = lodash.intersection;\nvar omit = lodash.omit;\nvar pick = lodash.pick;\nvar uniq = lodash.uniq;\n\nvar ALGORITHMS = require(\"../algorithms\"),\n    CONSTANTS = require(\"./constants.js\"),\n    HELPERS = require(\"./helpers.js\"),\n    UTIL = require(\"../util\");\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\n\n\nvar JWKBaseKeyObject = function (kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n  props = clone(props); // strip thumbprints if present\n\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function (a) {\n    var h = prints[a];\n\n    if (!kid) {\n      kid = h;\n\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  }); // force certain values\n\n  props.kty = kty;\n  props.kid = props.kid || kid || uuid(); // setup base info\n\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function (p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base)); // setup public information\n\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  } // setup private information\n\n\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  } // setup extra information\n\n\n  json.extra = omit(props, excluded); // TODO: validate 'alg' against supported algorithms\n  // setup calculated values\n\n  var keyLen;\n\n  if (keys.public && \"length\" in keys.public) {\n    keyLen = keys.public.length;\n  } else if (keys.private && \"length\" in keys.private) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  } // ### Public Properties ###\n\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n\n\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  }); // ### Public Methods ###\n\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function (hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function (result) {\n        if (result) {\n          prints[hash] = result;\n        }\n\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n\n  Object.defineProperty(this, \"algorithms\", {\n    value: function (mode) {\n      var modes = [];\n\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function (m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n\n  Object.defineProperty(this, \"supports\", {\n    value: function (alg, mode) {\n      return this.algorithms(mode).indexOf(alg) !== -1;\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n\n  Object.defineProperty(this, \"has\", {\n    value: function (name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base && name in json.base);\n      contains = contains || !!(keys.public && name in keys.public);\n      contains = contains || !!(json.extra && name in json.extra);\n      contains = contains || !!(isPrivate && keys.private && name in keys.private); // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n\n  Object.defineProperty(this, \"get\", {\n    value: function (name, isPrivate) {\n      var src;\n\n      if (json.base && name in json.base) {\n        src = json.base;\n      } else if (keys.public && name in keys.public) {\n        src = keys.public;\n      } else if (json.extra && name in json.extra) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && name in keys.private) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n\n  Object.defineProperty(this, \"toJSON\", {\n    value: function (isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n\n      var result = {}; // TODO: check for export restrictions\n\n      result = merge(result, json.base, json.public, \"boolean\" === typeof isPrivate && isPrivate ? json.private : {}, json.extra);\n      result = omit(result, excluded || []);\n      return result;\n    }\n  });\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n\n  Object.defineProperty(this, \"toPEM\", {\n    value: function (isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n\n      var k = isPrivate ? keys.private : keys.public;\n\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n\n  Object.defineProperty(this, \"toObject\", {\n    value: function (isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n\n      var result = {}; // TODO: check for export restrictions\n\n      result = merge(result, json.base, keys.public, \"boolean\" === typeof isPrivate && isPrivate ? keys.private : {}, json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n      return result;\n    }\n  });\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"sign\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.signKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"verify\", {\n    value: function (alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.verifyKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"encrypt\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.encryptKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"decrypt\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.decryptKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"wrap\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.wrapKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"unwrap\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.unwrapKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/jwk/basekey.js"],"names":["lodash","require","merge","uuid","assign","clone","flatten","intersection","omit","pick","uniq","ALGORITHMS","CONSTANTS","HELPERS","UTIL","JWKBaseKeyObject","kty","ks","props","cfg","Error","JSON","parse","excluded","keys","json","prints","kid","INTERNALS","THUMBPRINT_KEY","Object","forEach","a","h","Buffer","isBuffer","base64url","encode","decode","included","COMMON_PROPS","map","p","name","base","concat","public","publicKey","private","privateKey","extra","keyLen","length","NaN","defineProperty","value","enumerable","use","alg","hash","THUMBPRINT_HASH","toUpperCase","Promise","resolve","thumbprint","then","result","mode","modes","MODE_SIGN","push","MODE_VERIFY","MODE_ENCRYPT","MODE_DECRYPT","MODE_WRAP","MODE_UNWRAP","self","algs","m","algorithms","call","valid","indexOf","isPrivate","contains","src","Array","isArray","convertToPEM","k","data","reject","signKey","signProps","sign","mac","verifyKey","verifyProps","verify","encryptKey","encryptProps","encrypt","decryptKey","decryptProps","decrypt","wrapKey","wrapProps","unwrapKey","unwrapProps","module","exports"],"mappings":"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","sourcesContent":["/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar lodash = require(\"lodash\"),\n    merge = require(\"../util/merge\"),\n    uuid = require(\"uuid\");\n\nvar assign = lodash.assign;\nvar clone = lodash.clone;\nvar flatten = lodash.flatten;\nvar intersection = lodash.intersection;\nvar omit = lodash.omit;\nvar pick = lodash.pick;\nvar uniq = lodash.uniq;\n\nvar ALGORITHMS = require(\"../algorithms\"),\n    CONSTANTS = require(\"./constants.js\"),\n    HELPERS = require(\"./helpers.js\"),\n    UTIL = require(\"../util\");\n\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\nvar JWKBaseKeyObject = function(kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n\n  props = clone(props);\n  // strip thumbprints if present\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function(a) {\n    var h = prints[a];\n    if (!kid) {\n      kid = h;\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  });\n\n  // force certain values\n  props.kty = kty;\n  props.kid = props.kid || kid || uuid();\n\n  // setup base info\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function(p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base));\n\n  // setup public information\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  }\n\n  // setup private information\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  }\n\n  // setup extra information\n  json.extra = omit(props, excluded);\n\n  // TODO: validate 'alg' against supported algorithms\n\n  // setup calculated values\n  var keyLen;\n  if (keys.public && (\"length\" in keys.public)) {\n    keyLen = keys.public.length;\n  } else if (keys.private && (\"length\" in keys.private)) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  }\n\n  // ### Public Properties ###\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  });\n\n  // ### Public Methods ###\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function(hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function(result) {\n        if (result) {\n          prints[hash] = result;\n        }\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n  Object.defineProperty(this, \"algorithms\", {\n    value: function(mode) {\n      var modes = [];\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function(m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n  Object.defineProperty(this, \"supports\", {\n    value: function(alg, mode) {\n      return (this.algorithms(mode).indexOf(alg) !== -1);\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n  Object.defineProperty(this, \"has\", {\n    value: function(name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base &&\n                                (name in json.base));\n      contains = contains || !!(keys.public &&\n                                (name in keys.public));\n      contains = contains || !!(json.extra &&\n                                (name in json.extra));\n      contains = contains || !!(isPrivate &&\n                                keys.private &&\n                                (name in keys.private));\n      // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(name, isPrivate) {\n      var src;\n      if (json.base && (name in json.base)) {\n        src = json.base;\n      } else if (keys.public && (name in keys.public)) {\n        src = keys.public;\n      } else if (json.extra && (name in json.extra)) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && (name in keys.private)) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       json.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? json.private : {},\n                       json.extra);\n      result = omit(result, excluded || []);\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n  Object.defineProperty(this, \"toPEM\", {\n    value: function(isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n      var k = (isPrivate) ? keys.private : keys.public;\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n  Object.defineProperty(this, \"toObject\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       keys.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? keys.private : {},\n                       json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"sign\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.signKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"verify\", {\n    value: function(alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.verifyKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"encrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.encryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.decryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"wrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.wrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"unwrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.unwrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;\n"]},"metadata":{},"sourceType":"script"}