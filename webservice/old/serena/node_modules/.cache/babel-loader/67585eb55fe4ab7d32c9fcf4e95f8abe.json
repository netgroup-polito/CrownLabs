{"ast":null,"code":"'use strict';\n\nvar MissingRefError = require('./error_classes').MissingRef;\n\nmodule.exports = compileAsync;\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\n\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n\n  /* global Promise */\n\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(function (v) {\n      callback(null, v);\n    }, callback);\n  }\n\n  return p;\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema) ? compileAsync.call(self, {\n      $ref: $schema\n    }, true) : Promise.resolve();\n  }\n\n  function _compileAsync(schemaObj) {\n    try {\n      return self._compile(schemaObj);\n    } catch (e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n      var schemaPromise = self._loadingSchemas[ref];\n\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function () {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/ajv/lib/compile/async.js"],"names":["MissingRefError","require","MissingRef","module","exports","compileAsync","schema","meta","callback","self","_opts","loadSchema","Error","undefined","p","loadMetaSchemaOf","then","schemaObj","_addSchema","validate","_compileAsync","v","sch","$schema","getSchema","call","$ref","Promise","resolve","_compile","e","loadMissingSchema","ref","missingSchema","added","missingRef","schemaPromise","_loadingSchemas","removePromise","addSchema","_refs","_schemas"],"mappings":"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","sourcesContent":["'use strict';\n\nvar MissingRefError = require('./error_classes').MissingRef;\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}