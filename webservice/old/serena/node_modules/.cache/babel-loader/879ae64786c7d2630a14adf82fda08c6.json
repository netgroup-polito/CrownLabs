{"ast":null,"code":"var parseKeys = require('parse-asn1');\n\nvar randomBytes = require('randombytes');\n\nvar createHash = require('create-hash');\n\nvar mgf = require('./mgf');\n\nvar xor = require('./xor');\n\nvar BN = require('bn.js');\n\nvar withPublic = require('./withPublic');\n\nvar crt = require('browserify-rsa');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function publicEncrypt(publicKey, msg, reverse) {\n  var padding;\n\n  if (publicKey.padding) {\n    padding = publicKey.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n\n  var key = parseKeys(publicKey);\n  var paddedMsg;\n\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new BN(msg);\n\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n\n  if (reverse) {\n    return crt(paddedMsg, key);\n  } else {\n    return withPublic(paddedMsg, key);\n  }\n};\n\nfunction oaep(key, msg) {\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n\n  var ps = Buffer.alloc(k - mLen - hLen2 - 2);\n  var dblen = k - hLen - 1;\n  var seed = randomBytes(hLen);\n  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen));\n  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));\n}\n\nfunction pkcs1(key, msg, reverse) {\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n\n  var ps;\n\n  if (reverse) {\n    ps = Buffer.alloc(k - mLen - 3, 0xff);\n  } else {\n    ps = nonZero(k - mLen - 3);\n  }\n\n  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));\n}\n\nfunction nonZero(len) {\n  var out = Buffer.allocUnsafe(len);\n  var i = 0;\n  var cache = randomBytes(len * 2);\n  var cur = 0;\n  var num;\n\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len * 2);\n      cur = 0;\n    }\n\n    num = cache[cur++];\n\n    if (num) {\n      out[i++] = num;\n    }\n  }\n\n  return out;\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/public-encrypt/publicEncrypt.js"],"names":["parseKeys","require","randomBytes","createHash","mgf","xor","BN","withPublic","crt","Buffer","module","exports","publicEncrypt","publicKey","msg","reverse","padding","key","paddedMsg","oaep","pkcs1","cmp","modulus","Error","k","byteLength","mLen","length","iHash","update","alloc","digest","hLen","hLen2","ps","dblen","seed","maskedDb","concat","maskedSeed","nonZero","from","len","out","allocUnsafe","i","cache","cur","num"],"mappings":"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","sourcesContent":["var parseKeys = require('parse-asn1')\nvar randomBytes = require('randombytes')\nvar createHash = require('create-hash')\nvar mgf = require('./mgf')\nvar xor = require('./xor')\nvar BN = require('bn.js')\nvar withPublic = require('./withPublic')\nvar crt = require('browserify-rsa')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function publicEncrypt (publicKey, msg, reverse) {\n  var padding\n  if (publicKey.padding) {\n    padding = publicKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n  var key = parseKeys(publicKey)\n  var paddedMsg\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg)\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    paddedMsg = new BN(msg)\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus')\n    }\n  } else {\n    throw new Error('unknown padding')\n  }\n  if (reverse) {\n    return crt(paddedMsg, key)\n  } else {\n    return withPublic(paddedMsg, key)\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var mLen = msg.length\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  var hLen2 = 2 * hLen\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long')\n  }\n  var ps = Buffer.alloc(k - mLen - hLen2 - 2)\n  var dblen = k - hLen - 1\n  var seed = randomBytes(hLen)\n  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen))\n  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))\n}\nfunction pkcs1 (key, msg, reverse) {\n  var mLen = msg.length\n  var k = key.modulus.byteLength()\n  if (mLen > k - 11) {\n    throw new Error('message too long')\n  }\n  var ps\n  if (reverse) {\n    ps = Buffer.alloc(k - mLen - 3, 0xff)\n  } else {\n    ps = nonZero(k - mLen - 3)\n  }\n  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))\n}\nfunction nonZero (len) {\n  var out = Buffer.allocUnsafe(len)\n  var i = 0\n  var cache = randomBytes(len * 2)\n  var cur = 0\n  var num\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len * 2)\n      cur = 0\n    }\n    num = cache[cur++]\n    if (num) {\n      out[i++] = num\n    }\n  }\n  return out\n}\n"]},"metadata":{},"sourceType":"script"}