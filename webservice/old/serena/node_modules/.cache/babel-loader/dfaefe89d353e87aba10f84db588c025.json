{"ast":null,"code":"/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar lodash = require(\"lodash\"),\n    util = require(\"../util\"),\n    generateCEK = require(\"./helpers\").generateCEK,\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice,\n    zlib = require(\"zlib\"),\n    CONSTANTS = require(\"../algorithms/constants\");\n\nvar assign = lodash.assign;\nvar clone = lodash.clone;\n\nvar DEFAULTS = require(\"./defaults\");\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\n\n\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      protectAll = !!cfg.protectAll,\n      content = Buffer.alloc(0);\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n\n  Object.defineProperty(this, \"zip\", {\n    get: function () {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n\n  Object.defineProperty(this, \"compact\", {\n    get: function () {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n\n  Object.defineProperty(this, \"format\", {\n    get: function () {\n      return format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n\n  Object.defineProperty(this, \"protected\", {\n    get: function () {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n\n  Object.defineProperty(this, \"header\", {\n    get: function () {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"update\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n\n        if (content.length) {\n          content = Buffer.concat([content, data], content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"final\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      } // last-minute data\n\n\n      this.update(data, encoding); // mark as done...ish\n\n      finalized = true;\n      var promise = Promise.resolve({}); // determine CEK and IV\n\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function (jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n\n        return jwe;\n      }); // process recipients\n\n      promise = promise.then(function (jwe) {\n        var procR = function (r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n          var algKey = r.key,\n              algAlg = props.alg; // generate Ephemeral EC Key\n\n          var tks, rpromise;\n\n          if ((props.alg || \"\").indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          } // encrypt the CEK\n\n\n          rpromise = rpromise.then(function () {\n            var cek, p; // special case 'alg=dir'\n\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function (jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n\n                encKey = generateCEK(encAlg);\n              }\n\n              p = encKey.then(function (jwk) {\n                cek = jwk.get(\"k\", true); // algKey may or may not be a promise\n\n                return algKey;\n              });\n              p = p.then(function (algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n\n            return p;\n          });\n          rpromise = rpromise.then(function (wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {}, wrapped.header);\n            }\n\n            return rjwe;\n          });\n          return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function (rcpts) {\n          var single = 1 === rcpts.length;\n          rcpts = rcpts.map(function (r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function (rcpts) {\n          jwe.recipients = rcpts.filter(function (r) {\n            return !!r;\n          });\n          return jwe;\n        });\n        return p;\n      }); // normalize headers\n\n      var props = {};\n      promise = promise.then(function (jwe) {\n        var protect, lenProtect, unprotect, lenUnprotect;\n        unprotect = clone(fields);\n\n        if (protectAll && jwe.recipients.length === 1 || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = {};\n          protect = assign({}, unprotect, jwe.recipients[0].header);\n          lenProtect = Object.keys(protect).length;\n          unprotect = undefined;\n          lenUnprotect = 0;\n          delete jwe.recipients[0].header;\n\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function (f) {\n            // remove protected header values from body unprotected header\n            if (!(f in unprotect)) {\n              return;\n            }\n\n            protect[f] = unprotect[f];\n            lenProtect++;\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n          jwe.recipients = (jwe.recipients || []).map(function (rcpt) {\n            rcpt = rcpt || {};\n            var header = rcpt.header;\n\n            if (header) {\n              Object.keys(header).forEach(function (f) {\n                if (f in protect) {\n                  delete header[f];\n                }\n              });\n\n              if (!Object.keys(header).length) {\n                delete rcpt.header;\n              }\n            }\n\n            return rcpt;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        } // \"serialize\" (and setup merged props)\n\n\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      }); // (OPTIONAL) compress plaintext\n\n      promise = promise.then(function (jwe) {\n        var pdata = content;\n\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function (resolve, reject) {\n            zlib.deflateRaw(Buffer.from(pdata, \"binary\"), function (err, data) {\n              if (err) {\n                reject(err);\n              } else {\n                jwe.plaintext = data;\n                resolve(jwe);\n              }\n            });\n          });\n        }\n\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      }); // encrypt plaintext\n\n      promise = promise.then(function (jwe) {\n        props.adata = jwe.protected;\n\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = Buffer.from(props.adata, \"utf8\");\n        } // calculate IV\n\n\n        var iv = cfg.iv || util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function (encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function (result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n\n            if (\"aad\" in cfg && cfg.aad != null) {\n              jwe.aad = cfg.aad;\n            }\n\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      }); // (OPTIONAL) compact/flattened results\n\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function (jwe) {\n            var compact = new Array(5);\n            compact[0] = jwe.protected;\n\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n\n        case \"flattened\":\n          promise = promise.then(function (jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n\n            [\"header\", \"encrypted_key\"].forEach(function (f) {\n              if (!rcpt) {\n                return;\n              }\n\n              if (!(f in rcpt)) {\n                return;\n              }\n\n              if (!rcpt[f]) {\n                return;\n              }\n\n              if (\"object\" === typeof rcpt[f] && !Object.keys(rcpt[f]).length) {\n                return;\n              }\n\n              flattened[f] = rcpt[f];\n            });\n\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n            return flattened;\n          });\n          break;\n\n        case \"general\":\n          promise = promise.then(function (jwe) {\n            var recipients = jwe.recipients || [];\n            recipients = recipients.map(function (rcpt) {\n              if (!Object.keys(rcpt).length) {\n                return undefined;\n              }\n\n              return rcpt;\n            });\n            recipients = recipients.filter(function (rcpt) {\n              return !!rcpt;\n            });\n\n            if (recipients.length) {\n              jwe.recipients = recipients;\n            } else {\n              delete jwe.recipients;\n            }\n\n            return jwe;\n          });\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n      rcptStart = 1,\n      rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) || opts && \"kty\" in opts || opts && \"key\" in opts && (JWK.isKey(opts.key) || \"kty\" in opts.key)) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  } // fixup options\n\n\n  options = assign(clone(DEFAULTS), options); // setup header fields\n\n  var fields = clone(options.fields || {});\n\n  if (options.zip) {\n    fields.zip = typeof options.zip === \"boolean\" ? options.zip ? \"DEF\" : false : options.zip;\n  }\n\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n\n    /* eslint no-fallthrough: [0] */\n\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n\n      break;\n  } // note protected fields (globally)\n  // protected fields are global only\n\n\n  var protectAll = false;\n\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function (r, idx) {\n    var p; // resolve a key\n\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function (k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function (k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    } // convert ephemeral key (if present)\n\n\n    if (r.epk) {\n      p = p.then(function (recipient) {\n        return JWK.asKey(r.epk).then(function (epk) {\n          recipient.epk = epk;\n          return recipient;\n        });\n      });\n    } // resolve the complete recipient\n\n\n    p = p.then(function (recipient) {\n      var key = recipient.key; // prepare the recipient header\n\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header); // ensure key protection algorithm is set\n\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n        header.alg = props.alg;\n      }\n\n      if (!props.alg) {\n        return Promise.reject(new Error(\"key not valid for encrypting to recipient \" + idx));\n      }\n\n      header.alg = props.alg; // determine the key reference\n\n      var ref = recipient.reference;\n      delete recipient.reference;\n\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function (k) {\n          return k in header;\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n\n      var jwk;\n\n      if (ref) {\n        jwk = key.toJSON();\n\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      } // freeze recipient\n\n\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n    return p;\n  }); // create and configure encryption\n\n  var cfg = {\n    aad: \"aad\" in options ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/jwe/encrypt.js"],"names":["lodash","require","util","generateCEK","JWK","slice","zlib","CONSTANTS","assign","clone","DEFAULTS","JWEEncrypter","cfg","fields","recipients","finalized","format","protectAll","content","Buffer","alloc","Object","defineProperty","get","zip","enumerable","protect","value","data","encoding","Error","asBuffer","length","concat","Promise","reject","update","promise","resolve","encAlg","enc","encKey","then","jwe","cek","asKey","procR","r","one","props","header","algKey","key","algAlg","alg","tks","rpromise","indexOf","keystore","temp","epk","toJSON","toObject","generate","p","jwk","algorithms","MODE_ENCRYPT","once","direct","contentAlg","wrap","wrapped","rjwe","base64url","encode","kty","k","encrypted_key","keys","all","rcpts","single","map","filter","lenProtect","unprotect","lenUnprotect","undefined","splice","forEach","f","rcpt","unprotected","JSON","stringify","protected","pdata","plaintext","deflateRaw","from","err","adata","aad","iv","randomBytes","NONCELENGTH","decode","kdata","epu","epv","encrypt","result","ciphertext","tag","compact","Array","join","flattened","createEncrypt","opts","options","rcptStart","rcptList","arguments","isKey","isArray","idx","reference","recipient","MODE_WRAP","ref","some","freeze","module","exports","encrypter"],"mappings":"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","sourcesContent":["/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar lodash = require(\"lodash\"),\n    util = require(\"../util\"),\n    generateCEK = require(\"./helpers\").generateCEK,\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice,\n    zlib = require(\"zlib\"),\n    CONSTANTS = require(\"../algorithms/constants\");\n\nvar assign = lodash.assign;\nvar clone = lodash.clone;\n\nvar DEFAULTS = require(\"./defaults\");\n\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n    format = cfg.format || \"general\",\n    protectAll = !!cfg.protectAll,\n    content = Buffer.alloc(0);\n\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n  Object.defineProperty(this, \"zip\", {\n    get: function() {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n  Object.defineProperty(this, \"compact\", {\n    get: function() { return \"compact\" === format; },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n  Object.defineProperty(this, \"format\", {\n    get: function() { return format; },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n  Object.defineProperty(this, \"protected\", {\n    get: function() {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n  Object.defineProperty(this, \"header\", {\n    get: function() {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise = Promise.resolve({});\n\n      // determine CEK and IV\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function(jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n        return jwe;\n      });\n\n      // process recipients\n      promise = promise.then(function(jwe) {\n        var procR = function(r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n\n          var algKey = r.key,\n              algAlg = props.alg;\n\n          // generate Ephemeral EC Key\n          var tks,\n              rpromise;\n          if ((props.alg || \"\").indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          }\n\n          // encrypt the CEK\n          rpromise = rpromise.then(function() {\n            var cek,\n                p;\n            // special case 'alg=dir'\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function(jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n                encKey = generateCEK(encAlg);\n              }\n              p = encKey.then(function(jwk) {\n                cek = jwk.get(\"k\", true);\n                // algKey may or may not be a promise\n                return algKey;\n              });\n              p = p.then(function(algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n            return p;\n          });\n          rpromise = rpromise.then(function(wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {},\n                                     wrapped.header);\n            }\n\n            return rjwe;\n           });\n           return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function(rcpts) {\n          var single = (1 === rcpts.length);\n          rcpts = rcpts.map(function(r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function(rcpts) {\n          jwe.recipients = rcpts.filter(function(r) { return !!r; });\n          return jwe;\n        });\n        return p;\n      });\n\n      // normalize headers\n      var props = {};\n      promise = promise.then(function(jwe) {\n        var protect,\n          lenProtect,\n          unprotect,\n          lenUnprotect;\n\n        unprotect = clone(fields);\n        if ((protectAll && jwe.recipients.length === 1) || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = {};\n          protect = assign({},\n                     unprotect,\n                    jwe.recipients[0].header);\n          lenProtect = Object.keys(protect).length;\n\n          unprotect = undefined;\n          lenUnprotect = 0;\n\n          delete jwe.recipients[0].header;\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function(f) {\n            // remove protected header values from body unprotected header\n            if (!(f in unprotect)) {\n              return;\n            }\n            protect[f] = unprotect[f];\n            lenProtect++;\n\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n\n          jwe.recipients = (jwe.recipients || []).map(function(rcpt) {\n            rcpt = rcpt || {};\n            var header = rcpt.header;\n            if (header) {\n              Object.keys(header).forEach(function (f) {\n                if (f in protect) { delete header[f]; }\n              });\n              if (!Object.keys(header).length) {\n                delete rcpt.header;\n              }\n            }\n            return rcpt;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        }\n\n        // \"serialize\" (and setup merged props)\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      });\n\n      // (OPTIONAL) compress plaintext\n      promise = promise.then(function(jwe) {\n        var pdata = content;\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function(resolve, reject) {\n            zlib.deflateRaw(Buffer.from(pdata, \"binary\"), function(err, data) {\n              if (err) {\n                reject(err);\n              }\n              else {\n                jwe.plaintext = data;\n                resolve(jwe);\n              }\n            });\n          });\n        }\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      });\n\n      // encrypt plaintext\n      promise = promise.then(function(jwe) {\n        props.adata = jwe.protected;\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = Buffer.from(props.adata, \"utf8\");\n        }\n        // calculate IV\n        var iv = cfg.iv ||\n                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function(encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function(result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n            if (\"aad\" in cfg && cfg.aad != null) {\n             jwe.aad = cfg.aad;\n            }\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      });\n\n      // (OPTIONAL) compact/flattened results\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jwe) {\n            var compact = new Array(5);\n\n            compact[0] = jwe.protected;\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n            [\"header\", \"encrypted_key\"].forEach(function(f) {\n              if (!rcpt) { return; }\n              if (!(f in rcpt)) { return; }\n              if (!rcpt[f]) { return; }\n              if (\"object\" === typeof rcpt[f] && !Object.keys(rcpt[f]).length) { return; }\n              flattened[f] = rcpt[f];\n            });\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n\n            return flattened;\n          });\n          break;\n        case \"general\":\n          promise = promise.then(function(jwe) {\n            var recipients = jwe.recipients || [];\n            recipients = recipients.map(function (rcpt) {\n              if (!Object.keys(rcpt).length) { return undefined; }\n              return rcpt;\n            });\n            recipients = recipients.filter(function (rcpt) { return !!rcpt; });\n            if (recipients.length) {\n              jwe.recipients = recipients;\n            } else {\n              delete jwe.recipients;\n            }\n\n            return jwe;\n          });\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n    rcptStart = 1,\n    rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n        (opts && \"kty\" in opts) ||\n        (opts && \"key\" in opts &&\n        (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  }\n\n  // fixup options\n  options = assign(clone(DEFAULTS), options);\n\n  // setup header fields\n  var fields = clone(options.fields || {});\n  if (options.zip) {\n    fields.zip = (typeof options.zip === \"boolean\") ?\n           (options.zip ? \"DEF\" : false) :\n           options.zip;\n  }\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n      /* eslint no-fallthrough: [0] */\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n      break;\n  }\n\n  // note protected fields (globally)\n  // protected fields are global only\n  var protectAll = false;\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function(r, idx) {\n    var p;\n\n    // resolve a key\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function(k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    }\n\n    // convert ephemeral key (if present)\n    if (r.epk) {\n      p = p.then(function(recipient) {\n        return JWK.asKey(r.epk).\n          then(function(epk) {\n            recipient.epk = epk;\n            return recipient;\n          });\n      });\n    }\n\n    // resolve the complete recipient\n    p = p.then(function(recipient) {\n      var key = recipient.key;\n\n      // prepare the recipient header\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header);\n\n      // ensure key protection algorithm is set\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n        header.alg = props.alg;\n      }\n      if (!props.alg) {\n        return Promise.reject(new Error(\"key not valid for encrypting to recipient \" + idx));\n      }\n      header.alg = props.alg;\n\n      // determine the key reference\n      var ref = recipient.reference;\n      delete recipient.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // freeze recipient\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n\n    return p;\n  });\n\n  // create and configure encryption\n  var cfg = {\n    aad: (\"aad\" in options) ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};\n"]},"metadata":{},"sourceType":"script"}