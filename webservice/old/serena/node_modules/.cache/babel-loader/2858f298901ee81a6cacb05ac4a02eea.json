{"ast":null,"code":"/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nforge.cipher = forge.cipher || {}; // supported cipher modes\n\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function (options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function (options) {};\n\nmodes.ecb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // write output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // decrypt block\n\n\n  this.cipher.decrypt(this._inBlock, this._outBlock); // write output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  } // ensure padding byte count is valid\n\n\n  var len = output.length();\n  var count = output.at(len - 1);\n\n  if (count > this.blockSize << 2) {\n    return false;\n  } // trim off padding bytes\n\n\n  output.truncate(count);\n  return true;\n};\n/** Cipher-block Chaining (CBC) **/\n\n\nmodes.cbc = function (options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function (options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if (options.iv === null) {\n    // must have a previous block\n    if (!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n\n    this._iv = this._prev.slice(0);\n  } else if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // write output, save previous block\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // decrypt block\n\n\n  this.cipher.decrypt(this._inBlock, this._outBlock); // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  } // ensure padding byte count is valid\n\n\n  var len = output.length();\n  var count = output.at(len - 1);\n\n  if (count > this.blockSize << 2) {\n    return false;\n  } // trim off padding bytes\n\n\n  output.truncate(count);\n  return true;\n};\n/** Cipher feedback (CFB) **/\n\n\nmodes.cfb = function (options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output, write input as partial output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block (CFB always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output, write input as partial output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n/** Output feedback (OFB) **/\n\n\nmodes.ofb = function (options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (input.length() === 0) {\n    return true;\n  } // encrypt block (OFB always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n/** Counter (CTR) **/\n\nmodes.ctr = function (options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block (CTR always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    } // XOR input with output\n\n\n    this._partialOutput.clear();\n\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if (partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    } // skip any previous partial bytes\n\n\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if (partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  } // block complete, increment counter (input block)\n\n\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function (options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0; // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // ensure IV is a byte buffer\n\n\n  var iv = forge.util.createBuffer(options.iv); // no ciphered data processed yet\n\n  this._cipherLength = 0; // default additional data is none\n\n  var additionalData;\n\n  if ('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  } // default tag length is 128 bits\n\n\n  if ('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  } // if tag is given, ensure tag matches tag length\n\n\n  this._tag = null;\n\n  if (options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n\n    if (this._tag.length !== this._tagLength / 8) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  } // create tmp storage for hash calculation\n\n\n  this._hashBlock = new Array(this._ints); // no tag generated yet\n\n  this.tag = null; // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey); // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits); // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n\n  var ivLength = iv.length();\n\n  if (ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n\n    while (iv.length() > 0) {\n      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n\n    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  } // generate ICB (initial counter block)\n\n\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0; // consume authentication data\n\n  additionalData = forge.util.createBuffer(additionalData); // save additional data length as a BE 64-bit number\n\n  this._aDataLength = from64To32(additionalData.length() * 8); // pad additional data to 128 bit (16 byte) block size\n\n  var overflow = additionalData.length() % this.blockSize;\n\n  if (overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n\n  this._s = [0, 0, 0, 0];\n\n  while (additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    } // XOR input with output\n\n\n    this._partialOutput.clear();\n\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if (partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if (finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow; // truncate for hash function\n\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      } // get output block for hashing\n\n\n      for (var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n\n      this._partialOutput.read -= this.blockSize;\n    } // skip any previous partial bytes\n\n\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if (partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  } // update hash block S\n\n\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock); // increment counter (input block)\n\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n\n  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  } // encrypt block (GCM always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // increment counter (input block)\n\n  inc32(this._inBlock); // update hash block S\n\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock); // XOR hash input with output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  } // increment cipher data length\n\n\n  if (inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function (output, options) {\n  var rval = true; // handle overflow\n\n  if (options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  } // handle authentication tag\n\n\n  this.tag = forge.util.createBuffer(); // concatenate additional data length with cipher length\n\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8)); // include lengths in hash\n\n\n  this._s = this.ghash(this._hashSubkey, this._s, lengths); // do GCTR(J_0, S)\n\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n\n  for (var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  } // trim tag to length\n\n\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8)); // check authentication tag\n\n  if (options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\n\n\nmodes.gcm.prototype.multiply = function (x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0); // calculate Z_128 (block has 128 bits)\n\n  for (var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n\n    if (x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    } // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n\n\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function (x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1; // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n\n  for (var i = 3; i > 0; --i) {\n    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n  } // shift the first integer normally\n\n\n  out[0] = x[0] >>> 1; // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n\n  if (lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function (x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n\n  for (var i = 0; i < 32; ++i) {\n    var idx = i / 8 | 0;\n    var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n\n  return z;\n};\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\n\n\nmodes.gcm.prototype.ghash = function (h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y); //return this.multiply(y, h);\n};\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\n\n\nmodes.gcm.prototype.generateHashTable = function (h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n\n  for (var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = i / perInt | 0;\n    var shft = (perInt - 1 - i % perInt) * bits;\n    tmp[idx] = 1 << bits - 1 << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n\n  return m;\n};\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\n\n\nmodes.gcm.prototype.generateSubHashTable = function (mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n\n  while (i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n\n  i = 2;\n\n  while (i < half) {\n    for (var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];\n    }\n\n    i *= 2;\n  }\n\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n\n  for (i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n\n  return m;\n};\n/** Utility functions */\n\n\nfunction transformIV(iv) {\n  if (typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if (forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n\n    for (var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n\n  if (!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [num / 0x100000000 | 0, num & 0xFFFFFFFF];\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/cipherModes.js"],"names":["forge","require","cipher","modes","module","exports","ecb","options","name","blockSize","_ints","_inBlock","Array","_outBlock","prototype","start","encrypt","input","output","finish","length","i","getInt32","putInt32","decrypt","pad","padding","fillWithByte","unpad","overflow","len","count","at","truncate","cbc","iv","_prev","Error","_iv","slice","transformIV","cfb","_partialBlock","_partialOutput","util","createBuffer","_partialBytes","inputLength","partialBytes","clear","read","getBytes","putBytes","ofb","ctr","inc32","gcm","_R","_cipherLength","additionalData","_tagLength","tagLength","_tag","tag","_hashBlock","_hashSubkey","componentBits","_m","generateHashTable","ivLength","_j0","ghash","concat","from64To32","_aDataLength","_s","afterFinish","rval","lengths","bytes","multiply","x","y","z_i","v_i","x_i","pow","out","lsb","tableMultiply","z","idx","ah","h","bits","multiplier","perInt","size","m","tmp","shft","generateSubHashTable","mid","half","j","m_i","m_j","c","isArray","putByte","block","num"],"mappings":"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","sourcesContent":["/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.cipher = forge.cipher || {};\n\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function(options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function(options) {};\n\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher-block Chaining (CBC) **/\n\nmodes.cbc = function(options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function(options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if(options.iv === null) {\n    // must have a previous block\n    if(!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n    this._iv = this._prev.slice(0);\n  } else if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous block\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher feedback (CFB) **/\n\nmodes.cfb = function(options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\n/** Output feedback (OFB) **/\n\nmodes.ofb = function(options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(input.length() === 0) {\n    return true;\n  }\n\n  // encrypt block (OFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n\n/** Counter (CTR) **/\n\nmodes.ctr = function(options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CTR always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // block complete, increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function(options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n\n  // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // ensure IV is a byte buffer\n  var iv = forge.util.createBuffer(options.iv);\n\n  // no ciphered data processed yet\n  this._cipherLength = 0;\n\n  // default additional data is none\n  var additionalData;\n  if('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  }\n\n  // default tag length is 128 bits\n  if('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  }\n\n  // if tag is given, ensure tag matches tag length\n  this._tag = null;\n  if(options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n    if(this._tag.length !== (this._tagLength / 8)) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  }\n\n  // create tmp storage for hash calculation\n  this._hashBlock = new Array(this._ints);\n\n  // no tag generated yet\n  this.tag = null;\n\n  // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n\n  // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n\n  // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n  var ivLength = iv.length();\n  if(ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n    while(iv.length() > 0) {\n      this._j0 = this.ghash(\n        this._hashSubkey, this._j0,\n        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n    this._j0 = this.ghash(\n      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  }\n\n  // generate ICB (initial counter block)\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0;\n\n  // consume authentication data\n  additionalData = forge.util.createBuffer(additionalData);\n  // save additional data length as a BE 64-bit number\n  this._aDataLength = from64To32(additionalData.length() * 8);\n  // pad additional data to 128 bit (16 byte) block size\n  var overflow = additionalData.length() % this.blockSize;\n  if(overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n  this._s = [0, 0, 0, 0];\n  while(additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32()\n    ]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if(finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow;\n        // truncate for hash function\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n\n      // get output block for hashing\n      for(var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n      this._partialOutput.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // update hash block S\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  }\n\n  // encrypt block (GCM always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n\n  // update hash block S\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n\n  // XOR hash input with output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  }\n\n  // increment cipher data length\n  if(inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function(output, options) {\n  var rval = true;\n\n  // handle overflow\n  if(options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  }\n\n  // handle authentication tag\n  this.tag = forge.util.createBuffer();\n\n  // concatenate additional data length with cipher length\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n\n  // include lengths in hash\n  this._s = this.ghash(this._hashSubkey, this._s, lengths);\n\n  // do GCTR(J_0, S)\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n  for(var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  }\n\n  // trim tag to length\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n\n  // check authentication tag\n  if(options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\nmodes.gcm.prototype.multiply = function(x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0);\n\n  // calculate Z_128 (block has 128 bits)\n  for(var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\n    if(x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    }\n\n    // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function(x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1;\n\n  // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n  for(var i = 3; i > 0; --i) {\n    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\n  }\n  // shift the first integer normally\n  out[0] = x[0] >>> 1;\n\n  // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n  if(lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function(x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n  for(var i = 0; i < 32; ++i) {\n    var idx = (i / 8) | 0;\n    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n  return z;\n};\n\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\nmodes.gcm.prototype.ghash = function(h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y);\n  //return this.multiply(y, h);\n};\n\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateHashTable = function(h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n  for(var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = (i / perInt) | 0;\n    var shft = ((perInt - 1 - (i % perInt)) * bits);\n    tmp[idx] = (1 << (bits - 1)) << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n  return m;\n};\n\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n  while(i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n  i = 2;\n  while(i < half) {\n    for(var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [\n        m_i[0] ^ m_j[0],\n        m_i[1] ^ m_j[1],\n        m_i[2] ^ m_j[2],\n        m_i[3] ^ m_j[3]\n      ];\n    }\n    i *= 2;\n  }\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n  for(i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n  return m;\n};\n\n/** Utility functions */\n\nfunction transformIV(iv) {\n  if(typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if(forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n    for(var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n  if(!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\n}\n"]},"metadata":{},"sourceType":"script"}