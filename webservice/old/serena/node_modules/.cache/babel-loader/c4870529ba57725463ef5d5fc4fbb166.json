{"ast":null,"code":"// Copyright 2017 Joyent, Inc.\nmodule.exports = PrivateKey;\n\nvar assert = require('assert-plus');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar algs = require('./algs');\n\nvar crypto = require('crypto');\n\nvar Fingerprint = require('./fingerprint');\n\nvar Signature = require('./signature');\n\nvar errs = require('./errors');\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar dhe = require('./dhe');\n\nvar generateECDSA = dhe.generateECDSA;\nvar generateED25519 = dhe.generateED25519;\n\nvar edCompat = require('./ed-compat');\n\nvar nacl = require('tweetnacl');\n\nvar Key = require('./key');\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar KeyEncryptedError = errs.KeyEncryptedError;\nvar formats = {};\nformats['auto'] = require('./formats/auto');\nformats['pem'] = require('./formats/pem');\nformats['pkcs1'] = require('./formats/pkcs1');\nformats['pkcs8'] = require('./formats/pkcs8');\nformats['rfc4253'] = require('./formats/rfc4253');\nformats['ssh-private'] = require('./formats/ssh-private');\nformats['openssh'] = formats['ssh-private'];\nformats['ssh'] = formats['ssh-private'];\nformats['dnssec'] = require('./formats/dnssec');\n\nfunction PrivateKey(opts) {\n  assert.object(opts, 'options');\n  Key.call(this, opts);\n  this._pubCache = undefined;\n}\n\nutil.inherits(PrivateKey, Key);\nPrivateKey.formats = formats;\n\nPrivateKey.prototype.toBuffer = function (format, options) {\n  if (format === undefined) format = 'pkcs1';\n  assert.string(format, 'format');\n  assert.object(formats[format], 'formats[format]');\n  assert.optionalObject(options, 'options');\n  return formats[format].write(this, options);\n};\n\nPrivateKey.prototype.hash = function (algo, type) {\n  return this.toPublic().hash(algo, type);\n};\n\nPrivateKey.prototype.fingerprint = function (algo, type) {\n  return this.toPublic().fingerprint(algo, type);\n};\n\nPrivateKey.prototype.toPublic = function () {\n  if (this._pubCache) return this._pubCache;\n  var algInfo = algs.info[this.type];\n  var pubParts = [];\n\n  for (var i = 0; i < algInfo.parts.length; ++i) {\n    var p = algInfo.parts[i];\n    pubParts.push(this.part[p]);\n  }\n\n  this._pubCache = new Key({\n    type: this.type,\n    source: this,\n    parts: pubParts\n  });\n  if (this.comment) this._pubCache.comment = this.comment;\n  return this._pubCache;\n};\n\nPrivateKey.prototype.derive = function (newType) {\n  assert.string(newType, 'type');\n  var priv, pub, pair;\n\n  if (this.type === 'ed25519' && newType === 'curve25519') {\n    priv = this.part.k.data;\n    if (priv[0] === 0x00) priv = priv.slice(1);\n    pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n    pub = Buffer.from(pair.publicKey);\n    return new PrivateKey({\n      type: 'curve25519',\n      parts: [{\n        name: 'A',\n        data: utils.mpNormalize(pub)\n      }, {\n        name: 'k',\n        data: utils.mpNormalize(priv)\n      }]\n    });\n  } else if (this.type === 'curve25519' && newType === 'ed25519') {\n    priv = this.part.k.data;\n    if (priv[0] === 0x00) priv = priv.slice(1);\n    pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n    pub = Buffer.from(pair.publicKey);\n    return new PrivateKey({\n      type: 'ed25519',\n      parts: [{\n        name: 'A',\n        data: utils.mpNormalize(pub)\n      }, {\n        name: 'k',\n        data: utils.mpNormalize(priv)\n      }]\n    });\n  }\n\n  throw new Error('Key derivation not supported from ' + this.type + ' to ' + newType);\n};\n\nPrivateKey.prototype.createVerify = function (hashAlgo) {\n  return this.toPublic().createVerify(hashAlgo);\n};\n\nPrivateKey.prototype.createSign = function (hashAlgo) {\n  if (hashAlgo === undefined) hashAlgo = this.defaultHashAlgorithm();\n  assert.string(hashAlgo, 'hash algorithm');\n  /* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\n  if (this.type === 'ed25519' && edCompat !== undefined) return new edCompat.Signer(this, hashAlgo);\n  if (this.type === 'curve25519') throw new Error('Curve25519 keys are not suitable for ' + 'signing or verification');\n  var v, nm, err;\n\n  try {\n    nm = hashAlgo.toUpperCase();\n    v = crypto.createSign(nm);\n  } catch (e) {\n    err = e;\n  }\n\n  if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {\n    nm = 'RSA-';\n    nm += hashAlgo.toUpperCase();\n    v = crypto.createSign(nm);\n  }\n\n  assert.ok(v, 'failed to create verifier');\n  var oldSign = v.sign.bind(v);\n  var key = this.toBuffer('pkcs1');\n  var type = this.type;\n  var curve = this.curve;\n\n  v.sign = function () {\n    var sig = oldSign(key);\n    if (typeof sig === 'string') sig = Buffer.from(sig, 'binary');\n    sig = Signature.parse(sig, type, 'asn1');\n    sig.hashAlgorithm = hashAlgo;\n    sig.curve = curve;\n    return sig;\n  };\n\n  return v;\n};\n\nPrivateKey.parse = function (data, format, options) {\n  if (typeof data !== 'string') assert.buffer(data, 'data');\n  if (format === undefined) format = 'auto';\n  assert.string(format, 'format');\n  if (typeof options === 'string') options = {\n    filename: options\n  };\n  assert.optionalObject(options, 'options');\n  if (options === undefined) options = {};\n  assert.optionalString(options.filename, 'options.filename');\n  if (options.filename === undefined) options.filename = '(unnamed)';\n  assert.object(formats[format], 'formats[format]');\n\n  try {\n    var k = formats[format].read(data, options);\n    assert.ok(k instanceof PrivateKey, 'key is not a private key');\n    if (!k.comment) k.comment = options.filename;\n    return k;\n  } catch (e) {\n    if (e.name === 'KeyEncryptedError') throw e;\n    throw new KeyParseError(options.filename, format, e);\n  }\n};\n\nPrivateKey.isPrivateKey = function (obj, ver) {\n  return utils.isCompatible(obj, PrivateKey, ver);\n};\n\nPrivateKey.generate = function (type, options) {\n  if (options === undefined) options = {};\n  assert.object(options, 'options');\n\n  switch (type) {\n    case 'ecdsa':\n      if (options.curve === undefined) options.curve = 'nistp256';\n      assert.string(options.curve, 'options.curve');\n      return generateECDSA(options.curve);\n\n    case 'ed25519':\n      return generateED25519();\n\n    default:\n      throw new Error('Key generation not supported with key ' + 'type \"' + type + '\"');\n  }\n};\n/*\n * API versions for PrivateKey:\n * [1,0] -- initial ver\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n * [1,2] -- added defaultHashAlgorithm\n * [1,3] -- added derive, ed, createDH\n * [1,4] -- first tagged version\n * [1,5] -- changed ed25519 part names and format\n * [1,6] -- type arguments for hash() and fingerprint()\n */\n\n\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\nPrivateKey._oldVersionDetect = function (obj) {\n  assert.func(obj.toPublic);\n  assert.func(obj.createSign);\n  if (obj.derive) return [1, 3];\n  if (obj.defaultHashAlgorithm) return [1, 2];\n  if (obj.formats['auto']) return [1, 1];\n  return [1, 0];\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/sshpk/lib/private-key.js"],"names":["module","exports","PrivateKey","assert","require","Buffer","algs","crypto","Fingerprint","Signature","errs","util","utils","dhe","generateECDSA","generateED25519","edCompat","nacl","Key","InvalidAlgorithmError","KeyParseError","KeyEncryptedError","formats","opts","object","call","_pubCache","undefined","inherits","prototype","toBuffer","format","options","string","optionalObject","write","hash","algo","type","toPublic","fingerprint","algInfo","info","pubParts","i","parts","length","p","push","part","source","comment","derive","newType","priv","pub","pair","k","data","slice","box","keyPair","fromSecretKey","Uint8Array","from","publicKey","name","mpNormalize","sign","fromSeed","Error","createVerify","hashAlgo","createSign","defaultHashAlgorithm","Signer","v","nm","err","toUpperCase","e","message","match","ok","oldSign","bind","key","curve","sig","parse","hashAlgorithm","buffer","filename","optionalString","read","isPrivateKey","obj","ver","isCompatible","generate","_sshpkApiVersion","_oldVersionDetect","func"],"mappings":"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","sourcesContent":["// Copyright 2017 Joyent, Inc.\n\nmodule.exports = PrivateKey;\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('./algs');\nvar crypto = require('crypto');\nvar Fingerprint = require('./fingerprint');\nvar Signature = require('./signature');\nvar errs = require('./errors');\nvar util = require('util');\nvar utils = require('./utils');\nvar dhe = require('./dhe');\nvar generateECDSA = dhe.generateECDSA;\nvar generateED25519 = dhe.generateED25519;\nvar edCompat = require('./ed-compat');\nvar nacl = require('tweetnacl');\n\nvar Key = require('./key');\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar KeyEncryptedError = errs.KeyEncryptedError;\n\nvar formats = {};\nformats['auto'] = require('./formats/auto');\nformats['pem'] = require('./formats/pem');\nformats['pkcs1'] = require('./formats/pkcs1');\nformats['pkcs8'] = require('./formats/pkcs8');\nformats['rfc4253'] = require('./formats/rfc4253');\nformats['ssh-private'] = require('./formats/ssh-private');\nformats['openssh'] = formats['ssh-private'];\nformats['ssh'] = formats['ssh-private'];\nformats['dnssec'] = require('./formats/dnssec');\n\nfunction PrivateKey(opts) {\n\tassert.object(opts, 'options');\n\tKey.call(this, opts);\n\n\tthis._pubCache = undefined;\n}\nutil.inherits(PrivateKey, Key);\n\nPrivateKey.formats = formats;\n\nPrivateKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pkcs1';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nPrivateKey.prototype.hash = function (algo, type) {\n\treturn (this.toPublic().hash(algo, type));\n};\n\nPrivateKey.prototype.fingerprint = function (algo, type) {\n\treturn (this.toPublic().fingerprint(algo, type));\n};\n\nPrivateKey.prototype.toPublic = function () {\n\tif (this._pubCache)\n\t\treturn (this._pubCache);\n\n\tvar algInfo = algs.info[this.type];\n\tvar pubParts = [];\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = algInfo.parts[i];\n\t\tpubParts.push(this.part[p]);\n\t}\n\n\tthis._pubCache = new Key({\n\t\ttype: this.type,\n\t\tsource: this,\n\t\tparts: pubParts\n\t});\n\tif (this.comment)\n\t\tthis._pubCache.comment = this.comment;\n\treturn (this._pubCache);\n};\n\nPrivateKey.prototype.derive = function (newType) {\n\tassert.string(newType, 'type');\n\tvar priv, pub, pair;\n\n\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t}\n\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t    ' to ' + newType));\n};\n\nPrivateKey.prototype.createVerify = function (hashAlgo) {\n\treturn (this.toPublic().createVerify(hashAlgo));\n};\n\nPrivateKey.prototype.createSign = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Signer(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldSign = v.sign.bind(v);\n\tvar key = this.toBuffer('pkcs1');\n\tvar type = this.type;\n\tvar curve = this.curve;\n\tv.sign = function () {\n\t\tvar sig = oldSign(key);\n\t\tif (typeof (sig) === 'string')\n\t\t\tsig = Buffer.from(sig, 'binary');\n\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\tsig.hashAlgorithm = hashAlgo;\n\t\tsig.curve = curve;\n\t\treturn (sig);\n\t};\n\treturn (v);\n};\n\nPrivateKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nPrivateKey.isPrivateKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, PrivateKey, ver));\n};\n\nPrivateKey.generate = function (type, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.object(options, 'options');\n\n\tswitch (type) {\n\tcase 'ecdsa':\n\t\tif (options.curve === undefined)\n\t\t\toptions.curve = 'nistp256';\n\t\tassert.string(options.curve, 'options.curve');\n\t\treturn (generateECDSA(options.curve));\n\tcase 'ed25519':\n\t\treturn (generateED25519());\n\tdefault:\n\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t    'type \"' + type + '\"'));\n\t}\n};\n\n/*\n * API versions for PrivateKey:\n * [1,0] -- initial ver\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n * [1,2] -- added defaultHashAlgorithm\n * [1,3] -- added derive, ed, createDH\n * [1,4] -- first tagged version\n * [1,5] -- changed ed25519 part names and format\n * [1,6] -- type arguments for hash() and fingerprint()\n */\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\nPrivateKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toPublic);\n\tassert.func(obj.createSign);\n\tif (obj.derive)\n\t\treturn ([1, 3]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 2]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n"]},"metadata":{},"sourceType":"script"}