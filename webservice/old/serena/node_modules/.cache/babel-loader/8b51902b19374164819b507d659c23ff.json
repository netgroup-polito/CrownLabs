{"ast":null,"code":"/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../deps/forge.js\"),\n    merge = require(\"../util/merge.js\"),\n    util = require(\"../util\"),\n    helpers = require(\"./helpers.js\"),\n    CONSTANTS = require(\"./constants.js\"),\n    KW = require(\"./aes-kw.js\");\n\nvar NULL_BUFFER = Buffer.from([0]);\nvar DEFAULT_ITERATIONS = 8192;\nvar DEFAULT_SALT_LENGTH = 16;\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [Buffer.from(alg, \"utf8\"), NULL_BUFFER, salt];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || Buffer.alloc(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n    return props;\n  }\n\n  var fallback = function (key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var promise = new Promise(function (resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n\n      var cb = function (err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = Buffer.from(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"), salt.toString(\"binary\"), itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  var webcrypto = function (key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var promise = Promise.resolve(key);\n    promise = promise.then(function (keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function (key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: new Uint8Array(salt),\n        iterations: itrs,\n        hash: hash\n      };\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function (result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBKDF2-\" + hash);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function (resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n  return function (key, pdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || DEFAULT_ITERATIONS;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    if (0 === salt.length) {\n      salt = util.randomBytes(DEFAULT_SALT_LENGTH);\n    } else if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n\n    var header = {\n      p2s: util.base64url.encode(salt),\n      p2c: itrs\n    };\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n    var promise = Promise.resolve(key); // STEP 1: derive shared key\n\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    }); // STEP 2: encrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    }); // STEP 3: (re-)apply headers\n\n    promise = promise.then(function (results) {\n      results.header = merge(results.header || {}, header);\n      return results;\n    });\n    return promise;\n  };\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n  return function (key, cdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n    var promise = Promise.resolve(key); // STEP 1: derived shared key\n\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    }); // STEP 2: decrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n    return promise;\n  };\n} // ### Public API\n\n\nvar pbes2 = {}; // * [name].derive\n\n[\"PBKDF2-SHA-256\", \"PBKDF2-SHA-384\", \"PBKDF2-SHA-512\"].forEach(function (alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n}); // [name].encrypt\n// [name].decrypt\n\n[\"PBES2-HS256+A128KW\", \"PBES2-HS384+A192KW\", \"PBES2-HS512+A256KW\"].forEach(function (alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\nmodule.exports = pbes2;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/algorithms/pbes2.js"],"names":["forge","require","merge","util","helpers","CONSTANTS","KW","NULL_BUFFER","Buffer","from","DEFAULT_ITERATIONS","DEFAULT_SALT_LENGTH","fixSalt","hmac","kw","salt","alg","output","concat","pbkdf2Fn","hash","prepareProps","props","keyLen","length","asBuffer","alloc","itrs","iterations","Error","fallback","key","err","Promise","reject","promise","resolve","md","replace","toLowerCase","create","cb","dk","pkcs5","pbkdf2","toString","webcrypto","then","keyval","subtleCrypto","importKey","mainAlgo","name","Uint8Array","deriveBits","result","nodejs","nodeCrypto","setupFallback","pbes2EncryptFN","deriveAlg","KEYLENGTH","pdata","p2s","p2c","randomBytes","header","base64url","encode","pbes2","derive","encrypt","results","pbes2DecryptFN","cdata","decrypt","forEach","parts","exec","module","exports"],"mappings":"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","sourcesContent":["/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../deps/forge.js\"),\n    merge = require(\"../util/merge.js\"),\n    util = require(\"../util\"),\n    helpers = require(\"./helpers.js\"),\n    CONSTANTS = require(\"./constants.js\"),\n    KW = require(\"./aes-kw.js\");\n\nvar NULL_BUFFER = Buffer.from([0]);\nvar DEFAULT_ITERATIONS = 8192;\nvar DEFAULT_SALT_LENGTH = 16;\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [\n    Buffer.from(alg, \"utf8\"),\n    NULL_BUFFER,\n    salt\n  ];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || Buffer.alloc(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n\n    return props;\n  }\n\n  var fallback = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = new Promise(function(resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n      var cb = function(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = Buffer.from(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"),\n                         salt.toString(\"binary\"),\n                         itrs,\n                         keyLen,\n                         md,\n                         cb);\n    });\n    return promise;\n  };\n  var webcrypto = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = Promise.resolve(key);\n    promise = promise.then(function(keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function(key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: new Uint8Array(salt),\n        iterations: itrs,\n        hash: hash\n      };\n\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function(result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n  var nodejs = function(key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBKDF2-\" + hash);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n        var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function(resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, pdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n      itrs = props.p2c || DEFAULT_ITERATIONS;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n    if (0 === salt.length) {\n      salt = util.randomBytes(DEFAULT_SALT_LENGTH);\n    } else if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n    var header = {\n      p2s: util.base64url.encode(salt),\n      p2c: itrs\n    };\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n    // STEP 1: derive shared key\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: encrypt cek\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    // STEP 3: (re-)apply headers\n    promise = promise.then(function (results) {\n      results.header = merge(results.header || {}, header);\n      return results;\n    });\n\n    return promise;\n  };\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, cdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n\n    // STEP 1: derived shared key\n    promise = promise.then(function(key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: decrypt cek\n    promise = promise.then(function(dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\nvar pbes2 = {};\n\n// * [name].derive\n[\n  \"PBKDF2-SHA-256\",\n  \"PBKDF2-SHA-384\",\n  \"PBKDF2-SHA-512\"\n].forEach(function(alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n});\n\n// [name].encrypt\n// [name].decrypt\n[\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\"\n].forEach(function(alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\n\nmodule.exports = pbes2;\n"]},"metadata":{},"sourceType":"script"}