{"ast":null,"code":"/**\n * Prime number generation API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nrequire('./jsbn');\n\nrequire('./random');\n\n(function () {\n  // forge.prime already defined\n  if (forge.prime) {\n    module.exports = forge.prime;\n    return;\n  }\n  /* PRIME API */\n\n\n  var prime = module.exports = forge.prime = forge.prime || {};\n  var BigInteger = forge.jsbn.BigInteger; // primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\n\n  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n  var THIRTY = new BigInteger(null);\n  THIRTY.fromInt(30);\n\n  var op_or = function (x, y) {\n    return x | y;\n  };\n  /**\n   * Generates a random probable prime with the given number of bits.\n   *\n   * Alternative algorithms can be specified by name as a string or as an\n   * object with custom options like so:\n   *\n   * {\n   *   name: 'PRIMEINC',\n   *   options: {\n   *     maxBlockTime: <the maximum amount of time to block the main\n   *       thread before allowing I/O other JS to run>,\n   *     millerRabinTests: <the number of miller-rabin tests to run>,\n   *     workerScript: <the worker script URL>,\n   *     workers: <the number of web workers (if supported) to use,\n   *       -1 to use estimated cores minus one>.\n   *     workLoad: the size of the work load, ie: number of possible prime\n   *       numbers for each web worker to check per work assignment,\n   *       (default: 100).\n   *   }\n   * }\n   *\n   * @param bits the number of bits for the prime number.\n   * @param options the options to use.\n   *          [algorithm] the algorithm to use (default: 'PRIMEINC').\n   *          [prng] a custom crypto-secure pseudo-random number generator to use,\n   *            that must define \"getBytesSync\".\n   *\n   * @return callback(err, num) called once the operation completes.\n   */\n\n\n  prime.generateProbablePrime = function (bits, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {}; // default to PRIMEINC algorithm\n\n    var algorithm = options.algorithm || 'PRIMEINC';\n\n    if (typeof algorithm === 'string') {\n      algorithm = {\n        name: algorithm\n      };\n    }\n\n    algorithm.options = algorithm.options || {}; // create prng with api that matches BigInteger secure random\n\n    var prng = options.prng || forge.random;\n    var rng = {\n      // x is an array to fill with bytes\n      nextBytes: function (x) {\n        var b = prng.getBytesSync(x.length);\n\n        for (var i = 0; i < x.length; ++i) {\n          x[i] = b.charCodeAt(i);\n        }\n      }\n    };\n\n    if (algorithm.name === 'PRIMEINC') {\n      return primeincFindPrime(bits, rng, algorithm.options, callback);\n    }\n\n    throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\n  };\n\n  function primeincFindPrime(bits, rng, options, callback) {\n    if ('workers' in options) {\n      return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n    }\n\n    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n  }\n\n  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n    // initialize random number\n    var num = generateRandom(bits, rng);\n    /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n    number we are given is always aligned at 30k + 1. Each time the number is\n    determined not to be prime we add to get to the next 'i', eg: if the number\n    was at 30k + 1 we add 6. */\n\n    var deltaIdx = 0; // get required number of MR tests\n\n    var mrTests = getMillerRabinTests(num.bitLength());\n\n    if ('millerRabinTests' in options) {\n      mrTests = options.millerRabinTests;\n    } // find prime nearest to 'num' for maxBlockTime ms\n    // 10 ms gives 5ms of leeway for other calculations before dropping\n    // below 60fps (1000/60 == 16.67), but in reality, the number will\n    // likely be higher due to an 'atomic' big int modPow\n\n\n    var maxBlockTime = 10;\n\n    if ('maxBlockTime' in options) {\n      maxBlockTime = options.maxBlockTime;\n    }\n\n    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n  }\n\n  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n    var start = +new Date();\n\n    do {\n      // overflow, regenerate random number\n      if (num.bitLength() > bits) {\n        num = generateRandom(bits, rng);\n      } // do primality test\n\n\n      if (num.isProbablePrime(mrTests)) {\n        return callback(null, num);\n      } // get next potential prime\n\n\n      num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n    } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime); // keep trying later\n\n\n    forge.util.setImmediate(function () {\n      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n    });\n  } // NOTE: This algorithm is indeterminate in nature because workers\n  // run in parallel looking at different segments of numbers. Even if this\n  // algorithm is run twice with the same input from a predictable RNG, it\n  // may produce different outputs.\n\n\n  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n    // web workers unavailable\n    if (typeof Worker === 'undefined') {\n      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n    } // initialize random number\n\n\n    var num = generateRandom(bits, rng); // use web workers to generate keys\n\n    var numWorkers = options.workers;\n    var workLoad = options.workLoad || 100;\n    var range = workLoad * 30 / 8;\n    var workerScript = options.workerScript || 'forge/prime.worker.js';\n\n    if (numWorkers === -1) {\n      return forge.util.estimateCores(function (err, cores) {\n        if (err) {\n          // default to 2\n          cores = 2;\n        }\n\n        numWorkers = cores - 1;\n        generate();\n      });\n    }\n\n    generate();\n\n    function generate() {\n      // require at least 1 worker\n      numWorkers = Math.max(1, numWorkers); // TODO: consider optimizing by starting workers outside getPrime() ...\n      // note that in order to clean up they will have to be made internally\n      // asynchronous which may actually be slower\n      // start workers immediately\n\n      var workers = [];\n\n      for (var i = 0; i < numWorkers; ++i) {\n        // FIXME: fix path or use blob URLs\n        workers[i] = new Worker(workerScript);\n      }\n\n      var running = numWorkers; // listen for requests from workers and assign ranges to find prime\n\n      for (var i = 0; i < numWorkers; ++i) {\n        workers[i].addEventListener('message', workerMessage);\n      }\n      /* Note: The distribution of random numbers is unknown. Therefore, each\n      web worker is continuously allocated a range of numbers to check for a\n      random number until one is found.\n       Every 30 numbers will be checked just 8 times, because prime numbers\n      have the form:\n       30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\n       Therefore, if we want a web worker to run N checks before asking for\n      a new range of numbers, each range must contain N*30/8 numbers.\n       For 100 checks (workLoad), this is a range of 375. */\n\n\n      var found = false;\n\n      function workerMessage(e) {\n        // ignore message, prime already found\n        if (found) {\n          return;\n        }\n\n        --running;\n        var data = e.data;\n\n        if (data.found) {\n          // terminate all workers\n          for (var i = 0; i < workers.length; ++i) {\n            workers[i].terminate();\n          }\n\n          found = true;\n          return callback(null, new BigInteger(data.prime, 16));\n        } // overflow, regenerate random number\n\n\n        if (num.bitLength() > bits) {\n          num = generateRandom(bits, rng);\n        } // assign new range to check\n\n\n        var hex = num.toString(16); // start prime search\n\n        e.target.postMessage({\n          hex: hex,\n          workLoad: workLoad\n        });\n        num.dAddOffset(range, 0);\n      }\n    }\n  }\n  /**\n   * Generates a random number using the given number of bits and RNG.\n   *\n   * @param bits the number of bits for the number.\n   * @param rng the random number generator to use.\n   *\n   * @return the random number.\n   */\n\n\n  function generateRandom(bits, rng) {\n    var num = new BigInteger(bits, rng); // force MSB set\n\n    var bits1 = bits - 1;\n\n    if (!num.testBit(bits1)) {\n      num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n    } // align number on 30k+1 boundary\n\n\n    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n    return num;\n  }\n  /**\n   * Returns the required number of Miller-Rabin tests to generate a\n   * prime with an error probability of (1/2)^80.\n   *\n   * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n   *\n   * @param bits the bit size.\n   *\n   * @return the required number of iterations.\n   */\n\n\n  function getMillerRabinTests(bits) {\n    if (bits <= 100) return 27;\n    if (bits <= 150) return 18;\n    if (bits <= 200) return 15;\n    if (bits <= 250) return 12;\n    if (bits <= 300) return 9;\n    if (bits <= 350) return 8;\n    if (bits <= 400) return 7;\n    if (bits <= 500) return 6;\n    if (bits <= 600) return 5;\n    if (bits <= 800) return 4;\n    if (bits <= 1250) return 3;\n    return 2;\n  }\n})();","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/prime.js"],"names":["forge","require","prime","module","exports","BigInteger","jsbn","GCD_30_DELTA","THIRTY","fromInt","op_or","x","y","generateProbablePrime","bits","options","callback","algorithm","name","prng","random","rng","nextBytes","b","getBytesSync","length","i","charCodeAt","primeincFindPrime","Error","primeincFindPrimeWithWorkers","primeincFindPrimeWithoutWorkers","num","generateRandom","deltaIdx","mrTests","getMillerRabinTests","bitLength","millerRabinTests","maxBlockTime","_primeinc","start","Date","isProbablePrime","dAddOffset","util","setImmediate","Worker","numWorkers","workers","workLoad","range","workerScript","estimateCores","err","cores","generate","Math","max","running","addEventListener","workerMessage","found","e","data","terminate","hex","toString","target","postMessage","bits1","testBit","bitwiseTo","ONE","shiftLeft","mod","byteValue"],"mappings":"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","sourcesContent":["/**\n * Prime number generation API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./jsbn');\nrequire('./random');\n\n(function() {\n\n// forge.prime already defined\nif(forge.prime) {\n  module.exports = forge.prime;\n  return;\n}\n\n/* PRIME API */\nvar prime = module.exports = forge.prime = forge.prime || {};\n\nvar BigInteger = forge.jsbn.BigInteger;\n\n// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\nvar THIRTY = new BigInteger(null);\nTHIRTY.fromInt(30);\nvar op_or = function(x, y) {return x|y;};\n\n/**\n * Generates a random probable prime with the given number of bits.\n *\n * Alternative algorithms can be specified by name as a string or as an\n * object with custom options like so:\n *\n * {\n *   name: 'PRIMEINC',\n *   options: {\n *     maxBlockTime: <the maximum amount of time to block the main\n *       thread before allowing I/O other JS to run>,\n *     millerRabinTests: <the number of miller-rabin tests to run>,\n *     workerScript: <the worker script URL>,\n *     workers: <the number of web workers (if supported) to use,\n *       -1 to use estimated cores minus one>.\n *     workLoad: the size of the work load, ie: number of possible prime\n *       numbers for each web worker to check per work assignment,\n *       (default: 100).\n *   }\n * }\n *\n * @param bits the number of bits for the prime number.\n * @param options the options to use.\n *          [algorithm] the algorithm to use (default: 'PRIMEINC').\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *\n * @return callback(err, num) called once the operation completes.\n */\nprime.generateProbablePrime = function(bits, options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  // default to PRIMEINC algorithm\n  var algorithm = options.algorithm || 'PRIMEINC';\n  if(typeof algorithm === 'string') {\n    algorithm = {name: algorithm};\n  }\n  algorithm.options = algorithm.options || {};\n\n  // create prng with api that matches BigInteger secure random\n  var prng = options.prng || forge.random;\n  var rng = {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      var b = prng.getBytesSync(x.length);\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = b.charCodeAt(i);\n      }\n    }\n  };\n\n  if(algorithm.name === 'PRIMEINC') {\n    return primeincFindPrime(bits, rng, algorithm.options, callback);\n  }\n\n  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\n};\n\nfunction primeincFindPrime(bits, rng, options, callback) {\n  if('workers' in options) {\n    return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n  }\n  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n}\n\nfunction primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n  // initialize random number\n  var num = generateRandom(bits, rng);\n\n  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n  number we are given is always aligned at 30k + 1. Each time the number is\n  determined not to be prime we add to get to the next 'i', eg: if the number\n  was at 30k + 1 we add 6. */\n  var deltaIdx = 0;\n\n  // get required number of MR tests\n  var mrTests = getMillerRabinTests(num.bitLength());\n  if('millerRabinTests' in options) {\n    mrTests = options.millerRabinTests;\n  }\n\n  // find prime nearest to 'num' for maxBlockTime ms\n  // 10 ms gives 5ms of leeway for other calculations before dropping\n  // below 60fps (1000/60 == 16.67), but in reality, the number will\n  // likely be higher due to an 'atomic' big int modPow\n  var maxBlockTime = 10;\n  if('maxBlockTime' in options) {\n    maxBlockTime = options.maxBlockTime;\n  }\n\n  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n}\n\nfunction _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n  var start = +new Date();\n  do {\n    // overflow, regenerate random number\n    if(num.bitLength() > bits) {\n      num = generateRandom(bits, rng);\n    }\n    // do primality test\n    if(num.isProbablePrime(mrTests)) {\n      return callback(null, num);\n    }\n    // get next potential prime\n    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));\n\n  // keep trying later\n  forge.util.setImmediate(function() {\n    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n  });\n}\n\n// NOTE: This algorithm is indeterminate in nature because workers\n// run in parallel looking at different segments of numbers. Even if this\n// algorithm is run twice with the same input from a predictable RNG, it\n// may produce different outputs.\nfunction primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n  // web workers unavailable\n  if(typeof Worker === 'undefined') {\n    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n  }\n\n  // initialize random number\n  var num = generateRandom(bits, rng);\n\n  // use web workers to generate keys\n  var numWorkers = options.workers;\n  var workLoad = options.workLoad || 100;\n  var range = workLoad * 30 / 8;\n  var workerScript = options.workerScript || 'forge/prime.worker.js';\n  if(numWorkers === -1) {\n    return forge.util.estimateCores(function(err, cores) {\n      if(err) {\n        // default to 2\n        cores = 2;\n      }\n      numWorkers = cores - 1;\n      generate();\n    });\n  }\n  generate();\n\n  function generate() {\n    // require at least 1 worker\n    numWorkers = Math.max(1, numWorkers);\n\n    // TODO: consider optimizing by starting workers outside getPrime() ...\n    // note that in order to clean up they will have to be made internally\n    // asynchronous which may actually be slower\n\n    // start workers immediately\n    var workers = [];\n    for(var i = 0; i < numWorkers; ++i) {\n      // FIXME: fix path or use blob URLs\n      workers[i] = new Worker(workerScript);\n    }\n    var running = numWorkers;\n\n    // listen for requests from workers and assign ranges to find prime\n    for(var i = 0; i < numWorkers; ++i) {\n      workers[i].addEventListener('message', workerMessage);\n    }\n\n    /* Note: The distribution of random numbers is unknown. Therefore, each\n    web worker is continuously allocated a range of numbers to check for a\n    random number until one is found.\n\n    Every 30 numbers will be checked just 8 times, because prime numbers\n    have the form:\n\n    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\n\n    Therefore, if we want a web worker to run N checks before asking for\n    a new range of numbers, each range must contain N*30/8 numbers.\n\n    For 100 checks (workLoad), this is a range of 375. */\n\n    var found = false;\n    function workerMessage(e) {\n      // ignore message, prime already found\n      if(found) {\n        return;\n      }\n\n      --running;\n      var data = e.data;\n      if(data.found) {\n        // terminate all workers\n        for(var i = 0; i < workers.length; ++i) {\n          workers[i].terminate();\n        }\n        found = true;\n        return callback(null, new BigInteger(data.prime, 16));\n      }\n\n      // overflow, regenerate random number\n      if(num.bitLength() > bits) {\n        num = generateRandom(bits, rng);\n      }\n\n      // assign new range to check\n      var hex = num.toString(16);\n\n      // start prime search\n      e.target.postMessage({\n        hex: hex,\n        workLoad: workLoad\n      });\n\n      num.dAddOffset(range, 0);\n    }\n  }\n}\n\n/**\n * Generates a random number using the given number of bits and RNG.\n *\n * @param bits the number of bits for the number.\n * @param rng the random number generator to use.\n *\n * @return the random number.\n */\nfunction generateRandom(bits, rng) {\n  var num = new BigInteger(bits, rng);\n  // force MSB set\n  var bits1 = bits - 1;\n  if(!num.testBit(bits1)) {\n    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n  }\n  // align number on 30k+1 boundary\n  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n  return num;\n}\n\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */\nfunction getMillerRabinTests(bits) {\n  if(bits <= 100) return 27;\n  if(bits <= 150) return 18;\n  if(bits <= 200) return 15;\n  if(bits <= 250) return 12;\n  if(bits <= 300) return 9;\n  if(bits <= 350) return 8;\n  if(bits <= 400) return 7;\n  if(bits <= 500) return 6;\n  if(bits <= 600) return 5;\n  if(bits <= 800) return 4;\n  if(bits <= 1250) return 3;\n  return 2;\n}\n\n})();\n"]},"metadata":{},"sourceType":"script"}