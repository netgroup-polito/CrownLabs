{"ast":null,"code":"'use strict';\n\nconst bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n  if (!inputStream) {\n    return Promise.reject(new Error('Expected a stream'));\n  }\n\n  opts = Object.assign({\n    maxBuffer: Infinity\n  }, opts);\n  const maxBuffer = opts.maxBuffer;\n  let stream;\n  let clean;\n  const p = new Promise((resolve, reject) => {\n    const error = err => {\n      if (err) {\n        // null check\n        err.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(err);\n    };\n\n    stream = bufferStream(opts);\n    inputStream.once('error', error);\n    inputStream.pipe(stream);\n    stream.on('data', () => {\n      if (stream.getBufferedLength() > maxBuffer) {\n        reject(new Error('maxBuffer exceeded'));\n      }\n    });\n    stream.once('error', error);\n    stream.on('end', resolve);\n\n    clean = () => {\n      // some streams doesn't implement the `stream.Readable` interface correctly\n      if (inputStream.unpipe) {\n        inputStream.unpipe(stream);\n      }\n    };\n  });\n  p.then(clean, clean);\n  return p.then(() => stream.getBufferedValue());\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, {\n  encoding: 'buffer'\n}));\n\nmodule.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, {\n  array: true\n}));","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/cacheable-request/node_modules/get-stream/index.js"],"names":["bufferStream","require","getStream","inputStream","opts","Promise","reject","Error","Object","assign","maxBuffer","Infinity","stream","clean","p","resolve","error","err","bufferedData","getBufferedValue","once","pipe","on","getBufferedLength","unpipe","then","module","exports","buffer","encoding","array"],"mappings":"AAAA;;AACA,MAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA5B;;AAEA,SAASC,SAAT,CAAmBC,WAAnB,EAAgCC,IAAhC,EAAsC;AACrC,MAAI,CAACD,WAAL,EAAkB;AACjB,WAAOE,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,mBAAV,CAAf,CAAP;AACA;;AAEDH,EAAAA,IAAI,GAAGI,MAAM,CAACC,MAAP,CAAc;AAACC,IAAAA,SAAS,EAAEC;AAAZ,GAAd,EAAqCP,IAArC,CAAP;AAEA,QAAMM,SAAS,GAAGN,IAAI,CAACM,SAAvB;AACA,MAAIE,MAAJ;AACA,MAAIC,KAAJ;AAEA,QAAMC,CAAC,GAAG,IAAIT,OAAJ,CAAY,CAACU,OAAD,EAAUT,MAAV,KAAqB;AAC1C,UAAMU,KAAK,GAAGC,GAAG,IAAI;AACpB,UAAIA,GAAJ,EAAS;AAAE;AACVA,QAAAA,GAAG,CAACC,YAAJ,GAAmBN,MAAM,CAACO,gBAAP,EAAnB;AACA;;AAEDb,MAAAA,MAAM,CAACW,GAAD,CAAN;AACA,KAND;;AAQAL,IAAAA,MAAM,GAAGZ,YAAY,CAACI,IAAD,CAArB;AACAD,IAAAA,WAAW,CAACiB,IAAZ,CAAiB,OAAjB,EAA0BJ,KAA1B;AACAb,IAAAA,WAAW,CAACkB,IAAZ,CAAiBT,MAAjB;AAEAA,IAAAA,MAAM,CAACU,EAAP,CAAU,MAAV,EAAkB,MAAM;AACvB,UAAIV,MAAM,CAACW,iBAAP,KAA6Bb,SAAjC,EAA4C;AAC3CJ,QAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAU,oBAAV,CAAD,CAAN;AACA;AACD,KAJD;AAKAK,IAAAA,MAAM,CAACQ,IAAP,CAAY,OAAZ,EAAqBJ,KAArB;AACAJ,IAAAA,MAAM,CAACU,EAAP,CAAU,KAAV,EAAiBP,OAAjB;;AAEAF,IAAAA,KAAK,GAAG,MAAM;AACb;AACA,UAAIV,WAAW,CAACqB,MAAhB,EAAwB;AACvBrB,QAAAA,WAAW,CAACqB,MAAZ,CAAmBZ,MAAnB;AACA;AACD,KALD;AAMA,GA3BS,CAAV;AA6BAE,EAAAA,CAAC,CAACW,IAAF,CAAOZ,KAAP,EAAcA,KAAd;AAEA,SAAOC,CAAC,CAACW,IAAF,CAAO,MAAMb,MAAM,CAACO,gBAAP,EAAb,CAAP;AACA;;AAEDO,MAAM,CAACC,OAAP,GAAiBzB,SAAjB;;AACAwB,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,CAAChB,MAAD,EAASR,IAAT,KAAkBF,SAAS,CAACU,MAAD,EAASJ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,EAAwB;AAACyB,EAAAA,QAAQ,EAAE;AAAX,CAAxB,CAAT,CAAnD;;AACAH,MAAM,CAACC,OAAP,CAAeG,KAAf,GAAuB,CAAClB,MAAD,EAASR,IAAT,KAAkBF,SAAS,CAACU,MAAD,EAASJ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,EAAwB;AAAC0B,EAAAA,KAAK,EAAE;AAAR,CAAxB,CAAT,CAAlD","sourcesContent":["'use strict';\nconst bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\topts = Object.assign({maxBuffer: Infinity}, opts);\n\n\tconst maxBuffer = opts.maxBuffer;\n\tlet stream;\n\tlet clean;\n\n\tconst p = new Promise((resolve, reject) => {\n\t\tconst error = err => {\n\t\t\tif (err) { // null check\n\t\t\t\terr.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(err);\n\t\t};\n\n\t\tstream = bufferStream(opts);\n\t\tinputStream.once('error', error);\n\t\tinputStream.pipe(stream);\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\treject(new Error('maxBuffer exceeded'));\n\t\t\t}\n\t\t});\n\t\tstream.once('error', error);\n\t\tstream.on('end', resolve);\n\n\t\tclean = () => {\n\t\t\t// some streams doesn't implement the `stream.Readable` interface correctly\n\t\t\tif (inputStream.unpipe) {\n\t\t\t\tinputStream.unpipe(stream);\n\t\t\t}\n\t\t};\n\t});\n\n\tp.then(clean, clean);\n\n\treturn p.then(() => stream.getBufferedValue());\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, {encoding: 'buffer'}));\nmodule.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, {array: true}));\n"]},"metadata":{},"sourceType":"script"}