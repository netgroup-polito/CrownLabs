{"ast":null,"code":"var common = require('./common');\n\nvar fs = require('fs');\n\ncommon.register('rm', _rm, {\n  cmdOptions: {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive'\n  }\n}); // Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\n\nfunction rmdirSyncRecursive(dir, force, fromSymlink) {\n  var files;\n  files = fs.readdirSync(dir); // Loop through and delete everything in the sub-tree after checking it\n\n  for (var i = 0; i < files.length; i++) {\n    var file = dir + '/' + files[i];\n    var currFile = common.statNoFollowLinks(file);\n\n    if (currFile.isDirectory()) {\n      // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    } else {\n      // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error('could not remove file (code ' + e.code + '): ' + file, {\n            continue: true\n          });\n        }\n      }\n    }\n  } // if was directory was referenced through a symbolic link,\n  // the contents should be removed, but not the directory itself\n\n\n  if (fromSymlink) return; // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n\n  try {\n    // Retry on windows, sometimes it takes a little time before all the files in the directory are gone\n    var start = Date.now(); // TODO: replace this with a finite loop\n\n    for (;;) {\n      try {\n        result = fs.rmdirSync(dir);\n        if (fs.existsSync(dir)) throw {\n          code: 'EAGAIN'\n        };\n        break;\n      } catch (er) {\n        /* istanbul ignore next */\n        // In addition to error codes, also check if the directory still exists and loop again if true\n        if (process.platform === 'win32' && (er.code === 'ENOTEMPTY' || er.code === 'EBUSY' || er.code === 'EPERM' || er.code === 'EAGAIN')) {\n          if (Date.now() - start > 1000) throw er;\n        } else if (er.code === 'ENOENT') {\n          // Directory did not exist, deletion was successful\n          break;\n        } else {\n          throw er;\n        }\n      }\n    }\n  } catch (e) {\n    common.error('could not remove directory (code ' + e.code + '): ' + dir, {\n      continue: true\n    });\n  }\n\n  return result;\n} // rmdirSyncRecursive\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\n\n\nfunction isWriteable(file) {\n  var writePermission = true;\n\n  try {\n    var __fd = fs.openSync(file, 'a');\n\n    fs.closeSync(__fd);\n  } catch (e) {\n    writePermission = false;\n  }\n\n  return writePermission;\n}\n\nfunction handleFile(file, options) {\n  if (options.force || isWriteable(file)) {\n    // -f was passed, or file is writable, so it can be removed\n    common.unlinkSync(file);\n  } else {\n    common.error('permission denied: ' + file, {\n      continue: true\n    });\n  }\n}\n\nfunction handleDirectory(file, options) {\n  if (options.recursive) {\n    // -r was passed, so directory can be removed\n    rmdirSyncRecursive(file, options.force);\n  } else {\n    common.error('path is a directory', {\n      continue: true\n    });\n  }\n}\n\nfunction handleSymbolicLink(file, options) {\n  var stats;\n\n  try {\n    stats = common.statFollowLinks(file);\n  } catch (e) {\n    // symlink is broken, so remove the symlink itself\n    common.unlinkSync(file);\n    return;\n  }\n\n  if (stats.isFile()) {\n    common.unlinkSync(file);\n  } else if (stats.isDirectory()) {\n    if (file[file.length - 1] === '/') {\n      // trailing separator, so remove the contents, not the link\n      if (options.recursive) {\n        // -r was passed, so directory can be removed\n        var fromSymlink = true;\n        rmdirSyncRecursive(file, options.force, fromSymlink);\n      } else {\n        common.error('path is a directory', {\n          continue: true\n        });\n      }\n    } else {\n      // no trailing separator, so remove the link\n      common.unlinkSync(file);\n    }\n  }\n}\n\nfunction handleFIFO(file) {\n  common.unlinkSync(file);\n} //@\n//@ ### rm([options,] file [, file ...])\n//@ ### rm([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files.\n\n\nfunction _rm(options, files) {\n  if (!files) common.error('no paths given'); // Convert to array\n\n  files = [].slice.call(arguments, 1);\n  files.forEach(function (file) {\n    var lstats;\n\n    try {\n      var filepath = file[file.length - 1] === '/' ? file.slice(0, -1) // remove the '/' so lstatSync can detect symlinks\n      : file;\n      lstats = common.statNoFollowLinks(filepath); // test for existence\n    } catch (e) {\n      // Path does not exist, no force flag given\n      if (!options.force) {\n        common.error('no such file or directory: ' + file, {\n          continue: true\n        });\n      }\n\n      return; // skip file\n    } // If here, path exists\n\n\n    if (lstats.isFile()) {\n      handleFile(file, options);\n    } else if (lstats.isDirectory()) {\n      handleDirectory(file, options);\n    } else if (lstats.isSymbolicLink()) {\n      handleSymbolicLink(file, options);\n    } else if (lstats.isFIFO()) {\n      handleFIFO(file);\n    }\n  }); // forEach(file)\n\n  return '';\n} // rm\n\n\nmodule.exports = _rm;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/shelljs/src/rm.js"],"names":["common","require","fs","register","_rm","cmdOptions","rmdirSyncRecursive","dir","force","fromSymlink","files","readdirSync","i","length","file","currFile","statNoFollowLinks","isDirectory","isWriteable","unlinkSync","e","error","code","continue","result","start","Date","now","rmdirSync","existsSync","er","process","platform","writePermission","__fd","openSync","closeSync","handleFile","options","handleDirectory","recursive","handleSymbolicLink","stats","statFollowLinks","isFile","handleFIFO","slice","call","arguments","forEach","lstats","filepath","isSymbolicLink","isFIFO","module","exports"],"mappings":"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","sourcesContent":["var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('rm', _rm, {\n  cmdOptions: {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive',\n  },\n});\n\n// Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction rmdirSyncRecursive(dir, force, fromSymlink) {\n  var files;\n\n  files = fs.readdirSync(dir);\n\n  // Loop through and delete everything in the sub-tree after checking it\n  for (var i = 0; i < files.length; i++) {\n    var file = dir + '/' + files[i];\n    var currFile = common.statNoFollowLinks(file);\n\n    if (currFile.isDirectory()) { // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    } else { // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error('could not remove file (code ' + e.code + '): ' + file, {\n            continue: true,\n          });\n        }\n      }\n    }\n  }\n\n  // if was directory was referenced through a symbolic link,\n  // the contents should be removed, but not the directory itself\n  if (fromSymlink) return;\n\n  // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n  try {\n    // Retry on windows, sometimes it takes a little time before all the files in the directory are gone\n    var start = Date.now();\n\n    // TODO: replace this with a finite loop\n    for (;;) {\n      try {\n        result = fs.rmdirSync(dir);\n        if (fs.existsSync(dir)) throw { code: 'EAGAIN' };\n        break;\n      } catch (er) {\n        /* istanbul ignore next */\n        // In addition to error codes, also check if the directory still exists and loop again if true\n        if (process.platform === 'win32' && (er.code === 'ENOTEMPTY' || er.code === 'EBUSY' || er.code === 'EPERM' || er.code === 'EAGAIN')) {\n          if (Date.now() - start > 1000) throw er;\n        } else if (er.code === 'ENOENT') {\n          // Directory did not exist, deletion was successful\n          break;\n        } else {\n          throw er;\n        }\n      }\n    }\n  } catch (e) {\n    common.error('could not remove directory (code ' + e.code + '): ' + dir, { continue: true });\n  }\n\n  return result;\n} // rmdirSyncRecursive\n\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\nfunction isWriteable(file) {\n  var writePermission = true;\n  try {\n    var __fd = fs.openSync(file, 'a');\n    fs.closeSync(__fd);\n  } catch (e) {\n    writePermission = false;\n  }\n\n  return writePermission;\n}\n\nfunction handleFile(file, options) {\n  if (options.force || isWriteable(file)) {\n    // -f was passed, or file is writable, so it can be removed\n    common.unlinkSync(file);\n  } else {\n    common.error('permission denied: ' + file, { continue: true });\n  }\n}\n\nfunction handleDirectory(file, options) {\n  if (options.recursive) {\n    // -r was passed, so directory can be removed\n    rmdirSyncRecursive(file, options.force);\n  } else {\n    common.error('path is a directory', { continue: true });\n  }\n}\n\nfunction handleSymbolicLink(file, options) {\n  var stats;\n  try {\n    stats = common.statFollowLinks(file);\n  } catch (e) {\n    // symlink is broken, so remove the symlink itself\n    common.unlinkSync(file);\n    return;\n  }\n\n  if (stats.isFile()) {\n    common.unlinkSync(file);\n  } else if (stats.isDirectory()) {\n    if (file[file.length - 1] === '/') {\n      // trailing separator, so remove the contents, not the link\n      if (options.recursive) {\n        // -r was passed, so directory can be removed\n        var fromSymlink = true;\n        rmdirSyncRecursive(file, options.force, fromSymlink);\n      } else {\n        common.error('path is a directory', { continue: true });\n      }\n    } else {\n      // no trailing separator, so remove the link\n      common.unlinkSync(file);\n    }\n  }\n}\n\nfunction handleFIFO(file) {\n  common.unlinkSync(file);\n}\n\n//@\n//@ ### rm([options,] file [, file ...])\n//@ ### rm([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files.\nfunction _rm(options, files) {\n  if (!files) common.error('no paths given');\n\n  // Convert to array\n  files = [].slice.call(arguments, 1);\n\n  files.forEach(function (file) {\n    var lstats;\n    try {\n      var filepath = (file[file.length - 1] === '/')\n        ? file.slice(0, -1) // remove the '/' so lstatSync can detect symlinks\n        : file;\n      lstats = common.statNoFollowLinks(filepath); // test for existence\n    } catch (e) {\n      // Path does not exist, no force flag given\n      if (!options.force) {\n        common.error('no such file or directory: ' + file, { continue: true });\n      }\n      return; // skip file\n    }\n\n    // If here, path exists\n    if (lstats.isFile()) {\n      handleFile(file, options);\n    } else if (lstats.isDirectory()) {\n      handleDirectory(file, options);\n    } else if (lstats.isSymbolicLink()) {\n      handleSymbolicLink(file, options);\n    } else if (lstats.isFIFO()) {\n      handleFIFO(file);\n    }\n  }); // forEach(file)\n  return '';\n} // rm\nmodule.exports = _rm;\n"]},"metadata":{},"sourceType":"script"}