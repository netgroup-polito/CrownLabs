{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst WebSocket = require(\"isomorphic-ws\");\n\nconst protocols = ['v4.channel.k8s.io', 'v3.channel.k8s.io', 'v2.channel.k8s.io', 'channel.k8s.io'];\n\nclass WebSocketHandler {\n  // factory is really just for test injection\n  constructor(config, socketFactory) {\n    this.config = config;\n    this.socketFactory = socketFactory;\n  }\n\n  static handleStandardStreams(streamNum, buff, stdout, stderr) {\n    if (buff.length < 1) {\n      return null;\n    }\n\n    if (stdout && streamNum === WebSocketHandler.StdoutStream) {\n      stdout.write(buff);\n    } else if (stderr && streamNum === WebSocketHandler.StderrStream) {\n      stderr.write(buff);\n    } else if (streamNum === WebSocketHandler.StatusStream) {\n      // stream closing.\n      if (stdout && stdout !== process.stdout) {\n        stdout.end();\n      }\n\n      if (stderr && stderr !== process.stderr) {\n        stderr.end();\n      }\n\n      return JSON.parse(buff.toString('utf8'));\n    } else {\n      throw new Error('Unknown stream: ' + streamNum);\n    }\n\n    return null;\n  }\n\n  static handleStandardInput(ws, stdin, streamNum = 0) {\n    stdin.on('data', data => {\n      const buff = Buffer.alloc(data.length + 1);\n      buff.writeInt8(streamNum, 0);\n\n      if (data instanceof Buffer) {\n        data.copy(buff, 1);\n      } else {\n        buff.write(data, 1);\n      }\n\n      ws.send(buff);\n    });\n    stdin.on('end', () => {\n      ws.close();\n    }); // Keep the stream open\n\n    return true;\n  }\n\n  static restartableHandleStandardInput(createWS, stdin, streamNum = 0, retryCount = 3) {\n    if (retryCount < 0) {\n      throw new Error(\"retryCount can't be lower than 0.\");\n    }\n\n    let queue = Promise.resolve();\n    let ws;\n\n    function processData(data) {\n      return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const buff = Buffer.alloc(data.length + 1);\n        buff.writeInt8(streamNum, 0);\n\n        if (data instanceof Buffer) {\n          data.copy(buff, 1);\n        } else {\n          buff.write(data, 1);\n        }\n\n        let i = 0;\n\n        for (; i < retryCount; ++i) {\n          if (ws !== null && ws.readyState === WebSocket.OPEN) {\n            ws.send(buff);\n            break;\n          } else {\n            ws = yield createWS();\n          }\n        }\n\n        if (i >= retryCount) {\n          throw new Error(\"can't send data to ws\");\n        }\n      });\n    }\n\n    stdin.on('data', data => {\n      queue = queue.then(() => processData(data));\n    });\n    stdin.on('end', () => {\n      if (ws) {\n        ws.close();\n      }\n    });\n    return () => ws;\n  }\n  /**\n   * Connect to a web socket endpoint.\n   * @param path The HTTP Path to connect to on the server.\n   * @param textHandler Callback for text over the web socket.\n   *      Returns true if the connection should be kept alive, false to disconnect.\n   * @param binaryHandler Callback for binary data over the web socket.\n   *      Returns true if the connection should be kept alive, false to disconnect.\n   */\n\n\n  connect(path, textHandler, binaryHandler) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const cluster = this.config.getCurrentCluster();\n\n      if (!cluster) {\n        throw new Error('No cluster is defined.');\n      }\n\n      const server = cluster.server;\n      const ssl = server.startsWith('https://');\n      const target = ssl ? server.substr(8) : server.substr(7);\n      const proto = ssl ? 'wss' : 'ws';\n      const uri = `${proto}://${target}${path}`;\n      const opts = {};\n      yield this.config.applytoHTTPSOptions(opts);\n      return yield new Promise((resolve, reject) => {\n        const client = this.socketFactory ? this.socketFactory(uri, opts) : new WebSocket(uri, protocols, opts);\n        let resolved = false;\n\n        client.onopen = () => {\n          resolved = true;\n          resolve(client);\n        };\n\n        client.onerror = err => {\n          if (!resolved) {\n            reject(err);\n          }\n        };\n\n        client.onmessage = ({\n          data\n        }) => {\n          // TODO: support ArrayBuffer and Buffer[] data types?\n          if (typeof data === 'string') {\n            if (textHandler && !textHandler(data)) {\n              client.close();\n            }\n          } else if (data instanceof Buffer) {\n            const streamNum = data.readInt8(0);\n\n            if (binaryHandler && !binaryHandler(streamNum, data.slice(1))) {\n              client.close();\n            }\n          }\n        };\n      });\n    });\n  }\n\n}\n\nWebSocketHandler.StdinStream = 0;\nWebSocketHandler.StdoutStream = 1;\nWebSocketHandler.StderrStream = 2;\nWebSocketHandler.StatusStream = 3;\nWebSocketHandler.ResizeStream = 4;\nexports.WebSocketHandler = WebSocketHandler;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/@kubernetes/client-node/dist/web-socket-handler.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","WebSocket","protocols","WebSocketHandler","constructor","config","socketFactory","handleStandardStreams","streamNum","buff","stdout","stderr","length","StdoutStream","write","StderrStream","StatusStream","process","end","JSON","parse","toString","Error","handleStandardInput","ws","stdin","on","data","Buffer","alloc","writeInt8","copy","send","close","restartableHandleStandardInput","createWS","retryCount","queue","Promise","resolve","processData","__awaiter","i","readyState","OPEN","then","connect","path","textHandler","binaryHandler","cluster","getCurrentCluster","server","ssl","startsWith","target","substr","proto","uri","opts","applytoHTTPSOptions","reject","client","resolved","onopen","onerror","err","onmessage","readInt8","slice","StdinStream","ResizeStream"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst WebSocket = require(\"isomorphic-ws\");\nconst protocols = ['v4.channel.k8s.io', 'v3.channel.k8s.io', 'v2.channel.k8s.io', 'channel.k8s.io'];\nclass WebSocketHandler {\n    // factory is really just for test injection\n    constructor(config, socketFactory) {\n        this.config = config;\n        this.socketFactory = socketFactory;\n    }\n    static handleStandardStreams(streamNum, buff, stdout, stderr) {\n        if (buff.length < 1) {\n            return null;\n        }\n        if (stdout && streamNum === WebSocketHandler.StdoutStream) {\n            stdout.write(buff);\n        }\n        else if (stderr && streamNum === WebSocketHandler.StderrStream) {\n            stderr.write(buff);\n        }\n        else if (streamNum === WebSocketHandler.StatusStream) {\n            // stream closing.\n            if (stdout && stdout !== process.stdout) {\n                stdout.end();\n            }\n            if (stderr && stderr !== process.stderr) {\n                stderr.end();\n            }\n            return JSON.parse(buff.toString('utf8'));\n        }\n        else {\n            throw new Error('Unknown stream: ' + streamNum);\n        }\n        return null;\n    }\n    static handleStandardInput(ws, stdin, streamNum = 0) {\n        stdin.on('data', (data) => {\n            const buff = Buffer.alloc(data.length + 1);\n            buff.writeInt8(streamNum, 0);\n            if (data instanceof Buffer) {\n                data.copy(buff, 1);\n            }\n            else {\n                buff.write(data, 1);\n            }\n            ws.send(buff);\n        });\n        stdin.on('end', () => {\n            ws.close();\n        });\n        // Keep the stream open\n        return true;\n    }\n    static restartableHandleStandardInput(createWS, stdin, streamNum = 0, retryCount = 3) {\n        if (retryCount < 0) {\n            throw new Error(\"retryCount can't be lower than 0.\");\n        }\n        let queue = Promise.resolve();\n        let ws;\n        function processData(data) {\n            return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                const buff = Buffer.alloc(data.length + 1);\n                buff.writeInt8(streamNum, 0);\n                if (data instanceof Buffer) {\n                    data.copy(buff, 1);\n                }\n                else {\n                    buff.write(data, 1);\n                }\n                let i = 0;\n                for (; i < retryCount; ++i) {\n                    if (ws !== null && ws.readyState === WebSocket.OPEN) {\n                        ws.send(buff);\n                        break;\n                    }\n                    else {\n                        ws = yield createWS();\n                    }\n                }\n                if (i >= retryCount) {\n                    throw new Error(\"can't send data to ws\");\n                }\n            });\n        }\n        stdin.on('data', (data) => {\n            queue = queue.then(() => processData(data));\n        });\n        stdin.on('end', () => {\n            if (ws) {\n                ws.close();\n            }\n        });\n        return () => ws;\n    }\n    /**\n     * Connect to a web socket endpoint.\n     * @param path The HTTP Path to connect to on the server.\n     * @param textHandler Callback for text over the web socket.\n     *      Returns true if the connection should be kept alive, false to disconnect.\n     * @param binaryHandler Callback for binary data over the web socket.\n     *      Returns true if the connection should be kept alive, false to disconnect.\n     */\n    connect(path, textHandler, binaryHandler) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const cluster = this.config.getCurrentCluster();\n            if (!cluster) {\n                throw new Error('No cluster is defined.');\n            }\n            const server = cluster.server;\n            const ssl = server.startsWith('https://');\n            const target = ssl ? server.substr(8) : server.substr(7);\n            const proto = ssl ? 'wss' : 'ws';\n            const uri = `${proto}://${target}${path}`;\n            const opts = {};\n            yield this.config.applytoHTTPSOptions(opts);\n            return yield new Promise((resolve, reject) => {\n                const client = this.socketFactory\n                    ? this.socketFactory(uri, opts)\n                    : new WebSocket(uri, protocols, opts);\n                let resolved = false;\n                client.onopen = () => {\n                    resolved = true;\n                    resolve(client);\n                };\n                client.onerror = (err) => {\n                    if (!resolved) {\n                        reject(err);\n                    }\n                };\n                client.onmessage = ({ data }) => {\n                    // TODO: support ArrayBuffer and Buffer[] data types?\n                    if (typeof data === 'string') {\n                        if (textHandler && !textHandler(data)) {\n                            client.close();\n                        }\n                    }\n                    else if (data instanceof Buffer) {\n                        const streamNum = data.readInt8(0);\n                        if (binaryHandler && !binaryHandler(streamNum, data.slice(1))) {\n                            client.close();\n                        }\n                    }\n                };\n            });\n        });\n    }\n}\nWebSocketHandler.StdinStream = 0;\nWebSocketHandler.StdoutStream = 1;\nWebSocketHandler.StderrStream = 2;\nWebSocketHandler.StatusStream = 3;\nWebSocketHandler.ResizeStream = 4;\nexports.WebSocketHandler = WebSocketHandler;\n//# sourceMappingURL=web-socket-handler.js.map"]},"metadata":{},"sourceType":"script"}