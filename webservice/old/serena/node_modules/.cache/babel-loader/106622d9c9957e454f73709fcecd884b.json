{"ast":null,"code":"/**\n * Hash-based Message Authentication Code implementation. Requires a message\n * digest object that can be obtained, for example, from forge.md.sha1 or\n * forge.md.md5.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\n\nrequire('./md');\n\nrequire('./util');\n/* HMAC API */\n\n\nvar hmac = module.exports = forge.hmac = forge.hmac || {};\n/**\n * Creates an HMAC object that uses the given message digest object.\n *\n * @return an HMAC object.\n */\n\nhmac.create = function () {\n  // the hmac key to use\n  var _key = null; // the message digest to use\n\n  var _md = null; // the inner padding\n\n  var _ipadding = null; // the outer padding\n\n  var _opadding = null; // hmac context\n\n  var ctx = {};\n  /**\n   * Starts or restarts the HMAC with the given key and message digest.\n   *\n   * @param md the message digest to use, null to reuse the previous one,\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\n   * @param key the key to use as a string, array of bytes, byte buffer,\n   *           or null to reuse the previous key.\n   */\n\n  ctx.start = function (md, key) {\n    if (md !== null) {\n      if (typeof md === 'string') {\n        // create builtin message digest\n        md = md.toLowerCase();\n\n        if (md in forge.md.algorithms) {\n          _md = forge.md.algorithms[md].create();\n        } else {\n          throw new Error('Unknown hash algorithm \"' + md + '\"');\n        }\n      } else {\n        // store message digest\n        _md = md;\n      }\n    }\n\n    if (key === null) {\n      // reuse previous key\n      key = _key;\n    } else {\n      if (typeof key === 'string') {\n        // convert string into byte buffer\n        key = forge.util.createBuffer(key);\n      } else if (forge.util.isArray(key)) {\n        // convert byte array into byte buffer\n        var tmp = key;\n        key = forge.util.createBuffer();\n\n        for (var i = 0; i < tmp.length; ++i) {\n          key.putByte(tmp[i]);\n        }\n      } // if key is longer than blocksize, hash it\n\n\n      var keylen = key.length();\n\n      if (keylen > _md.blockLength) {\n        _md.start();\n\n        _md.update(key.bytes());\n\n        key = _md.digest();\n      } // mix key into inner and outer padding\n      // ipadding = [0x36 * blocksize] ^ key\n      // opadding = [0x5C * blocksize] ^ key\n\n\n      _ipadding = forge.util.createBuffer();\n      _opadding = forge.util.createBuffer();\n      keylen = key.length();\n\n      for (var i = 0; i < keylen; ++i) {\n        var tmp = key.at(i);\n\n        _ipadding.putByte(0x36 ^ tmp);\n\n        _opadding.putByte(0x5C ^ tmp);\n      } // if key is shorter than blocksize, add additional padding\n\n\n      if (keylen < _md.blockLength) {\n        var tmp = _md.blockLength - keylen;\n\n        for (var i = 0; i < tmp; ++i) {\n          _ipadding.putByte(0x36);\n\n          _opadding.putByte(0x5C);\n        }\n      }\n\n      _key = key;\n      _ipadding = _ipadding.bytes();\n      _opadding = _opadding.bytes();\n    } // digest is done like so: hash(opadding | hash(ipadding | message))\n    // prepare to do inner hash\n    // hash(ipadding | message)\n\n\n    _md.start();\n\n    _md.update(_ipadding);\n  };\n  /**\n   * Updates the HMAC with the given message bytes.\n   *\n   * @param bytes the bytes to update with.\n   */\n\n\n  ctx.update = function (bytes) {\n    _md.update(bytes);\n  };\n  /**\n   * Produces the Message Authentication Code (MAC).\n   *\n   * @return a byte buffer containing the digest value.\n   */\n\n\n  ctx.getMac = function () {\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n    // here we do the outer hashing\n    var inner = _md.digest().bytes();\n\n    _md.start();\n\n    _md.update(_opadding);\n\n    _md.update(inner);\n\n    return _md.digest();\n  }; // alias for getMac\n\n\n  ctx.digest = ctx.getMac;\n  return ctx;\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/hmac.js"],"names":["forge","require","hmac","module","exports","create","_key","_md","_ipadding","_opadding","ctx","start","md","key","toLowerCase","algorithms","Error","util","createBuffer","isArray","tmp","i","length","putByte","keylen","blockLength","update","bytes","digest","at","getMac","inner"],"mappings":"AAAA;;;;;;;;;AASA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,MAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;AAEA;;;AACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,OAAP,GAAiBJ,KAAK,CAACE,IAAN,GAAaF,KAAK,CAACE,IAAN,IAAc,EAAvD;AAEA;;;;;;AAKAA,IAAI,CAACG,MAAL,GAAc,YAAW;AACvB;AACA,MAAIC,IAAI,GAAG,IAAX,CAFuB,CAIvB;;AACA,MAAIC,GAAG,GAAG,IAAV,CALuB,CAOvB;;AACA,MAAIC,SAAS,GAAG,IAAhB,CARuB,CAUvB;;AACA,MAAIC,SAAS,GAAG,IAAhB,CAXuB,CAavB;;AACA,MAAIC,GAAG,GAAG,EAAV;AAEA;;;;;;;;;AAQAA,EAAAA,GAAG,CAACC,KAAJ,GAAY,UAASC,EAAT,EAAaC,GAAb,EAAkB;AAC5B,QAAGD,EAAE,KAAK,IAAV,EAAgB;AACd,UAAG,OAAOA,EAAP,KAAc,QAAjB,EAA2B;AACzB;AACAA,QAAAA,EAAE,GAAGA,EAAE,CAACE,WAAH,EAAL;;AACA,YAAGF,EAAE,IAAIZ,KAAK,CAACY,EAAN,CAASG,UAAlB,EAA8B;AAC5BR,UAAAA,GAAG,GAAGP,KAAK,CAACY,EAAN,CAASG,UAAT,CAAoBH,EAApB,EAAwBP,MAAxB,EAAN;AACD,SAFD,MAEO;AACL,gBAAM,IAAIW,KAAJ,CAAU,6BAA6BJ,EAA7B,GAAkC,GAA5C,CAAN;AACD;AACF,OARD,MAQO;AACL;AACAL,QAAAA,GAAG,GAAGK,EAAN;AACD;AACF;;AAED,QAAGC,GAAG,KAAK,IAAX,EAAiB;AACf;AACAA,MAAAA,GAAG,GAAGP,IAAN;AACD,KAHD,MAGO;AACL,UAAG,OAAOO,GAAP,KAAe,QAAlB,EAA4B;AAC1B;AACAA,QAAAA,GAAG,GAAGb,KAAK,CAACiB,IAAN,CAAWC,YAAX,CAAwBL,GAAxB,CAAN;AACD,OAHD,MAGO,IAAGb,KAAK,CAACiB,IAAN,CAAWE,OAAX,CAAmBN,GAAnB,CAAH,EAA4B;AACjC;AACA,YAAIO,GAAG,GAAGP,GAAV;AACAA,QAAAA,GAAG,GAAGb,KAAK,CAACiB,IAAN,CAAWC,YAAX,EAAN;;AACA,aAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,GAAG,CAACE,MAAvB,EAA+B,EAAED,CAAjC,EAAoC;AAClCR,UAAAA,GAAG,CAACU,OAAJ,CAAYH,GAAG,CAACC,CAAD,CAAf;AACD;AACF,OAXI,CAaL;;;AACA,UAAIG,MAAM,GAAGX,GAAG,CAACS,MAAJ,EAAb;;AACA,UAAGE,MAAM,GAAGjB,GAAG,CAACkB,WAAhB,EAA6B;AAC3BlB,QAAAA,GAAG,CAACI,KAAJ;;AACAJ,QAAAA,GAAG,CAACmB,MAAJ,CAAWb,GAAG,CAACc,KAAJ,EAAX;;AACAd,QAAAA,GAAG,GAAGN,GAAG,CAACqB,MAAJ,EAAN;AACD,OAnBI,CAqBL;AACA;AACA;;;AACApB,MAAAA,SAAS,GAAGR,KAAK,CAACiB,IAAN,CAAWC,YAAX,EAAZ;AACAT,MAAAA,SAAS,GAAGT,KAAK,CAACiB,IAAN,CAAWC,YAAX,EAAZ;AACAM,MAAAA,MAAM,GAAGX,GAAG,CAACS,MAAJ,EAAT;;AACA,WAAI,IAAID,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGG,MAAnB,EAA2B,EAAEH,CAA7B,EAAgC;AAC9B,YAAID,GAAG,GAAGP,GAAG,CAACgB,EAAJ,CAAOR,CAAP,CAAV;;AACAb,QAAAA,SAAS,CAACe,OAAV,CAAkB,OAAOH,GAAzB;;AACAX,QAAAA,SAAS,CAACc,OAAV,CAAkB,OAAOH,GAAzB;AACD,OA/BI,CAiCL;;;AACA,UAAGI,MAAM,GAAGjB,GAAG,CAACkB,WAAhB,EAA6B;AAC3B,YAAIL,GAAG,GAAGb,GAAG,CAACkB,WAAJ,GAAkBD,MAA5B;;AACA,aAAI,IAAIH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,GAAnB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3Bb,UAAAA,SAAS,CAACe,OAAV,CAAkB,IAAlB;;AACAd,UAAAA,SAAS,CAACc,OAAV,CAAkB,IAAlB;AACD;AACF;;AACDjB,MAAAA,IAAI,GAAGO,GAAP;AACAL,MAAAA,SAAS,GAAGA,SAAS,CAACmB,KAAV,EAAZ;AACAlB,MAAAA,SAAS,GAAGA,SAAS,CAACkB,KAAV,EAAZ;AACD,KA/D2B,CAiE5B;AAEA;AACA;;;AACApB,IAAAA,GAAG,CAACI,KAAJ;;AACAJ,IAAAA,GAAG,CAACmB,MAAJ,CAAWlB,SAAX;AACD,GAvED;AAyEA;;;;;;;AAKAE,EAAAA,GAAG,CAACgB,MAAJ,GAAa,UAASC,KAAT,EAAgB;AAC3BpB,IAAAA,GAAG,CAACmB,MAAJ,CAAWC,KAAX;AACD,GAFD;AAIA;;;;;;;AAKAjB,EAAAA,GAAG,CAACoB,MAAJ,GAAa,YAAW;AACtB;AACA;AACA,QAAIC,KAAK,GAAGxB,GAAG,CAACqB,MAAJ,GAAaD,KAAb,EAAZ;;AACApB,IAAAA,GAAG,CAACI,KAAJ;;AACAJ,IAAAA,GAAG,CAACmB,MAAJ,CAAWjB,SAAX;;AACAF,IAAAA,GAAG,CAACmB,MAAJ,CAAWK,KAAX;;AACA,WAAOxB,GAAG,CAACqB,MAAJ,EAAP;AACD,GARD,CA/GuB,CAwHvB;;;AACAlB,EAAAA,GAAG,CAACkB,MAAJ,GAAalB,GAAG,CAACoB,MAAjB;AAEA,SAAOpB,GAAP;AACD,CA5HD","sourcesContent":["/**\n * Hash-based Message Authentication Code implementation. Requires a message\n * digest object that can be obtained, for example, from forge.md.sha1 or\n * forge.md.md5.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\n/* HMAC API */\nvar hmac = module.exports = forge.hmac = forge.hmac || {};\n\n/**\n * Creates an HMAC object that uses the given message digest object.\n *\n * @return an HMAC object.\n */\nhmac.create = function() {\n  // the hmac key to use\n  var _key = null;\n\n  // the message digest to use\n  var _md = null;\n\n  // the inner padding\n  var _ipadding = null;\n\n  // the outer padding\n  var _opadding = null;\n\n  // hmac context\n  var ctx = {};\n\n  /**\n   * Starts or restarts the HMAC with the given key and message digest.\n   *\n   * @param md the message digest to use, null to reuse the previous one,\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\n   * @param key the key to use as a string, array of bytes, byte buffer,\n   *           or null to reuse the previous key.\n   */\n  ctx.start = function(md, key) {\n    if(md !== null) {\n      if(typeof md === 'string') {\n        // create builtin message digest\n        md = md.toLowerCase();\n        if(md in forge.md.algorithms) {\n          _md = forge.md.algorithms[md].create();\n        } else {\n          throw new Error('Unknown hash algorithm \"' + md + '\"');\n        }\n      } else {\n        // store message digest\n        _md = md;\n      }\n    }\n\n    if(key === null) {\n      // reuse previous key\n      key = _key;\n    } else {\n      if(typeof key === 'string') {\n        // convert string into byte buffer\n        key = forge.util.createBuffer(key);\n      } else if(forge.util.isArray(key)) {\n        // convert byte array into byte buffer\n        var tmp = key;\n        key = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i) {\n          key.putByte(tmp[i]);\n        }\n      }\n\n      // if key is longer than blocksize, hash it\n      var keylen = key.length();\n      if(keylen > _md.blockLength) {\n        _md.start();\n        _md.update(key.bytes());\n        key = _md.digest();\n      }\n\n      // mix key into inner and outer padding\n      // ipadding = [0x36 * blocksize] ^ key\n      // opadding = [0x5C * blocksize] ^ key\n      _ipadding = forge.util.createBuffer();\n      _opadding = forge.util.createBuffer();\n      keylen = key.length();\n      for(var i = 0; i < keylen; ++i) {\n        var tmp = key.at(i);\n        _ipadding.putByte(0x36 ^ tmp);\n        _opadding.putByte(0x5C ^ tmp);\n      }\n\n      // if key is shorter than blocksize, add additional padding\n      if(keylen < _md.blockLength) {\n        var tmp = _md.blockLength - keylen;\n        for(var i = 0; i < tmp; ++i) {\n          _ipadding.putByte(0x36);\n          _opadding.putByte(0x5C);\n        }\n      }\n      _key = key;\n      _ipadding = _ipadding.bytes();\n      _opadding = _opadding.bytes();\n    }\n\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n\n    // prepare to do inner hash\n    // hash(ipadding | message)\n    _md.start();\n    _md.update(_ipadding);\n  };\n\n  /**\n   * Updates the HMAC with the given message bytes.\n   *\n   * @param bytes the bytes to update with.\n   */\n  ctx.update = function(bytes) {\n    _md.update(bytes);\n  };\n\n  /**\n   * Produces the Message Authentication Code (MAC).\n   *\n   * @return a byte buffer containing the digest value.\n   */\n  ctx.getMac = function() {\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n    // here we do the outer hashing\n    var inner = _md.digest().bytes();\n    _md.start();\n    _md.update(_opadding);\n    _md.update(inner);\n    return _md.digest();\n  };\n  // alias for getMac\n  ctx.digest = ctx.getMac;\n\n  return ctx;\n};\n"]},"metadata":{},"sourceType":"script"}