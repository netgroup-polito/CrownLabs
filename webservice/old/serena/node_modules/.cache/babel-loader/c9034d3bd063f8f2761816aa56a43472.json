{"ast":null,"code":"'use strict';\n/* eslint camelcase: \"off\" */\n\nvar assert = require('assert');\n\nvar Zstream = require('pako/lib/zlib/zstream');\n\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\n\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\n\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n} // zlib modes\n\n\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\nvar GZIP_HEADER_ID1 = 0x1f;\nvar GZIP_HEADER_ID2 = 0x8b;\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\n\nfunction Zlib(mode) {\n  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {\n    throw new TypeError('Bad argument');\n  }\n\n  this.dictionary = null;\n  this.err = 0;\n  this.flush = 0;\n  this.init_done = false;\n  this.level = 0;\n  this.memLevel = 0;\n  this.mode = mode;\n  this.strategy = 0;\n  this.windowBits = 0;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.gzip_id_bytes_read = 0;\n}\n\nZlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n  assert(this.init_done, 'close before init');\n  assert(this.mode <= exports.UNZIP);\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n  this.dictionary = null;\n};\n\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n  assert.equal(arguments.length, 8);\n  assert(this.init_done, 'write before init');\n  assert(this.mode !== exports.NONE, 'already finalized');\n  assert.equal(false, this.write_in_progress, 'write already in progress');\n  assert.equal(false, this.pending_close, 'close is pending');\n  this.write_in_progress = true;\n  assert.equal(false, flush === undefined, 'must provide flush value');\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = Buffer.alloc(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  this.strm.avail_in = in_len;\n  this.strm.input = input;\n  this.strm.next_in = in_off;\n  this.strm.avail_out = out_len;\n  this.strm.output = out;\n  this.strm.next_out = out_off;\n  this.flush = flush;\n\n  if (!async) {\n    // sync version\n    this._process();\n\n    if (this._checkError()) {\n      return this._afterSync();\n    }\n\n    return;\n  } // async version\n\n\n  var self = this;\n  process.nextTick(function () {\n    self._process();\n\n    self._after();\n  });\n  return this;\n};\n\nZlib.prototype._afterSync = function () {\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n  this.write_in_progress = false;\n  return [avail_in, avail_out];\n};\n\nZlib.prototype._process = function () {\n  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out\n  // of room.  If there was avail_out left over, then it means\n  // that all of the input was consumed.\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflate(this.strm, this.flush);\n      break;\n\n    case exports.UNZIP:\n      if (this.strm.avail_in > 0) {\n        next_expected_header_byte = this.strm.next_in;\n      }\n\n      switch (this.gzip_id_bytes_read) {\n        case 0:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n            this.gzip_id_bytes_read = 1;\n            next_expected_header_byte++;\n\n            if (this.strm.avail_in === 1) {\n              // The only available byte was already read.\n              break;\n            }\n          } else {\n            this.mode = exports.INFLATE;\n            break;\n          }\n\n        // fallthrough\n\n        case 1:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n            this.gzip_id_bytes_read = 2;\n            this.mode = exports.GUNZIP;\n          } else {\n            // There is no actual difference between INFLATE and INFLATERAW\n            // (after initialization).\n            this.mode = exports.INFLATE;\n          }\n\n          break;\n\n        default:\n          throw new Error('invalid number of gzip magic number bytes read');\n      }\n\n    // fallthrough\n\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      this.err = zlib_inflate.inflate(this.strm, this.flush // If data was encoded with dictionary\n      );\n\n      if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n        // Load it\n        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n\n        if (this.err === exports.Z_OK) {\n          // And try to decode again\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n        } else if (this.err === exports.Z_DATA_ERROR) {\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n          // Make it possible for After() to tell a bad dictionary from bad\n          // input.\n          this.err = exports.Z_NEED_DICT;\n        }\n      }\n\n      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\n        // Bytes remain in input buffer. Perhaps this is another compressed\n        // member in the same archive, or just trailing garbage.\n        // Trailing zero bytes are okay, though, since they are frequently\n        // used for padding.\n        this.reset();\n        this.err = zlib_inflate.inflate(this.strm, this.flush);\n      }\n\n      break;\n\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n};\n\nZlib.prototype._checkError = function () {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (this.err) {\n    case exports.Z_OK:\n    case exports.Z_BUF_ERROR:\n      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n        this._error('unexpected end of file');\n\n        return false;\n      }\n\n      break;\n\n    case exports.Z_STREAM_END:\n      // normal statuses, not fatal\n      break;\n\n    case exports.Z_NEED_DICT:\n      if (this.dictionary == null) {\n        this._error('Missing dictionary');\n      } else {\n        this._error('Bad dictionary');\n      }\n\n      return false;\n\n    default:\n      // something else.\n      this._error('Zlib error');\n\n      return false;\n  }\n\n  return true;\n};\n\nZlib.prototype._after = function () {\n  if (!this._checkError()) {\n    return;\n  }\n\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n  this.write_in_progress = false; // call the write() cb\n\n  this.callback(avail_in, avail_out);\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype._error = function (message) {\n  if (this.strm.msg) {\n    message = this.strm.msg;\n  }\n\n  this.onerror(message, this.err // no hope of rescue.\n  );\n  this.write_in_progress = false;\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\n  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\n  assert(level >= -1 && level <= 9, 'invalid compression level');\n  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\n  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\n\n  this._init(level, windowBits, memLevel, strategy, dictionary);\n\n  this._setDictionary();\n};\n\nZlib.prototype.params = function () {\n  throw new Error('deflateParams Not supported');\n};\n\nZlib.prototype.reset = function () {\n  this._reset();\n\n  this._setDictionary();\n};\n\nZlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n  this.level = level;\n  this.windowBits = windowBits;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n  this.flush = exports.Z_NO_FLUSH;\n  this.err = exports.Z_OK;\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n    this.windowBits += 16;\n  }\n\n  if (this.mode === exports.UNZIP) {\n    this.windowBits += 32;\n  }\n\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n    this.windowBits = -1 * this.windowBits;\n  }\n\n  this.strm = new Zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Init error');\n  }\n\n  this.dictionary = dictionary;\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype._setDictionary = function () {\n  if (this.dictionary == null) {\n    return;\n  }\n\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n      break;\n\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to set dictionary');\n  }\n};\n\nZlib.prototype._reset = function () {\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n    case exports.GZIP:\n      this.err = zlib_deflate.deflateReset(this.strm);\n      break;\n\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n    case exports.GUNZIP:\n      this.err = zlib_inflate.inflateReset(this.strm);\n      break;\n\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to reset stream');\n  }\n};\n\nexports.Zlib = Zlib;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/browserify-zlib/lib/binding.js"],"names":["assert","require","Zstream","zlib_deflate","zlib_inflate","constants","key","exports","NONE","DEFLATE","INFLATE","GZIP","GUNZIP","DEFLATERAW","INFLATERAW","UNZIP","GZIP_HEADER_ID1","GZIP_HEADER_ID2","Zlib","mode","TypeError","dictionary","err","flush","init_done","level","memLevel","strategy","windowBits","write_in_progress","pending_close","gzip_id_bytes_read","prototype","close","deflateEnd","strm","inflateEnd","write","input","in_off","in_len","out","out_off","out_len","_write","writeSync","async","equal","arguments","length","undefined","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Error","Buffer","alloc","avail_in","next_in","avail_out","output","next_out","_process","_checkError","_afterSync","self","process","nextTick","_after","next_expected_header_byte","deflate","inflate","Z_NEED_DICT","inflateSetDictionary","Z_OK","Z_DATA_ERROR","Z_STREAM_END","reset","Z_BUF_ERROR","_error","callback","message","msg","onerror","init","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","_init","_setDictionary","params","_reset","deflateInit2","Z_DEFLATED","inflateInit2","deflateSetDictionary","deflateReset","inflateReset"],"mappings":"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","sourcesContent":["'use strict';\n/* eslint camelcase: \"off\" */\n\nvar assert = require('assert');\n\nvar Zstream = require('pako/lib/zlib/zstream');\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n}\n\n// zlib modes\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n\nvar GZIP_HEADER_ID1 = 0x1f;\nvar GZIP_HEADER_ID2 = 0x8b;\n\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\nfunction Zlib(mode) {\n  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {\n    throw new TypeError('Bad argument');\n  }\n\n  this.dictionary = null;\n  this.err = 0;\n  this.flush = 0;\n  this.init_done = false;\n  this.level = 0;\n  this.memLevel = 0;\n  this.mode = mode;\n  this.strategy = 0;\n  this.windowBits = 0;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.gzip_id_bytes_read = 0;\n}\n\nZlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  assert(this.init_done, 'close before init');\n  assert(this.mode <= exports.UNZIP);\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n\n  this.dictionary = null;\n};\n\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n  assert.equal(arguments.length, 8);\n\n  assert(this.init_done, 'write before init');\n  assert(this.mode !== exports.NONE, 'already finalized');\n  assert.equal(false, this.write_in_progress, 'write already in progress');\n  assert.equal(false, this.pending_close, 'close is pending');\n\n  this.write_in_progress = true;\n\n  assert.equal(false, flush === undefined, 'must provide flush value');\n\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = Buffer.alloc(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  this.strm.avail_in = in_len;\n  this.strm.input = input;\n  this.strm.next_in = in_off;\n  this.strm.avail_out = out_len;\n  this.strm.output = out;\n  this.strm.next_out = out_off;\n  this.flush = flush;\n\n  if (!async) {\n    // sync version\n    this._process();\n\n    if (this._checkError()) {\n      return this._afterSync();\n    }\n    return;\n  }\n\n  // async version\n  var self = this;\n  process.nextTick(function () {\n    self._process();\n    self._after();\n  });\n\n  return this;\n};\n\nZlib.prototype._afterSync = function () {\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  return [avail_in, avail_out];\n};\n\nZlib.prototype._process = function () {\n  var next_expected_header_byte = null;\n\n  // If the avail_out is left at 0, then it means that it ran out\n  // of room.  If there was avail_out left over, then it means\n  // that all of the input was consumed.\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflate(this.strm, this.flush);\n      break;\n    case exports.UNZIP:\n      if (this.strm.avail_in > 0) {\n        next_expected_header_byte = this.strm.next_in;\n      }\n\n      switch (this.gzip_id_bytes_read) {\n        case 0:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n            this.gzip_id_bytes_read = 1;\n            next_expected_header_byte++;\n\n            if (this.strm.avail_in === 1) {\n              // The only available byte was already read.\n              break;\n            }\n          } else {\n            this.mode = exports.INFLATE;\n            break;\n          }\n\n        // fallthrough\n        case 1:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n            this.gzip_id_bytes_read = 2;\n            this.mode = exports.GUNZIP;\n          } else {\n            // There is no actual difference between INFLATE and INFLATERAW\n            // (after initialization).\n            this.mode = exports.INFLATE;\n          }\n\n          break;\n        default:\n          throw new Error('invalid number of gzip magic number bytes read');\n      }\n\n    // fallthrough\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      this.err = zlib_inflate.inflate(this.strm, this.flush\n\n      // If data was encoded with dictionary\n      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n        // Load it\n        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n        if (this.err === exports.Z_OK) {\n          // And try to decode again\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n        } else if (this.err === exports.Z_DATA_ERROR) {\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n          // Make it possible for After() to tell a bad dictionary from bad\n          // input.\n          this.err = exports.Z_NEED_DICT;\n        }\n      }\n      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\n        // Bytes remain in input buffer. Perhaps this is another compressed\n        // member in the same archive, or just trailing garbage.\n        // Trailing zero bytes are okay, though, since they are frequently\n        // used for padding.\n\n        this.reset();\n        this.err = zlib_inflate.inflate(this.strm, this.flush);\n      }\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n};\n\nZlib.prototype._checkError = function () {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (this.err) {\n    case exports.Z_OK:\n    case exports.Z_BUF_ERROR:\n      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n        this._error('unexpected end of file');\n        return false;\n      }\n      break;\n    case exports.Z_STREAM_END:\n      // normal statuses, not fatal\n      break;\n    case exports.Z_NEED_DICT:\n      if (this.dictionary == null) {\n        this._error('Missing dictionary');\n      } else {\n        this._error('Bad dictionary');\n      }\n      return false;\n    default:\n      // something else.\n      this._error('Zlib error');\n      return false;\n  }\n\n  return true;\n};\n\nZlib.prototype._after = function () {\n  if (!this._checkError()) {\n    return;\n  }\n\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  // call the write() cb\n  this.callback(avail_in, avail_out);\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype._error = function (message) {\n  if (this.strm.msg) {\n    message = this.strm.msg;\n  }\n  this.onerror(message, this.err\n\n  // no hope of rescue.\n  );this.write_in_progress = false;\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\n\n  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\n  assert(level >= -1 && level <= 9, 'invalid compression level');\n\n  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\n\n  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\n\n  this._init(level, windowBits, memLevel, strategy, dictionary);\n  this._setDictionary();\n};\n\nZlib.prototype.params = function () {\n  throw new Error('deflateParams Not supported');\n};\n\nZlib.prototype.reset = function () {\n  this._reset();\n  this._setDictionary();\n};\n\nZlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n  this.level = level;\n  this.windowBits = windowBits;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n\n  this.flush = exports.Z_NO_FLUSH;\n\n  this.err = exports.Z_OK;\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n    this.windowBits += 16;\n  }\n\n  if (this.mode === exports.UNZIP) {\n    this.windowBits += 32;\n  }\n\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n    this.windowBits = -1 * this.windowBits;\n  }\n\n  this.strm = new Zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Init error');\n  }\n\n  this.dictionary = dictionary;\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype._setDictionary = function () {\n  if (this.dictionary == null) {\n    return;\n  }\n\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to set dictionary');\n  }\n};\n\nZlib.prototype._reset = function () {\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n    case exports.GZIP:\n      this.err = zlib_deflate.deflateReset(this.strm);\n      break;\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n    case exports.GUNZIP:\n      this.err = zlib_inflate.inflateReset(this.strm);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to reset stream');\n  }\n};\n\nexports.Zlib = Zlib;"]},"metadata":{},"sourceType":"script"}