{"ast":null,"code":"'use strict';\n\nconst indentString = require('indent-string');\n\nconst cleanStack = require('clean-stack');\n\nconst cleanInternalStack = stack => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\nclass AggregateError extends Error {\n  constructor(errors) {\n    // Even though strings are iterable, we don't allow them to prevent subtle user mistakes\n    if (!errors[Symbol.iterator] || typeof errors === 'string') {\n      throw new TypeError(`Expected input to be iterable, got ${typeof errors}`);\n    }\n\n    errors = Array.from(errors).map(err => err instanceof Error ? err : new Error(err));\n    let message = errors.map(err => cleanInternalStack(cleanStack(err.stack))).join('\\n');\n    message = '\\n' + indentString(message, 4);\n    super(message);\n    this.name = this.constructor.name;\n    Object.defineProperty(this, '_errors', {\n      value: errors\n    });\n  }\n\n  *[Symbol.iterator]() {\n    for (const error of this._errors) {\n      yield error;\n    }\n  }\n\n}\n\nmodule.exports = AggregateError;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/p-some/node_modules/aggregate-error/index.js"],"names":["indentString","require","cleanStack","cleanInternalStack","stack","replace","AggregateError","Error","constructor","errors","Symbol","iterator","TypeError","Array","from","map","err","message","join","name","Object","defineProperty","value","error","_errors","module","exports"],"mappings":"AAAA;;AACA,MAAMA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,aAAD,CAA1B;;AAEA,MAAME,kBAAkB,GAAGC,KAAK,IAAIA,KAAK,CAACC,OAAN,CAAc,+CAAd,EAA+D,EAA/D,CAApC;;AAEA,MAAMC,cAAN,SAA6BC,KAA7B,CAAmC;AAClCC,EAAAA,WAAW,CAACC,MAAD,EAAS;AACnB;AACA,QAAI,CAACA,MAAM,CAACC,MAAM,CAACC,QAAR,CAAP,IAA4B,OAAOF,MAAP,KAAkB,QAAlD,EAA4D;AAC3D,YAAM,IAAIG,SAAJ,CAAe,sCAAqC,OAAOH,MAAO,EAAlE,CAAN;AACA;;AAEDA,IAAAA,MAAM,GAAGI,KAAK,CAACC,IAAN,CAAWL,MAAX,EAAmBM,GAAnB,CAAuBC,GAAG,IAAIA,GAAG,YAAYT,KAAf,GAAuBS,GAAvB,GAA6B,IAAIT,KAAJ,CAAUS,GAAV,CAA3D,CAAT;AAEA,QAAIC,OAAO,GAAGR,MAAM,CAACM,GAAP,CAAWC,GAAG,IAAIb,kBAAkB,CAACD,UAAU,CAACc,GAAG,CAACZ,KAAL,CAAX,CAApC,EAA6Dc,IAA7D,CAAkE,IAAlE,CAAd;AACAD,IAAAA,OAAO,GAAG,OAAOjB,YAAY,CAACiB,OAAD,EAAU,CAAV,CAA7B;AAEA,UAAMA,OAAN;AACA,SAAKE,IAAL,GAAY,KAAKX,WAAL,CAAiBW,IAA7B;AACAC,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AAACC,MAAAA,KAAK,EAAEb;AAAR,KAAvC;AACA;;AACD,IAAGC,MAAM,CAACC,QAAV,IAAsB;AACrB,SAAK,MAAMY,KAAX,IAAoB,KAAKC,OAAzB,EAAkC;AACjC,YAAMD,KAAN;AACA;AACD;;AApBiC;;AAuBnCE,MAAM,CAACC,OAAP,GAAiBpB,cAAjB","sourcesContent":["'use strict';\nconst indentString = require('indent-string');\nconst cleanStack = require('clean-stack');\n\nconst cleanInternalStack = stack => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\nclass AggregateError extends Error {\n\tconstructor(errors) {\n\t\t// Even though strings are iterable, we don't allow them to prevent subtle user mistakes\n\t\tif (!errors[Symbol.iterator] || typeof errors === 'string') {\n\t\t\tthrow new TypeError(`Expected input to be iterable, got ${typeof errors}`);\n\t\t}\n\n\t\terrors = Array.from(errors).map(err => err instanceof Error ? err : new Error(err));\n\n\t\tlet message = errors.map(err => cleanInternalStack(cleanStack(err.stack))).join('\\n');\n\t\tmessage = '\\n' + indentString(message, 4);\n\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tObject.defineProperty(this, '_errors', {value: errors});\n\t}\n\t* [Symbol.iterator]() {\n\t\tfor (const error of this._errors) {\n\t\t\tyield error;\n\t\t}\n\t}\n}\n\nmodule.exports = AggregateError;\n"]},"metadata":{},"sourceType":"script"}