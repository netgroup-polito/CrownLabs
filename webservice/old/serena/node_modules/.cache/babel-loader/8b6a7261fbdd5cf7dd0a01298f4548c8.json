{"ast":null,"code":"/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\n\nrequire('./random');\n\nrequire('./util'); // shortcut for PSS API\n\n\nvar pss = module.exports = forge.pss = forge.pss || {};\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */\n\npss.create = function (options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if (arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n  var salt_ = options.salt || null;\n\n  if (typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n\n  var sLen;\n\n  if ('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if (salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n\n  if (salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n\n  var prng = options.prng || forge.random;\n  var pssobj = {};\n  /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */\n\n  pssobj.encode = function (md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n\n    var mHash = md.digest().getBytes();\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */\n\n\n    var salt;\n\n    if (salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n\n\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */\n\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */\n\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n\n    var maskedDB = '';\n\n    for (i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */\n\n\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);\n    /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */\n\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n  /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n\n\n  pssobj.verify = function (mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n    /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */\n\n    em = em.substr(-emLen);\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */\n\n\n    if (em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */\n\n\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n\n\n    var dbMask = mgf.generate(h, maskLen);\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n\n    var db = '';\n\n    for (i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */\n\n\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i++) {\n      if (db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n\n    if (db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n    /* 11. Let salt be the last sLen octets of DB. */\n\n\n    var salt = db.substr(-sLen);\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n\n    return h === h_;\n  };\n\n  return pssobj;\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/pss.js"],"names":["forge","require","pss","module","exports","create","options","arguments","length","md","mgf","saltLength","hash","hLen","digestLength","salt_","salt","util","createBuffer","sLen","Error","prng","random","pssobj","encode","modBits","i","emBits","emLen","Math","ceil","mHash","digest","getBytes","getBytesSync","bytes","m_","ByteBuffer","fillWithByte","putBytes","start","update","h","ps","putByte","db","maskLen","dbMask","generate","maskedDB","String","fromCharCode","charCodeAt","mask","substr","verify","em","checkLen","h_"],"mappings":"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","sourcesContent":["/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\nrequire('./random');\nrequire('./util');\n\n// shortcut for PSS API\nvar pss = module.exports = forge.pss = forge.pss || {};\n\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */\npss.create = function(options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if(arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n\n  var salt_ = options.salt || null;\n  if(typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n\n  var sLen;\n  if('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if(salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n\n  if(salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n\n  var prng = options.prng || forge.random;\n\n  var pssobj = {};\n\n  /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */\n  pssobj.encode = function(md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n    var mHash = md.digest().getBytes();\n\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */\n    var salt;\n    if(salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n    var maskedDB = '';\n    for(i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\n      maskedDB.substr(1);\n\n    /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n\n  /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  pssobj.verify = function(mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */\n    em = em.substr(-emLen);\n\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */\n    if(em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    if((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n    var db = '';\n    for(i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */\n    var checkLen = emLen - hLen - sLen - 2;\n    for(i = 0; i < checkLen; i++) {\n      if(db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n\n    if(db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n\n    /* 11. Let salt be the last sLen octets of DB. */\n    var salt = db.substr(-sLen);\n\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n    return h === h_;\n  };\n\n  return pssobj;\n};\n"]},"metadata":{},"sourceType":"script"}