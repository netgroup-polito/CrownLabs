{"ast":null,"code":"var wrappy = require('wrappy');\n\nvar reqs = Object.create(null);\n\nvar once = require('once');\n\nmodule.exports = wrappy(inflight);\n\nfunction inflight(key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb);\n    return null;\n  } else {\n    reqs[key] = [cb];\n    return makeres(key);\n  }\n}\n\nfunction makeres(key) {\n  return once(function RES() {\n    var cbs = reqs[key];\n    var len = cbs.length;\n    var args = slice(arguments); // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args);\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len);\n        process.nextTick(function () {\n          RES.apply(null, args);\n        });\n      } else {\n        delete reqs[key];\n      }\n    }\n  });\n}\n\nfunction slice(args) {\n  var length = args.length;\n  var array = [];\n\n  for (var i = 0; i < length; i++) array[i] = args[i];\n\n  return array;\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/inflight/inflight.js"],"names":["wrappy","require","reqs","Object","create","once","module","exports","inflight","key","cb","push","makeres","RES","cbs","len","length","args","slice","arguments","i","apply","splice","process","nextTick","array"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAX;;AACA,IAAIC,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAAlB;;AAEAK,MAAM,CAACC,OAAP,GAAiBP,MAAM,CAACQ,QAAD,CAAvB;;AAEA,SAASA,QAAT,CAAmBC,GAAnB,EAAwBC,EAAxB,EAA4B;AAC1B,MAAIR,IAAI,CAACO,GAAD,CAAR,EAAe;AACbP,IAAAA,IAAI,CAACO,GAAD,CAAJ,CAAUE,IAAV,CAAeD,EAAf;AACA,WAAO,IAAP;AACD,GAHD,MAGO;AACLR,IAAAA,IAAI,CAACO,GAAD,CAAJ,GAAY,CAACC,EAAD,CAAZ;AACA,WAAOE,OAAO,CAACH,GAAD,CAAd;AACD;AACF;;AAED,SAASG,OAAT,CAAkBH,GAAlB,EAAuB;AACrB,SAAOJ,IAAI,CAAC,SAASQ,GAAT,GAAgB;AAC1B,QAAIC,GAAG,GAAGZ,IAAI,CAACO,GAAD,CAAd;AACA,QAAIM,GAAG,GAAGD,GAAG,CAACE,MAAd;AACA,QAAIC,IAAI,GAAGC,KAAK,CAACC,SAAD,CAAhB,CAH0B,CAK1B;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI;AACF,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC5BN,QAAAA,GAAG,CAACM,CAAD,CAAH,CAAOC,KAAP,CAAa,IAAb,EAAmBJ,IAAnB;AACD;AACF,KAJD,SAIU;AACR,UAAIH,GAAG,CAACE,MAAJ,GAAaD,GAAjB,EAAsB;AACpB;AACA;AACAD,QAAAA,GAAG,CAACQ,MAAJ,CAAW,CAAX,EAAcP,GAAd;AACAQ,QAAAA,OAAO,CAACC,QAAR,CAAiB,YAAY;AAC3BX,UAAAA,GAAG,CAACQ,KAAJ,CAAU,IAAV,EAAgBJ,IAAhB;AACD,SAFD;AAGD,OAPD,MAOO;AACL,eAAOf,IAAI,CAACO,GAAD,CAAX;AACD;AACF;AACF,GA3BU,CAAX;AA4BD;;AAED,SAASS,KAAT,CAAgBD,IAAhB,EAAsB;AACpB,MAAID,MAAM,GAAGC,IAAI,CAACD,MAAlB;AACA,MAAIS,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,EAA7B,EAAiCK,KAAK,CAACL,CAAD,CAAL,GAAWH,IAAI,CAACG,CAAD,CAAf;;AACjC,SAAOK,KAAP;AACD","sourcesContent":["var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n"]},"metadata":{},"sourceType":"script"}