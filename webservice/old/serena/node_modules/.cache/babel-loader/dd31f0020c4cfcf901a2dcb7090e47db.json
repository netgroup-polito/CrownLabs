{"ast":null,"code":"/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./aes');\n\nrequire('./sha256');\n\nrequire('./prng');\n\nrequire('./util');\n\n(function () {\n  // forge.random already defined\n  if (forge.random && forge.random.getBytes) {\n    module.exports = forge.random;\n    return;\n  }\n\n  (function (jQuery) {\n    // the default prng plugin, uses AES-128\n    var prng_aes = {};\n\n    var _prng_aes_output = new Array(4);\n\n    var _prng_aes_buffer = forge.util.createBuffer();\n\n    prng_aes.formatKey = function (key) {\n      // convert the key into 32-bit integers\n      var tmp = forge.util.createBuffer(key);\n      key = new Array(4);\n      key[0] = tmp.getInt32();\n      key[1] = tmp.getInt32();\n      key[2] = tmp.getInt32();\n      key[3] = tmp.getInt32(); // return the expanded key\n\n      return forge.aes._expandKey(key, false);\n    };\n\n    prng_aes.formatSeed = function (seed) {\n      // convert seed into 32-bit integers\n      var tmp = forge.util.createBuffer(seed);\n      seed = new Array(4);\n      seed[0] = tmp.getInt32();\n      seed[1] = tmp.getInt32();\n      seed[2] = tmp.getInt32();\n      seed[3] = tmp.getInt32();\n      return seed;\n    };\n\n    prng_aes.cipher = function (key, seed) {\n      forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n\n      return _prng_aes_buffer.getBytes();\n    };\n\n    prng_aes.increment = function (seed) {\n      // FIXME: do we care about carry or signed issues?\n      ++seed[3];\n      return seed;\n    };\n\n    prng_aes.md = forge.md.sha256;\n    /**\n     * Creates a new PRNG.\n     */\n\n    function spawnPrng() {\n      var ctx = forge.prng.create(prng_aes);\n      /**\n       * Gets random bytes. If a native secure crypto API is unavailable, this\n       * method tries to make the bytes more unpredictable by drawing from data that\n       * can be collected from the user of the browser, eg: mouse movement.\n       *\n       * If a callback is given, this method will be called asynchronously.\n       *\n       * @param count the number of random bytes to get.\n       * @param [callback(err, bytes)] called once the operation completes.\n       *\n       * @return the random bytes in a string.\n       */\n\n      ctx.getBytes = function (count, callback) {\n        return ctx.generate(count, callback);\n      };\n      /**\n       * Gets random bytes asynchronously. If a native secure crypto API is\n       * unavailable, this method tries to make the bytes more unpredictable by\n       * drawing from data that can be collected from the user of the browser,\n       * eg: mouse movement.\n       *\n       * @param count the number of random bytes to get.\n       *\n       * @return the random bytes in a string.\n       */\n\n\n      ctx.getBytesSync = function (count) {\n        return ctx.generate(count);\n      };\n\n      return ctx;\n    } // create default prng context\n\n\n    var _ctx = spawnPrng(); // add other sources of entropy only if window.crypto.getRandomValues is not\n    // available -- otherwise this source will be automatically used by the prng\n\n\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n\n    if (_crypto && _crypto.getRandomValues) {\n      getRandomValues = function (arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {\n      // if this is a web worker, do not use weak entropy, instead register to\n      // receive strong entropy asynchronously from the main thread\n      if (typeof window === 'undefined' || window.document === undefined) {} // FIXME:\n      // get load time entropy\n\n\n      _ctx.collectInt(+new Date(), 32); // add some entropy from navigator object\n\n\n      if (typeof navigator !== 'undefined') {\n        var _navBytes = '';\n\n        for (var key in navigator) {\n          try {\n            if (typeof navigator[key] == 'string') {\n              _navBytes += navigator[key];\n            }\n          } catch (e) {\n            /* Some navigator keys might not be accessible, e.g. the geolocation\n              attribute throws an exception if touched in Mozilla chrome://\n              context.\n               Silently ignore this and just don't use this as a source of\n              entropy. */\n          }\n        }\n\n        _ctx.collect(_navBytes);\n\n        _navBytes = null;\n      } // add mouse and keyboard collectors if jquery is available\n\n\n      if (jQuery) {\n        // set up mouse entropy capture\n        jQuery().mousemove(function (e) {\n          // add mouse coords\n          _ctx.collectInt(e.clientX, 16);\n\n          _ctx.collectInt(e.clientY, 16);\n        }); // set up keyboard entropy capture\n\n        jQuery().keypress(function (e) {\n          _ctx.collectInt(e.charCode, 8);\n        });\n      }\n    }\n    /* Random API */\n\n\n    if (!forge.random) {\n      forge.random = _ctx;\n    } else {\n      // extend forge.random with _ctx\n      for (var key in _ctx) {\n        forge.random[key] = _ctx[key];\n      }\n    } // expose spawn PRNG\n\n\n    forge.random.createInstance = spawnPrng;\n    module.exports = forge.random;\n  })(typeof jQuery !== 'undefined' ? jQuery : null);\n})();","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/random.js"],"names":["forge","require","random","getBytes","module","exports","jQuery","prng_aes","_prng_aes_output","Array","_prng_aes_buffer","util","createBuffer","formatKey","key","tmp","getInt32","aes","_expandKey","formatSeed","seed","cipher","_updateBlock","putInt32","increment","md","sha256","spawnPrng","ctx","prng","create","count","callback","generate","getBytesSync","_ctx","getRandomValues","globalScope","_crypto","crypto","msCrypto","arr","options","usePureJavaScript","isNodejs","window","document","undefined","collectInt","Date","navigator","_navBytes","e","collect","mousemove","clientX","clientY","keypress","charCode","createInstance"],"mappings":"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","sourcesContent":["/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./sha256');\nrequire('./prng');\nrequire('./util');\n\n(function() {\n\n// forge.random already defined\nif(forge.random && forge.random.getBytes) {\n  module.exports = forge.random;\n  return;\n}\n\n(function(jQuery) {\n\n// the default prng plugin, uses AES-128\nvar prng_aes = {};\nvar _prng_aes_output = new Array(4);\nvar _prng_aes_buffer = forge.util.createBuffer();\nprng_aes.formatKey = function(key) {\n  // convert the key into 32-bit integers\n  var tmp = forge.util.createBuffer(key);\n  key = new Array(4);\n  key[0] = tmp.getInt32();\n  key[1] = tmp.getInt32();\n  key[2] = tmp.getInt32();\n  key[3] = tmp.getInt32();\n\n  // return the expanded key\n  return forge.aes._expandKey(key, false);\n};\nprng_aes.formatSeed = function(seed) {\n  // convert seed into 32-bit integers\n  var tmp = forge.util.createBuffer(seed);\n  seed = new Array(4);\n  seed[0] = tmp.getInt32();\n  seed[1] = tmp.getInt32();\n  seed[2] = tmp.getInt32();\n  seed[3] = tmp.getInt32();\n  return seed;\n};\nprng_aes.cipher = function(key, seed) {\n  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n  return _prng_aes_buffer.getBytes();\n};\nprng_aes.increment = function(seed) {\n  // FIXME: do we care about carry or signed issues?\n  ++seed[3];\n  return seed;\n};\nprng_aes.md = forge.md.sha256;\n\n/**\n * Creates a new PRNG.\n */\nfunction spawnPrng() {\n  var ctx = forge.prng.create(prng_aes);\n\n  /**\n   * Gets random bytes. If a native secure crypto API is unavailable, this\n   * method tries to make the bytes more unpredictable by drawing from data that\n   * can be collected from the user of the browser, eg: mouse movement.\n   *\n   * If a callback is given, this method will be called asynchronously.\n   *\n   * @param count the number of random bytes to get.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytes = function(count, callback) {\n    return ctx.generate(count, callback);\n  };\n\n  /**\n   * Gets random bytes asynchronously. If a native secure crypto API is\n   * unavailable, this method tries to make the bytes more unpredictable by\n   * drawing from data that can be collected from the user of the browser,\n   * eg: mouse movement.\n   *\n   * @param count the number of random bytes to get.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytesSync = function(count) {\n    return ctx.generate(count);\n  };\n\n  return ctx;\n}\n\n// create default prng context\nvar _ctx = spawnPrng();\n\n// add other sources of entropy only if window.crypto.getRandomValues is not\n// available -- otherwise this source will be automatically used by the prng\nvar getRandomValues = null;\nvar globalScope = forge.util.globalScope;\nvar _crypto = globalScope.crypto || globalScope.msCrypto;\nif(_crypto && _crypto.getRandomValues) {\n  getRandomValues = function(arr) {\n    return _crypto.getRandomValues(arr);\n  };\n}\n\nif(forge.options.usePureJavaScript ||\n  (!forge.util.isNodejs && !getRandomValues)) {\n  // if this is a web worker, do not use weak entropy, instead register to\n  // receive strong entropy asynchronously from the main thread\n  if(typeof window === 'undefined' || window.document === undefined) {\n    // FIXME:\n  }\n\n  // get load time entropy\n  _ctx.collectInt(+new Date(), 32);\n\n  // add some entropy from navigator object\n  if(typeof(navigator) !== 'undefined') {\n    var _navBytes = '';\n    for(var key in navigator) {\n      try {\n        if(typeof(navigator[key]) == 'string') {\n          _navBytes += navigator[key];\n        }\n      } catch(e) {\n        /* Some navigator keys might not be accessible, e.g. the geolocation\n          attribute throws an exception if touched in Mozilla chrome://\n          context.\n\n          Silently ignore this and just don't use this as a source of\n          entropy. */\n      }\n    }\n    _ctx.collect(_navBytes);\n    _navBytes = null;\n  }\n\n  // add mouse and keyboard collectors if jquery is available\n  if(jQuery) {\n    // set up mouse entropy capture\n    jQuery().mousemove(function(e) {\n      // add mouse coords\n      _ctx.collectInt(e.clientX, 16);\n      _ctx.collectInt(e.clientY, 16);\n    });\n\n    // set up keyboard entropy capture\n    jQuery().keypress(function(e) {\n      _ctx.collectInt(e.charCode, 8);\n    });\n  }\n}\n\n/* Random API */\nif(!forge.random) {\n  forge.random = _ctx;\n} else {\n  // extend forge.random with _ctx\n  for(var key in _ctx) {\n    forge.random[key] = _ctx[key];\n  }\n}\n\n// expose spawn PRNG\nforge.random.createInstance = spawnPrng;\n\nmodule.exports = forge.random;\n\n})(typeof(jQuery) !== 'undefined' ? jQuery : null);\n\n})();\n"]},"metadata":{},"sourceType":"script"}