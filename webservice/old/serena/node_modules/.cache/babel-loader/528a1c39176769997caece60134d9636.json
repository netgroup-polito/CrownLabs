{"ast":null,"code":"'use strict';\n\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return decodeURIComponent(components.join(''));\n  } catch (err) {// Do nothing\n  }\n\n  if (components.length === 1) {\n    return components;\n  }\n\n  split = split || 1; // Split the array in 2 parts\n\n  var left = components.slice(0, split);\n  var right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch (err) {\n    var tokens = input.match(singleMatcher);\n\n    for (var i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher);\n    }\n\n    return input;\n  }\n}\n\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  var replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  var match = multiMatcher.exec(input);\n\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch (err) {\n      var result = decode(match[0]);\n\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n\n    match = multiMatcher.exec(input);\n  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\n\n  replaceMap['%C2'] = '\\uFFFD';\n  var entries = Object.keys(replaceMap);\n\n  for (var i = 0; i < entries.length; i++) {\n    // Replace all decoded components\n    var key = entries[i];\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n\n  return input;\n}\n\nmodule.exports = function (encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n\n  try {\n    encodedURI = encodedURI.replace(/\\+/g, ' '); // Try the built in decoder first\n\n    return decodeURIComponent(encodedURI);\n  } catch (err) {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/decode-uri-component/index.js"],"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","err","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","module","exports","encodedURI","TypeError"],"mappings":"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","sourcesContent":["'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}