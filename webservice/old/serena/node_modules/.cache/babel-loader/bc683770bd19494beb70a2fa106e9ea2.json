{"ast":null,"code":"const util = require('util');\n\nconst assert = require('assert');\n\nconst stdhttp = require('http');\n\nconst crypto = require('crypto');\n\nconst querystring = require('querystring');\n\nconst url = require('url');\n\nconst jose = require('node-jose');\n\nconst base64url = require('base64url');\n\nconst _ = require('lodash');\n\nconst tokenHash = require('oidc-token-hash');\n\nconst errorHandlerFactory = require('./helpers/error_handler');\n\nconst expectResponseWithBody = require('./helpers/expect_response');\n\nconst TokenSet = require('./token_set');\n\nconst OpenIdConnectError = require('./open_id_connect_error');\n\nconst now = require('./util/unix_timestamp');\n\nconst {\n  CALLBACK_PROPERTIES,\n  CLIENT_DEFAULTS,\n  JWT_CONTENT\n} = require('./helpers/consts');\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst forEach = require('./util/for_each');\n\nconst random = require('./util/random');\n\nconst errorHandler = errorHandlerFactory();\nconst bearerErrorHandler = errorHandlerFactory({\n  bearerEndpoint: true\n});\nconst map = new WeakMap();\nconst format = 'compact';\n\nfunction formUrlEncode(value) {\n  return encodeURIComponent(value).replace(/%20/g, '+');\n}\n\nfunction bearer(token) {\n  return `Bearer ${token}`;\n}\n\nfunction instance(ctx) {\n  if (!map.has(ctx)) map.set(ctx, {\n    metadata: {}\n  });\n  return map.get(ctx);\n}\n\nfunction cleanUpClaims(claims) {\n  if (_.isEmpty(claims._claim_names)) delete claims._claim_names;\n  if (_.isEmpty(claims._claim_sources)) delete claims._claim_sources;\n  return claims;\n}\n\nfunction assignClaim(target, source, sourceName) {\n  return (inSource, claim) => {\n    if (inSource === sourceName) {\n      assert(source[claim] !== undefined, `expected claim \"${claim}\" in \"${sourceName}\"`);\n      target[claim] = source[claim];\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction getFromJWT(jwt, position, claim) {\n  assert.equal(typeof jwt, 'string', 'invalid JWT type, expected a string');\n  const parts = jwt.split('.');\n  assert.equal(parts.length, 3, 'invalid JWT format, expected three parts');\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction assignErrSrc(sourceName) {\n  return err => {\n    err.src = sourceName;\n    throw err;\n  };\n}\n\nfunction authorizationParams(params) {\n  assert(_.isPlainObject(params), 'pass a plain object as the first argument');\n  const authParams = Object.assign({\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: 'code'\n  }, params); // TODO: default redirect_uris if there's one\n\n  forEach(authParams, (value, key) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n  assert(['none', 'code'].includes(authParams.response_type) || authParams.nonce, 'nonce MUST be provided for implicit and hybrid flows');\n  return authParams;\n}\n\nfunction claimJWT(jwt) {\n  try {\n    const iss = getIss(jwt);\n    const keyDef = getHeader(jwt);\n    assert(keyDef.alg, 'claim source is missing JWT header alg property');\n    if (keyDef.alg === 'none') return Promise.resolve(getPayload(jwt));\n\n    const getKey = (() => {\n      if (!iss || iss === this.issuer.issuer) {\n        return this.issuer.key(keyDef);\n      }\n\n      if (issuerRegistry.has(iss)) {\n        return issuerRegistry.get(iss).key(keyDef);\n      }\n\n      return this.issuer.constructor.discover(iss).then(issuer => issuer.key(keyDef));\n    })();\n\n    return getKey.then(key => jose.JWS.createVerify(key).verify(jwt)).then(result => JSON.parse(result.payload));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nfunction checkStore(keystore) {\n  assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n  assert(keystore.all().every(key => {\n    if (key.kty === 'RSA' || key.kty === 'EC') {\n      try {\n        key.toPEM(true);\n      } catch (err) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }), 'keystore must only contain private EC or RSA keys');\n} // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\n\n\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nfunction assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n\n  if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa]) {\n    assert(issuer[easavs], `${easavs} must be configured on the issuer if ${easa} is not defined on a client`);\n  }\n}\n\nfunction assertIssuerConfiguration(issuer, endpoint) {\n  assert(issuer[endpoint], `${endpoint} must be configured on the issuer`);\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, keystore) {\n    super();\n    const properties = Object.assign({}, CLIENT_DEFAULTS, metadata);\n\n    if (!metadata.token_endpoint_auth_method) {\n      // if no explicit value was provided\n      checkBasicSupport(this, metadata, properties);\n    }\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n    forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).metadata[key];\n          }\n\n        });\n      }\n    });\n\n    if (keystore !== undefined) {\n      checkStore.call(this, keystore);\n      instance(this).keystore = keystore;\n    }\n\n    this.CLOCK_TOLERANCE = 0;\n  }\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n\n\n  authorizationUrl(params) {\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    Object.assign(target.query, authorizationParams.call(this, params));\n    return url.format(target);\n  }\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n\n\n  authorizationPost(params) {\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n\n\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n    const {\n      0: postLogout,\n      length\n    } = this.post_logout_redirect_uris || [];\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined\n    } = params;\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      assert(hint.id_token, 'id_token not present in TokenSet');\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = Object.assign(params, target.query, {\n      post_logout_redirect_uri,\n      id_token_hint: hint\n    });\n    forEach(target.query, (value, key) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n  /**\n   * @name callbackParams\n   * @api public\n   */\n\n\n  callbackParams(input) {\n    // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n    assert(isString || isIncomingMessage, '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    let uri;\n\n    if (isIncomingMessage) {\n      const msg = input;\n\n      switch (msg.method) {\n        case 'GET':\n          uri = msg.url;\n          break;\n\n        case 'POST':\n          assert(msg.body, 'incoming message body missing, include a body parser prior to this call');\n\n          switch (typeof msg.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(msg.body)) {\n                return querystring.parse(msg.body.toString('utf-8'));\n              }\n\n              if (typeof msg.body === 'string') {\n                return querystring.parse(msg.body);\n              }\n\n              return msg.body;\n\n            default:\n              throw new Error('invalid IncomingMessage body object');\n          }\n\n        default:\n          throw new Error('invalid IncomingMessage method');\n      }\n    } else {\n      uri = input;\n    }\n\n    return _.pick(url.parse(uri, true).query, CALLBACK_PROPERTIES);\n  }\n  /**\n   * @name authorizationCallback\n   * @api public\n   */\n\n\n  authorizationCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (this.default_max_age && !checks.max_age) checks.max_age = this.default_max_age;\n\n    if (!params.state && checks.state) {\n      return Promise.reject(new Error('state missing from the response'));\n    }\n\n    if (params.state && !checks.state) {\n      return Promise.reject(new Error('checks.state argument is missing'));\n    }\n\n    if (checks.state !== params.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            return Promise.reject(new Error('unexpected params encountered for \"none\" response'));\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              return Promise.reject(new Error(`${param} missing from response`));\n            }\n          }\n        }\n      }\n    }\n\n    let promise;\n\n    if (params.id_token) {\n      promise = Promise.resolve(new TokenSet(params)).then(tokenset => this.decryptIdToken(tokenset)).then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state));\n    }\n\n    if (params.code) {\n      const grantCall = () => this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }).then(tokenset => this.decryptIdToken(tokenset)).then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age)).then(tokenset => {\n        if (params.session_state) tokenset.session_state = params.session_state;\n        return tokenset;\n      });\n\n      if (promise) {\n        promise = promise.then(grantCall);\n      } else {\n        return grantCall();\n      }\n    }\n\n    return promise || Promise.resolve(new TokenSet(params));\n  }\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n\n\n  oauthCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (!params.state && checks.state) {\n      return Promise.reject(new Error('state missing from the response'));\n    }\n\n    if (params.state && !checks.state) {\n      return Promise.reject(new Error('checks.state argument is missing'));\n    }\n\n    if (checks.state !== params.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            return Promise.reject(new Error('unexpected params encountered for \"none\" response'));\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              return Promise.reject(new Error(`${param} missing from response`));\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      });\n    }\n\n    return Promise.resolve(new TokenSet(params));\n  }\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n\n\n  decryptIdToken(token, use) {\n    if (!use) use = 'id_token'; // eslint-disable-line no-param-reassign\n\n    if (!this[`${use}_encrypted_response_alg`]) {\n      return Promise.resolve(token);\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this[`${use}_encrypted_response_alg`];\n    const expectedEnc = this[`${use}_encrypted_response_enc`];\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n    assert.equal(header.alg, expectedAlg, 'unexpected alg received');\n    assert.equal(header.enc, expectedEnc, 'unexpected enc received');\n    const keystoreOrSecret = expectedAlg.match(/^(RSA|ECDH)/) ? Promise.resolve(instance(this).keystore) : this.joseSecret(expectedAlg);\n    return keystoreOrSecret.then(keyOrStore => jose.JWE.createDecrypt(keyOrStore).decrypt(idToken).then(result => {\n      if (token instanceof TokenSet) {\n        Object.defineProperty(token, 'encrypted_id_token', {\n          value: token.id_token\n        }); // TODO: deprecated\n\n        token.id_token = result.payload.toString('utf8');\n        return token;\n      }\n\n      return result.payload.toString('utf8');\n    }));\n  }\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n\n\n  validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = (() => {\n      if (returnedBy === 'userinfo') return this.userinfo_signed_response_alg;\n      return this.id_token_signed_response_alg;\n    })();\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    const verifyPresence = prop => {\n      if (payload[prop] === undefined) {\n        throw new Error(`missing required JWT property ${prop}`);\n      }\n    };\n\n    assert.equal(header.alg, expectedAlg, 'unexpected algorithm received');\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence);\n    }\n\n    if (payload.iss !== undefined) {\n      if (aadIssValidation) {\n        const azureADv2Issuer = this.issuer.issuer.replace('{tenantid}', payload.tid);\n        assert.equal(payload.iss, azureADv2Issuer, 'unexpected iss value');\n      } else {\n        assert.equal(payload.iss, this.issuer.issuer, 'unexpected iss value');\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      assert.equal(typeof payload.iat, 'number', 'iat is not a number');\n      assert(payload.iat <= timestamp + this.CLOCK_TOLERANCE, 'id_token issued in the future');\n    }\n\n    if (payload.nbf !== undefined) {\n      assert.equal(typeof payload.nbf, 'number', 'nbf is not a number');\n      assert(payload.nbf <= timestamp + this.CLOCK_TOLERANCE, 'id_token not active yet');\n    }\n\n    if (maxAge || maxAge !== null && this.require_auth_time) {\n      assert(payload.auth_time, 'missing required JWT property auth_time');\n      assert.equal(typeof payload.auth_time, 'number', 'auth_time is not a number');\n    }\n\n    if (maxAge) {\n      assert(payload.auth_time + maxAge >= timestamp - this.CLOCK_TOLERANCE, 'too much time has elapsed since the last End-User authentication');\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined)) {\n      assert.equal(payload.nonce, nonce, 'nonce mismatch');\n    }\n\n    if (payload.exp !== undefined) {\n      assert.equal(typeof payload.exp, 'number', 'exp is not a number');\n      assert(timestamp - this.CLOCK_TOLERANCE < payload.exp, 'id_token expired');\n    }\n\n    if (payload.aud !== undefined) {\n      if (!Array.isArray(payload.aud)) {\n        payload.aud = [payload.aud];\n      } else if (payload.aud.length > 1 && !payload.azp) {\n        throw new Error('missing required JWT property azp');\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      assert.equal(payload.azp, this.client_id, 'azp must be the client_id');\n    }\n\n    if (payload.aud !== undefined) {\n      assert(payload.aud.includes(this.client_id), 'aud is missing the client_id');\n    }\n\n    if (returnedBy === 'authorization') {\n      assert(payload.at_hash || !tokenSet.access_token, 'missing required property at_hash');\n      assert(payload.c_hash || !tokenSet.code, 'missing required property c_hash');\n\n      if (payload.s_hash) {\n        assert(state, 'cannot verify s_hash, state not provided');\n        assert(tokenHash(payload.s_hash, state, header.alg), 's_hash mismatch');\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      assert(tokenHash(payload.at_hash, tokenSet.access_token, header.alg), 'at_hash mismatch');\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      assert(tokenHash(payload.c_hash, tokenSet.code, header.alg), 'c_hash mismatch');\n    }\n\n    if (header.alg === 'none') {\n      return Promise.resolve(tokenSet);\n    }\n\n    return (header.alg.startsWith('HS') ? this.joseSecret() : this.issuer.key(header)).then(key => jose.JWS.createVerify(key).verify(idToken).catch(() => {\n      throw new Error('invalid signature');\n    })).then(() => tokenSet);\n  }\n  /**\n   * @name refresh\n   * @api public\n   */\n\n\n  refresh(refreshToken) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        return Promise.reject(new Error('refresh_token not present in TokenSet'));\n      }\n\n      token = token.refresh_token;\n    }\n\n    return this.grant({\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }).then(tokenset => {\n      if (!tokenset.id_token) {\n        return tokenset;\n      }\n\n      return this.decryptIdToken(tokenset).then(() => this.validateIdToken(tokenset, null, 'token', null));\n    });\n  }\n  /**\n   * @name userinfo\n   * @api public\n   */\n\n\n  userinfo(accessToken, options) {\n    let token = accessToken;\n\n    const opts = _.merge({\n      verb: 'get',\n      via: 'header'\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        return Promise.reject(new Error('access_token not present in TokenSet'));\n      }\n\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toLowerCase();\n    let httpOptions;\n\n    switch (opts.via) {\n      case 'query':\n        assert.equal(verb, 'get', 'providers should only parse query strings for GET requests');\n        httpOptions = {\n          query: {\n            access_token: token\n          }\n        };\n        break;\n\n      case 'body':\n        assert.equal(verb, 'post', 'can only send body on POST');\n        httpOptions = {\n          form: true,\n          body: {\n            access_token: token\n          }\n        };\n        break;\n\n      default:\n        httpOptions = {\n          headers: {\n            Authorization: bearer(token)\n          }\n        };\n    }\n\n    if (opts.params) {\n      if (verb === 'post') {\n        _.defaultsDeep(httpOptions, {\n          body: opts.params\n        });\n      } else {\n        _.defaultsDeep(httpOptions, {\n          query: opts.params\n        });\n      }\n    }\n\n    return this.httpClient[verb](this.issuer.userinfo_endpoint, this.issuer.httpOptions(httpOptions)).then(expectResponseWithBody(200)).then(response => {\n      if (JWT_CONTENT.exec(response.headers['content-type'])) {\n        return Promise.resolve(response.body).then(jwt => this.decryptIdToken(jwt, 'userinfo')).then(jwt => {\n          if (!this.userinfo_signed_response_alg) return JSON.parse(jwt);\n          return this.validateIdToken(jwt, null, 'userinfo', null).then(valid => JSON.parse(base64url.decode(valid.split('.')[1])));\n        });\n      }\n\n      return JSON.parse(response.body);\n    }).then(parsed => {\n      if (accessToken.id_token) {\n        assert.equal(parsed.sub, getSub(accessToken.id_token), 'userinfo sub mismatch');\n      }\n\n      return parsed;\n    }).catch(bearerErrorHandler.bind(this));\n  }\n  /**\n   * @name derivedKey\n   * @api private\n   */\n\n\n  derivedKey(len) {\n    const cacheKey = `${len}_key`;\n\n    if (instance(this)[cacheKey]) {\n      return Promise.resolve(instance(this)[cacheKey]);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256').update(this.client_secret).digest().slice(0, len / 8);\n    return jose.JWK.asKey({\n      k: base64url.encode(derivedBuffer),\n      kty: 'oct'\n    }).then(key => {\n      instance(this)[cacheKey] = key;\n      return key;\n    });\n  }\n  /**\n   * @name joseSecret\n   * @api private\n   */\n\n\n  joseSecret(alg) {\n    if (String(alg).match(/^(?:A|PBES2.+)(\\d{3})(GCM)?KW$/)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (instance(this).jose_secret) {\n      return Promise.resolve(instance(this).jose_secret);\n    }\n\n    return jose.JWK.asKey({\n      k: base64url.encode(this.client_secret),\n      kty: 'oct'\n    }).then(key => {\n      instance(this).jose_secret = key;\n      return key;\n    });\n  }\n  /**\n   * @name grant\n   * @api public\n   */\n\n\n  grant(body) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    return this.authenticatedPost('token', {\n      body: _.omitBy(body, _.isUndefined)\n    }).then(expectResponseWithBody(200)).then(response => new TokenSet(JSON.parse(response.body)));\n  }\n  /**\n   * @name revoke\n   * @api public\n   */\n\n\n  revoke(token, hint) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n    const body = {\n      token\n    };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('revocation', {\n      body\n    }).then(response => {\n      if (response.body) {\n        return JSON.parse(response.body);\n      }\n\n      return {};\n    });\n  }\n  /**\n   * @name introspect\n   * @api public\n   */\n\n\n  introspect(token, hint) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n    const body = {\n      token\n    };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('introspection', {\n      body\n    }).then(expectResponseWithBody(200)).then(response => JSON.parse(response.body));\n  }\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n\n\n  fetchDistributedClaims(claims, tokens = {}) {\n    const distributedSources = _.pickBy(claims._claim_sources, def => !!def.endpoint);\n\n    return Promise.all(_.map(distributedSources, (def, sourceName) => {\n      const opts = {\n        headers: {\n          Authorization: bearer(def.access_token || tokens[sourceName])\n        }\n      };\n      return this.httpClient.get(def.endpoint, this.issuer.httpOptions(opts)).then(response => claimJWT.call(this, response.body), bearerErrorHandler.bind(this)).then(data => {\n        delete claims._claim_sources[sourceName];\n        forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n\n\n  unpackAggregatedClaims(claims) {\n    const aggregatedSources = _.pickBy(claims._claim_sources, def => !!def.JWT);\n\n    return Promise.all(_.map(aggregatedSources, (def, sourceName) => {\n      const decoded = claimJWT.call(this, def.JWT);\n      return decoded.then(data => {\n        delete claims._claim_sources[sourceName];\n        forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n  /**\n   * @name authenticatedPost\n   * @api private\n   */\n\n\n  authenticatedPost(endpoint, httpOptions) {\n    return Promise.resolve(this.authFor(endpoint)).then(auth => {\n      const opts = this.issuer.httpOptions(_.merge(httpOptions, auth, {\n        form: true\n      }));\n      return this.httpClient.post(this.issuer[`${endpoint}_endpoint`], opts);\n    }).catch(errorHandler.bind(this));\n  }\n  /**\n   * @name createSign\n   * @api private\n   */\n\n\n  createSign(endpoint = 'token') {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n\n    switch (this[`${endpoint}_endpoint_auth_method`]) {\n      case 'client_secret_jwt':\n        return this.joseSecret().then(key => {\n          if (!alg) {\n            alg = _.find(this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`], signAlg => key.algorithms('sign').includes(signAlg));\n          }\n\n          return jose.JWS.createSign({\n            fields: {\n              alg,\n              typ: 'JWT'\n            },\n            format\n          }, {\n            key,\n            reference: false\n          });\n        });\n\n      case 'private_key_jwt':\n        {\n          if (!alg) {\n            const algs = new Set();\n            instance(this).keystore.all().forEach(key => {\n              key.algorithms('sign').forEach(algs.add.bind(algs));\n            });\n            alg = _.find(this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`], signAlg => algs.has(signAlg));\n          }\n\n          const key = instance(this).keystore.get({\n            alg,\n            use: 'sig'\n          });\n          assert(key, 'no valid key found');\n          return Promise.resolve(jose.JWS.createSign({\n            fields: {\n              alg,\n              typ: 'JWT'\n            },\n            format\n          }, {\n            key,\n            reference: true\n          }));\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error('createSign only works for _jwt token auth methods');\n    }\n  }\n  /**\n   * @name authFor\n   * @api private\n   */\n\n\n  authFor(endpoint = 'token') {\n    const authMethod = this[`${endpoint}_endpoint_auth_method`];\n\n    switch (authMethod) {\n      case 'none':\n        return {\n          body: {\n            client_id: this.client_id\n          }\n        };\n\n      case 'client_secret_post':\n        return {\n          body: {\n            client_id: this.client_id,\n            client_secret: this.client_secret\n          }\n        };\n\n      case 'private_key_jwt':\n      case 'client_secret_jwt':\n        {\n          const timestamp = now();\n          return this.createSign(endpoint).then(sign => sign.update(JSON.stringify({\n            iat: timestamp,\n            exp: timestamp + 60,\n            jti: random(),\n            iss: this.client_id,\n            sub: this.client_id,\n            aud: this.issuer[`${endpoint}_endpoint`]\n          })).final().then(client_assertion => {\n            // eslint-disable-line camelcase, arrow-body-style\n            return {\n              body: {\n                client_assertion,\n                client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n              }\n            };\n          }));\n        }\n\n      default:\n        {\n          const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n          const value = Buffer.from(encoded).toString('base64');\n          return {\n            headers: {\n              Authorization: `Basic ${value}`\n            }\n          };\n        }\n    }\n  }\n  /**\n   * @name inspect\n   * @api public\n   */\n\n\n  inspect() {\n    return util.format('Client <%s>', this.client_id);\n  }\n  /**\n   * @name register\n   * @api public\n   */\n\n\n  static register(properties, {\n    initialAccessToken,\n    keystore\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (keystore !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      checkStore.call(this, keystore);\n      properties.jwks = keystore.toJSON();\n    }\n\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    if (initialAccessToken) headers.Authorization = bearer(initialAccessToken);\n    return this.httpClient.post(this.issuer.registration_endpoint, this.issuer.httpOptions({\n      headers,\n      body: JSON.stringify(properties)\n    })).then(expectResponseWithBody(201)).then(response => new this(JSON.parse(response.body), keystore)).catch(bearerErrorHandler.bind(this));\n  }\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n  /**\n   * @name fromUri\n   * @api public\n   */\n\n\n  static fromUri(uri, token, keystore) {\n    return this.httpClient.get(uri, this.issuer.httpOptions({\n      headers: {\n        Authorization: bearer(token)\n      }\n    })).then(expectResponseWithBody(200)).then(response => new this(JSON.parse(response.body), keystore), bearerErrorHandler.bind(this));\n  }\n  /**\n   * @name requestObject\n   * @api public\n   */\n\n\n  requestObject(request = {}, algorithms = {}) {\n    assert(_.isPlainObject(request), 'pass a plain object as the first argument');\n\n    _.defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc\n      }\n    }, {\n      sign: 'none'\n    });\n\n    const signed = (() => {\n      const alg = algorithms.sign;\n      const header = {\n        alg,\n        typ: 'JWT'\n      };\n      const payload = JSON.stringify(_.defaults({}, request, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id\n      }));\n\n      if (alg === 'none') {\n        return Promise.resolve([base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.'));\n      }\n\n      const symmetrical = alg.startsWith('HS');\n\n      const getKey = (() => {\n        if (symmetrical) return this.joseSecret();\n        const {\n          keystore\n        } = instance(this);\n        assert(keystore, `no keystore present for client, cannot sign using ${alg}`);\n        const key = keystore.get({\n          alg,\n          use: 'sig'\n        });\n        assert(key, `no key to sign with found for ${alg}`);\n        return Promise.resolve(key);\n      })();\n\n      return getKey.then(key => jose.JWS.createSign({\n        fields: header,\n        format\n      }, {\n        key,\n        reference: !symmetrical\n      })).then(sign => sign.update(payload).final());\n    })();\n\n    if (!algorithms.encrypt.alg) return signed;\n    const fields = {\n      alg: algorithms.encrypt.alg,\n      enc: algorithms.encrypt.enc,\n      cty: 'JWT'\n    };\n    let keystoreOrSecret;\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      keystoreOrSecret = this.issuer.key({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc'\n      }, true);\n    } else {\n      keystoreOrSecret = this.joseSecret(fields.alg);\n    }\n    /* eslint-disable arrow-body-style */\n\n\n    return keystoreOrSecret.then(key => {\n      return signed.then(cleartext => {\n        return jose.JWE.createEncrypt({\n          format,\n          fields\n        }, {\n          key,\n          reference: key.kty !== 'oct'\n        }).update(cleartext).final();\n      });\n    });\n    /* eslint-enable arrow-body-style */\n  }\n\n  get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n  static get httpClient() {\n    return this.issuer.httpClient;\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  static get issuer() {\n    return issuer;\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  get issuer() {\n    // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n\n};\n\nmodule.exports.BaseClient = BaseClient;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/openid-client/lib/client.js"],"names":["util","require","assert","stdhttp","crypto","querystring","url","jose","base64url","_","tokenHash","errorHandlerFactory","expectResponseWithBody","TokenSet","OpenIdConnectError","now","CALLBACK_PROPERTIES","CLIENT_DEFAULTS","JWT_CONTENT","issuerRegistry","forEach","random","errorHandler","bearerErrorHandler","bearerEndpoint","map","WeakMap","format","formUrlEncode","value","encodeURIComponent","replace","bearer","token","instance","ctx","has","set","metadata","get","cleanUpClaims","claims","isEmpty","_claim_names","_claim_sources","assignClaim","target","source","sourceName","inSource","claim","undefined","getFromJWT","jwt","position","equal","parts","split","length","parsed","JSON","parse","decode","getSub","getIss","getHeader","getPayload","assignErrSrc","err","src","authorizationParams","params","isPlainObject","authParams","Object","assign","client_id","scope","response_type","key","stringify","String","includes","nonce","claimJWT","iss","keyDef","alg","Promise","resolve","getKey","issuer","constructor","discover","then","JWS","createVerify","verify","result","payload","error","reject","checkStore","keystore","JWK","isKeyStore","all","every","kty","toPEM","checkBasicSupport","client","properties","supported","token_endpoint_auth_methods_supported","token_endpoint_auth_method","getDefaultsForEndpoint","endpoint","tokenEndpointAuthMethod","tokenEndpointAuthSigningAlg","token_endpoint_auth_signing_alg","eam","easa","assertSigningAlgValuesSupport","easavs","endsWith","assertIssuerConfiguration","BaseClient","module","exports","aadIssValidation","Client","defineProperty","call","CLOCK_TOLERANCE","authorizationUrl","authorization_endpoint","search","query","authorizationPost","inputs","formInputs","keys","name","join","endSessionUrl","postLogout","post_logout_redirect_uris","post_logout_redirect_uri","hint","id_token_hint","id_token","end_session_endpoint","callbackParams","input","isIncomingMessage","IncomingMessage","method","isString","uri","msg","body","Buffer","isBuffer","toString","Error","pick","authorizationCallback","redirectUri","parameters","checks","default_max_age","max_age","state","RESPONSE_TYPE_REQUIRED_PARAMS","code","type","access_token","param","promise","tokenset","decryptIdToken","validateIdToken","grantCall","grant","grant_type","redirect_uri","code_verifier","session_state","oauthCallback","use","idToken","expectedAlg","expectedEnc","header","enc","keystoreOrSecret","match","joseSecret","keyOrStore","JWE","createDecrypt","decrypt","tokenSet","returnedBy","maxAge","userinfo_signed_response_alg","id_token_signed_response_alg","isTokenSet","timestamp","verifyPresence","prop","azureADv2Issuer","tid","iat","nbf","require_auth_time","auth_time","exp","aud","Array","isArray","azp","at_hash","c_hash","s_hash","startsWith","catch","refresh","refreshToken","refresh_token","userinfo","accessToken","options","opts","merge","verb","via","toLowerCase","httpOptions","form","headers","Authorization","defaultsDeep","httpClient","userinfo_endpoint","response","exec","valid","sub","bind","derivedKey","len","cacheKey","derivedBuffer","createHash","update","client_secret","digest","slice","asKey","k","encode","parseInt","RegExp","$1","jose_secret","authenticatedPost","omitBy","isUndefined","revoke","token_type_hint","introspect","fetchDistributedClaims","tokens","distributedSources","pickBy","def","data","unpackAggregatedClaims","aggregatedSources","JWT","decoded","authFor","auth","post","createSign","find","signAlg","algorithms","fields","typ","reference","algs","Set","add","authMethod","sign","jti","final","client_assertion","client_assertion_type","encoded","from","inspect","register","initialAccessToken","jwks","jwks_uri","toJSON","registration_endpoint","fromUri","requestObject","request","defaults","request_object_signing_alg","encrypt","request_object_encryption_alg","request_object_encryption_enc","signed","symmetrical","cty","cleartext","createEncrypt"],"mappings":"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","sourcesContent":["const util = require('util');\nconst assert = require('assert');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\nconst url = require('url');\n\nconst jose = require('node-jose');\nconst base64url = require('base64url');\nconst _ = require('lodash');\nconst tokenHash = require('oidc-token-hash');\n\nconst errorHandlerFactory = require('./helpers/error_handler');\nconst expectResponseWithBody = require('./helpers/expect_response');\nconst TokenSet = require('./token_set');\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst now = require('./util/unix_timestamp');\nconst { CALLBACK_PROPERTIES, CLIENT_DEFAULTS, JWT_CONTENT } = require('./helpers/consts');\nconst issuerRegistry = require('./issuer_registry');\nconst forEach = require('./util/for_each');\nconst random = require('./util/random');\n\nconst errorHandler = errorHandlerFactory();\nconst bearerErrorHandler = errorHandlerFactory({ bearerEndpoint: true });\n\nconst map = new WeakMap();\nconst format = 'compact';\n\nfunction formUrlEncode(value) {\n  return encodeURIComponent(value).replace(/%20/g, '+');\n}\n\nfunction bearer(token) {\n  return `Bearer ${token}`;\n}\n\nfunction instance(ctx) {\n  if (!map.has(ctx)) map.set(ctx, { metadata: {} });\n  return map.get(ctx);\n}\n\nfunction cleanUpClaims(claims) {\n  if (_.isEmpty(claims._claim_names)) delete claims._claim_names;\n  if (_.isEmpty(claims._claim_sources)) delete claims._claim_sources;\n  return claims;\n}\n\nfunction assignClaim(target, source, sourceName) {\n  return (inSource, claim) => {\n    if (inSource === sourceName) {\n      assert(source[claim] !== undefined, `expected claim \"${claim}\" in \"${sourceName}\"`);\n      target[claim] = source[claim];\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction getFromJWT(jwt, position, claim) {\n  assert.equal(typeof jwt, 'string', 'invalid JWT type, expected a string');\n  const parts = jwt.split('.');\n  assert.equal(parts.length, 3, 'invalid JWT format, expected three parts');\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction assignErrSrc(sourceName) {\n  return (err) => {\n    err.src = sourceName;\n    throw err;\n  };\n}\n\nfunction authorizationParams(params) {\n  assert(_.isPlainObject(params), 'pass a plain object as the first argument');\n\n  const authParams = Object.assign(\n    { client_id: this.client_id, scope: 'openid', response_type: 'code' },\n    params\n  );\n\n  // TODO: default redirect_uris if there's one\n\n  forEach(authParams, (value, key) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  assert(\n    ['none', 'code'].includes(authParams.response_type) || authParams.nonce,\n    'nonce MUST be provided for implicit and hybrid flows'\n  );\n\n  return authParams;\n}\n\nfunction claimJWT(jwt) {\n  try {\n    const iss = getIss(jwt);\n    const keyDef = getHeader(jwt);\n    assert(keyDef.alg, 'claim source is missing JWT header alg property');\n\n    if (keyDef.alg === 'none') return Promise.resolve(getPayload(jwt));\n\n    const getKey = (() => {\n      if (!iss || iss === this.issuer.issuer) {\n        return this.issuer.key(keyDef);\n      }\n      if (issuerRegistry.has(iss)) {\n        return issuerRegistry.get(iss).key(keyDef);\n      }\n      return this.issuer.constructor.discover(iss).then(issuer => issuer.key(keyDef));\n    })();\n\n    return getKey\n      .then(key => jose.JWS.createVerify(key).verify(jwt))\n      .then(result => JSON.parse(result.payload));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nfunction checkStore(keystore) {\n  assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n  assert(keystore.all().every((key) => {\n    if (key.kty === 'RSA' || key.kty === 'EC') {\n      try { key.toPEM(true); } catch (err) { return false; }\n      return true;\n    }\n    return false;\n  }), 'keystore must only contain private EC or RSA keys');\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nfunction assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n\n  if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa]) {\n    assert(issuer[easavs], `${easavs} must be configured on the issuer if ${easa} is not defined on a client`);\n  }\n}\n\nfunction assertIssuerConfiguration(issuer, endpoint) {\n  assert(issuer[endpoint], `${endpoint} must be configured on the issuer`);\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, keystore) {\n    super();\n    const properties = Object.assign({}, CLIENT_DEFAULTS, metadata);\n\n    if (!metadata.token_endpoint_auth_method) { // if no explicit value was provided\n      checkBasicSupport(this, metadata, properties);\n    }\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n\n    forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).metadata[key]; },\n        });\n      }\n    });\n\n    if (keystore !== undefined) {\n      checkStore.call(this, keystore);\n      instance(this).keystore = keystore;\n    }\n\n    this.CLOCK_TOLERANCE = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params) {\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    Object.assign(target.query, authorizationParams.call(this, params));\n    return url.format(target);\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params) {\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const {\n      0: postLogout,\n      length,\n    } = this.post_logout_redirect_uris || [];\n\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined,\n    } = params;\n\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      assert(hint.id_token, 'id_token not present in TokenSet');\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = Object.assign(params, target.query, {\n      post_logout_redirect_uri,\n      id_token_hint: hint,\n    });\n    forEach(target.query, (value, key) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) { // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage\n      || (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    assert(\n      isString || isIncomingMessage,\n      '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike'\n    );\n\n    let uri;\n    if (isIncomingMessage) {\n      const msg = input;\n\n      switch (msg.method) {\n        case 'GET':\n          uri = msg.url;\n          break;\n        case 'POST':\n          assert(msg.body, 'incoming message body missing, include a body parser prior to this call');\n          switch (typeof msg.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(msg.body)) {\n                return querystring.parse(msg.body.toString('utf-8'));\n              }\n              if (typeof msg.body === 'string') {\n                return querystring.parse(msg.body);\n              }\n\n              return msg.body;\n            default:\n              throw new Error('invalid IncomingMessage body object');\n          }\n        default:\n          throw new Error('invalid IncomingMessage method');\n      }\n    } else {\n      uri = input;\n    }\n\n    return _.pick(url.parse(uri, true).query, CALLBACK_PROPERTIES);\n  }\n\n  /**\n   * @name authorizationCallback\n   * @api public\n   */\n  authorizationCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (this.default_max_age && !checks.max_age) checks.max_age = this.default_max_age;\n\n    if (!params.state && checks.state) {\n      return Promise.reject(new Error('state missing from the response'));\n    }\n\n    if (params.state && !checks.state) {\n      return Promise.reject(new Error('checks.state argument is missing'));\n    }\n\n    if (checks.state !== params.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            return Promise.reject(new Error('unexpected params encountered for \"none\" response'));\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              return Promise.reject(new Error(`${param} missing from response`));\n            }\n          }\n        }\n      }\n    }\n\n    let promise;\n\n    if (params.id_token) {\n      promise = Promise.resolve(new TokenSet(params))\n        .then(tokenset => this.decryptIdToken(tokenset))\n        .then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state));\n    }\n\n    if (params.code) {\n      const grantCall = () => this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      })\n        .then(tokenset => this.decryptIdToken(tokenset))\n        .then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age))\n        .then((tokenset) => {\n          if (params.session_state) tokenset.session_state = params.session_state;\n          return tokenset;\n        });\n\n      if (promise) {\n        promise = promise.then(grantCall);\n      } else {\n        return grantCall();\n      }\n    }\n\n    return promise || Promise.resolve(new TokenSet(params));\n  }\n\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n  oauthCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (!params.state && checks.state) {\n      return Promise.reject(new Error('state missing from the response'));\n    }\n\n    if (params.state && !checks.state) {\n      return Promise.reject(new Error('checks.state argument is missing'));\n    }\n\n    if (checks.state !== params.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            return Promise.reject(new Error('unexpected params encountered for \"none\" response'));\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              return Promise.reject(new Error(`${param} missing from response`));\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      });\n    }\n\n    return Promise.resolve(new TokenSet(params));\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  decryptIdToken(token, use) {\n    if (!use) use = 'id_token'; // eslint-disable-line no-param-reassign\n\n    if (!this[`${use}_encrypted_response_alg`]) {\n      return Promise.resolve(token);\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this[`${use}_encrypted_response_alg`];\n    const expectedEnc = this[`${use}_encrypted_response_enc`];\n\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n\n    assert.equal(header.alg, expectedAlg, 'unexpected alg received');\n    assert.equal(header.enc, expectedEnc, 'unexpected enc received');\n\n    const keystoreOrSecret = expectedAlg.match(/^(RSA|ECDH)/)\n      ? Promise.resolve(instance(this).keystore) : this.joseSecret(expectedAlg);\n\n    return keystoreOrSecret.then(keyOrStore => jose.JWE.createDecrypt(keyOrStore).decrypt(idToken)\n      .then((result) => {\n        if (token instanceof TokenSet) {\n          Object.defineProperty(token, 'encrypted_id_token', { value: token.id_token }); // TODO: deprecated\n          token.id_token = result.payload.toString('utf8');\n          return token;\n        }\n        return result.payload.toString('utf8');\n      }));\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = (() => {\n      if (returnedBy === 'userinfo') return this.userinfo_signed_response_alg;\n      return this.id_token_signed_response_alg;\n    })();\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    const verifyPresence = (prop) => {\n      if (payload[prop] === undefined) {\n        throw new Error(`missing required JWT property ${prop}`);\n      }\n    };\n\n    assert.equal(header.alg, expectedAlg, 'unexpected algorithm received');\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence);\n    }\n\n    if (payload.iss !== undefined) {\n      if (aadIssValidation) {\n        const azureADv2Issuer = this.issuer.issuer.replace('{tenantid}', payload.tid);\n        assert.equal(payload.iss, azureADv2Issuer, 'unexpected iss value');\n      } else {\n        assert.equal(payload.iss, this.issuer.issuer, 'unexpected iss value');\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      assert.equal(typeof payload.iat, 'number', 'iat is not a number');\n      assert(payload.iat <= timestamp + this.CLOCK_TOLERANCE, 'id_token issued in the future');\n    }\n\n    if (payload.nbf !== undefined) {\n      assert.equal(typeof payload.nbf, 'number', 'nbf is not a number');\n      assert(payload.nbf <= timestamp + this.CLOCK_TOLERANCE, 'id_token not active yet');\n    }\n\n    if (maxAge || (maxAge !== null && this.require_auth_time)) {\n      assert(payload.auth_time, 'missing required JWT property auth_time');\n      assert.equal(typeof payload.auth_time, 'number', 'auth_time is not a number');\n    }\n\n    if (maxAge) {\n      assert(payload.auth_time + maxAge >= timestamp - this.CLOCK_TOLERANCE, 'too much time has elapsed since the last End-User authentication');\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined)) {\n      assert.equal(payload.nonce, nonce, 'nonce mismatch');\n    }\n\n    if (payload.exp !== undefined) {\n      assert.equal(typeof payload.exp, 'number', 'exp is not a number');\n      assert(timestamp - this.CLOCK_TOLERANCE < payload.exp, 'id_token expired');\n    }\n\n    if (payload.aud !== undefined) {\n      if (!Array.isArray(payload.aud)) {\n        payload.aud = [payload.aud];\n      } else if (payload.aud.length > 1 && !payload.azp) {\n        throw new Error('missing required JWT property azp');\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      assert.equal(payload.azp, this.client_id, 'azp must be the client_id');\n    }\n\n    if (payload.aud !== undefined) {\n      assert(payload.aud.includes(this.client_id), 'aud is missing the client_id');\n    }\n\n    if (returnedBy === 'authorization') {\n      assert(payload.at_hash || !tokenSet.access_token, 'missing required property at_hash');\n      assert(payload.c_hash || !tokenSet.code, 'missing required property c_hash');\n\n      if (payload.s_hash) {\n        assert(state, 'cannot verify s_hash, state not provided');\n        assert(tokenHash(payload.s_hash, state, header.alg), 's_hash mismatch');\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      assert(tokenHash(payload.at_hash, tokenSet.access_token, header.alg), 'at_hash mismatch');\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      assert(tokenHash(payload.c_hash, tokenSet.code, header.alg), 'c_hash mismatch');\n    }\n\n    if (header.alg === 'none') {\n      return Promise.resolve(tokenSet);\n    }\n\n    return (header.alg.startsWith('HS') ? this.joseSecret() : this.issuer.key(header))\n      .then(key => jose.JWS.createVerify(key).verify(idToken).catch(() => {\n        throw new Error('invalid signature');\n      }))\n      .then(() => tokenSet);\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  refresh(refreshToken) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        return Promise.reject(new Error('refresh_token not present in TokenSet'));\n      }\n      token = token.refresh_token;\n    }\n\n    return this.grant({\n      grant_type: 'refresh_token',\n      refresh_token: String(token),\n    })\n      .then((tokenset) => {\n        if (!tokenset.id_token) {\n          return tokenset;\n        }\n        return this.decryptIdToken(tokenset)\n          .then(() => this.validateIdToken(tokenset, null, 'token', null));\n      });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  userinfo(accessToken, options) {\n    let token = accessToken;\n    const opts = _.merge({\n      verb: 'get',\n      via: 'header',\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        return Promise.reject(new Error('access_token not present in TokenSet'));\n      }\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toLowerCase();\n    let httpOptions;\n\n    switch (opts.via) {\n      case 'query':\n        assert.equal(verb, 'get', 'providers should only parse query strings for GET requests');\n        httpOptions = { query: { access_token: token } };\n        break;\n      case 'body':\n        assert.equal(verb, 'post', 'can only send body on POST');\n        httpOptions = { form: true, body: { access_token: token } };\n        break;\n      default:\n        httpOptions = { headers: { Authorization: bearer(token) } };\n    }\n\n    if (opts.params) {\n      if (verb === 'post') {\n        _.defaultsDeep(httpOptions, { body: opts.params });\n      } else {\n        _.defaultsDeep(httpOptions, { query: opts.params });\n      }\n    }\n\n    return this.httpClient[verb](\n      this.issuer.userinfo_endpoint, this.issuer.httpOptions(httpOptions)\n    )\n      .then(expectResponseWithBody(200))\n      .then((response) => {\n        if (JWT_CONTENT.exec(response.headers['content-type'])) {\n          return Promise.resolve(response.body)\n            .then(jwt => this.decryptIdToken(jwt, 'userinfo'))\n            .then((jwt) => {\n              if (!this.userinfo_signed_response_alg) return JSON.parse(jwt);\n              return this.validateIdToken(jwt, null, 'userinfo', null)\n                .then(valid => JSON.parse(base64url.decode(valid.split('.')[1])));\n            });\n        }\n\n        return JSON.parse(response.body);\n      })\n      .then((parsed) => {\n        if (accessToken.id_token) {\n          assert.equal(parsed.sub, getSub(accessToken.id_token), 'userinfo sub mismatch');\n        }\n\n        return parsed;\n      })\n      .catch(bearerErrorHandler.bind(this));\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this)[cacheKey]) {\n      return Promise.resolve(instance(this)[cacheKey]);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256')\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n\n    return jose.JWK.asKey({ k: base64url.encode(derivedBuffer), kty: 'oct' }).then((key) => {\n      instance(this)[cacheKey] = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  joseSecret(alg) {\n    if (String(alg).match(/^(?:A|PBES2.+)(\\d{3})(GCM)?KW$/)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (instance(this).jose_secret) {\n      return Promise.resolve(instance(this).jose_secret);\n    }\n\n    return jose.JWK.asKey({ k: base64url.encode(this.client_secret), kty: 'oct' }).then((key) => {\n      instance(this).jose_secret = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  grant(body) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    return this.authenticatedPost('token', { body: _.omitBy(body, _.isUndefined) })\n      .then(expectResponseWithBody(200))\n      .then(response => new TokenSet(JSON.parse(response.body)));\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  revoke(token, hint) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('revocation', { body })\n      .then((response) => {\n        if (response.body) {\n          return JSON.parse(response.body);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  introspect(token, hint) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('introspection', { body })\n      .then(expectResponseWithBody(200))\n      .then(response => JSON.parse(response.body));\n  }\n\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  fetchDistributedClaims(claims, tokens = {}) {\n    const distributedSources = _.pickBy(claims._claim_sources, def => !!def.endpoint);\n\n    return Promise.all(_.map(distributedSources, (def, sourceName) => {\n      const opts = {\n        headers: { Authorization: bearer(def.access_token || tokens[sourceName]) },\n      };\n\n      return this.httpClient.get(def.endpoint, this.issuer.httpOptions(opts))\n        .then(response => claimJWT.call(this, response.body), bearerErrorHandler.bind(this))\n        .then((data) => {\n          delete claims._claim_sources[sourceName];\n          forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n        }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  unpackAggregatedClaims(claims) {\n    const aggregatedSources = _.pickBy(claims._claim_sources, def => !!def.JWT);\n\n    return Promise.all(_.map(aggregatedSources, (def, sourceName) => {\n      const decoded = claimJWT.call(this, def.JWT);\n\n      return decoded.then((data) => {\n        delete claims._claim_sources[sourceName];\n        forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n\n  /**\n   * @name authenticatedPost\n   * @api private\n   */\n  authenticatedPost(endpoint, httpOptions) {\n    return Promise.resolve(this.authFor(endpoint))\n      .then((auth) => {\n        const opts = this.issuer.httpOptions(_.merge(httpOptions, auth, { form: true }));\n        return this.httpClient.post(this.issuer[`${endpoint}_endpoint`], opts);\n      })\n      .catch(errorHandler.bind(this));\n  }\n\n  /**\n   * @name createSign\n   * @api private\n   */\n  createSign(endpoint = 'token') {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n    switch (this[`${endpoint}_endpoint_auth_method`]) {\n      case 'client_secret_jwt':\n        return this.joseSecret().then((key) => {\n          if (!alg) {\n            alg = _.find(\n              this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`],\n              signAlg => key.algorithms('sign').includes(signAlg)\n            );\n          }\n\n          return jose.JWS.createSign({\n            fields: { alg, typ: 'JWT' },\n            format,\n          }, { key, reference: false });\n        });\n      case 'private_key_jwt': {\n        if (!alg) {\n          const algs = new Set();\n          instance(this).keystore.all().forEach((key) => {\n            key.algorithms('sign').forEach(algs.add.bind(algs));\n          });\n\n          alg = _.find(\n            this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`],\n            signAlg => algs.has(signAlg)\n          );\n        }\n\n        const key = instance(this).keystore.get({ alg, use: 'sig' });\n        assert(key, 'no valid key found');\n\n        return Promise.resolve(jose.JWS.createSign({\n          fields: { alg, typ: 'JWT' },\n          format,\n        }, { key, reference: true }));\n      }\n      /* istanbul ignore next */\n      default:\n        throw new Error('createSign only works for _jwt token auth methods');\n    }\n  }\n\n  /**\n   * @name authFor\n   * @api private\n   */\n  authFor(endpoint = 'token') {\n    const authMethod = this[`${endpoint}_endpoint_auth_method`];\n    switch (authMethod) {\n      case 'none':\n        return {\n          body: {\n            client_id: this.client_id,\n          },\n        };\n      case 'client_secret_post':\n        return {\n          body: {\n            client_id: this.client_id,\n            client_secret: this.client_secret,\n          },\n        };\n      case 'private_key_jwt':\n      case 'client_secret_jwt': {\n        const timestamp = now();\n        return this.createSign(endpoint).then(sign => sign.update(JSON.stringify({\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: random(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: this.issuer[`${endpoint}_endpoint`],\n        })).final().then((client_assertion) => { // eslint-disable-line camelcase, arrow-body-style\n          return {\n            body: {\n              client_assertion,\n              client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n            },\n          };\n        }));\n      }\n      default: {\n        const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n        const value = Buffer.from(encoded).toString('base64');\n        return { headers: { Authorization: `Basic ${value}` } };\n      }\n    }\n  }\n\n  /**\n   * @name inspect\n   * @api public\n   */\n  inspect() {\n    return util.format('Client <%s>', this.client_id);\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static register(properties, { initialAccessToken, keystore } = {}) {\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (keystore !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      checkStore.call(this, keystore);\n      properties.jwks = keystore.toJSON();\n    }\n\n    const headers = { 'Content-Type': 'application/json' };\n\n    if (initialAccessToken) headers.Authorization = bearer(initialAccessToken);\n\n    return this.httpClient.post(this.issuer.registration_endpoint, this.issuer.httpOptions({\n      headers,\n      body: JSON.stringify(properties),\n    }))\n      .then(expectResponseWithBody(201))\n      .then(response => new this(JSON.parse(response.body), keystore))\n      .catch(bearerErrorHandler.bind(this));\n  }\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static fromUri(uri, token, keystore) {\n    return this.httpClient.get(uri, this.issuer.httpOptions({\n      headers: { Authorization: bearer(token) },\n    }))\n      .then(expectResponseWithBody(200))\n      .then(\n        response => new this(JSON.parse(response.body), keystore), bearerErrorHandler.bind(this)\n      );\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  requestObject(request = {}, algorithms = {}) {\n    assert(_.isPlainObject(request), 'pass a plain object as the first argument');\n\n    _.defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc,\n      },\n    }, {\n      sign: 'none',\n    });\n\n    const signed = (() => {\n      const alg = algorithms.sign;\n      const header = { alg, typ: 'JWT' };\n      const payload = JSON.stringify(_.defaults({}, request, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id,\n      }));\n\n      if (alg === 'none') {\n        return Promise.resolve([\n          base64url.encode(JSON.stringify(header)),\n          base64url.encode(payload),\n          '',\n        ].join('.'));\n      }\n\n      const symmetrical = alg.startsWith('HS');\n\n      const getKey = (() => {\n        if (symmetrical) return this.joseSecret();\n        const { keystore } = instance(this);\n\n        assert(keystore, `no keystore present for client, cannot sign using ${alg}`);\n        const key = keystore.get({ alg, use: 'sig' });\n        assert(key, `no key to sign with found for ${alg}`);\n        return Promise.resolve(key);\n      })();\n\n      return getKey\n        .then(key => jose.JWS.createSign({\n          fields: header,\n          format,\n        }, { key, reference: !symmetrical }))\n        .then(sign => sign.update(payload).final());\n    })();\n\n    if (!algorithms.encrypt.alg) return signed;\n    const fields = { alg: algorithms.encrypt.alg, enc: algorithms.encrypt.enc, cty: 'JWT' };\n\n    let keystoreOrSecret;\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      keystoreOrSecret = this.issuer.key({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc',\n      }, true);\n    } else {\n      keystoreOrSecret = this.joseSecret(fields.alg);\n    }\n\n    /* eslint-disable arrow-body-style */\n    return keystoreOrSecret.then((key) => {\n      return signed.then((cleartext) => {\n        return jose.JWE.createEncrypt({ format, fields }, { key, reference: key.kty !== 'oct' })\n          .update(cleartext)\n          .final();\n      });\n    });\n    /* eslint-enable arrow-body-style */\n  }\n\n  get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n  static get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  static get issuer() {\n    return issuer;\n  }\n\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  get issuer() { // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n};\n\nmodule.exports.BaseClient = BaseClient;\n"]},"metadata":{},"sourceType":"script"}