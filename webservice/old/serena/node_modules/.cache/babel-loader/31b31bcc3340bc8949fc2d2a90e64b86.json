{"ast":null,"code":"// Copyright 2015 Joyent, Inc.\nmodule.exports = {\n  read: read.bind(undefined, false, undefined),\n  readType: read.bind(undefined, false),\n  write: write,\n\n  /* semi-private api, used by sshpk-agent */\n  readPartial: read.bind(undefined, true),\n\n  /* shared with ssh format */\n  readInternal: read,\n  keyTypeToAlg: keyTypeToAlg,\n  algToKeyType: algToKeyType\n};\n\nvar assert = require('assert-plus');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar algs = require('../algs');\n\nvar utils = require('../utils');\n\nvar Key = require('../key');\n\nvar PrivateKey = require('../private-key');\n\nvar SSHBuffer = require('../ssh-buffer');\n\nfunction algToKeyType(alg) {\n  assert.string(alg);\n  if (alg === 'ssh-dss') return 'dsa';else if (alg === 'ssh-rsa') return 'rsa';else if (alg === 'ssh-ed25519') return 'ed25519';else if (alg === 'ssh-curve25519') return 'curve25519';else if (alg.match(/^ecdsa-sha2-/)) return 'ecdsa';else throw new Error('Unknown algorithm ' + alg);\n}\n\nfunction keyTypeToAlg(key) {\n  assert.object(key);\n  if (key.type === 'dsa') return 'ssh-dss';else if (key.type === 'rsa') return 'ssh-rsa';else if (key.type === 'ed25519') return 'ssh-ed25519';else if (key.type === 'curve25519') return 'ssh-curve25519';else if (key.type === 'ecdsa') return 'ecdsa-sha2-' + key.part.curve.data.toString();else throw new Error('Unknown key type ' + key.type);\n}\n\nfunction read(partial, type, buf, options) {\n  if (typeof buf === 'string') buf = Buffer.from(buf);\n  assert.buffer(buf, 'buf');\n  var key = {};\n  var parts = key.parts = [];\n  var sshbuf = new SSHBuffer({\n    buffer: buf\n  });\n  var alg = sshbuf.readString();\n  assert.ok(!sshbuf.atEnd(), 'key must have at least one part');\n  key.type = algToKeyType(alg);\n  var partCount = algs.info[key.type].parts.length;\n  if (type && type === 'private') partCount = algs.privInfo[key.type].parts.length;\n\n  while (!sshbuf.atEnd() && parts.length < partCount) parts.push(sshbuf.readPart());\n\n  while (!partial && !sshbuf.atEnd()) parts.push(sshbuf.readPart());\n\n  assert.ok(parts.length >= 1, 'key must have at least one part');\n  assert.ok(partial || sshbuf.atEnd(), 'leftover bytes at end of key');\n  var Constructor = Key;\n  var algInfo = algs.info[key.type];\n\n  if (type === 'private' || algInfo.parts.length !== parts.length) {\n    algInfo = algs.privInfo[key.type];\n    Constructor = PrivateKey;\n  }\n\n  assert.strictEqual(algInfo.parts.length, parts.length);\n\n  if (key.type === 'ecdsa') {\n    var res = /^ecdsa-sha2-(.+)$/.exec(alg);\n    assert.ok(res !== null);\n    assert.strictEqual(res[1], parts[0].data.toString());\n  }\n\n  var normalized = true;\n\n  for (var i = 0; i < algInfo.parts.length; ++i) {\n    var p = parts[i];\n    p.name = algInfo.parts[i];\n    /*\n     * OpenSSH stores ed25519 \"private\" keys as seed + public key\n     * concat'd together (k followed by A). We want to keep them\n     * separate for other formats that don't do this.\n     */\n\n    if (key.type === 'ed25519' && p.name === 'k') p.data = p.data.slice(0, 32);\n\n    if (p.name !== 'curve' && algInfo.normalize !== false) {\n      var nd;\n\n      if (key.type === 'ed25519') {\n        nd = utils.zeroPadToLength(p.data, 32);\n      } else {\n        nd = utils.mpNormalize(p.data);\n      }\n\n      if (nd.toString('binary') !== p.data.toString('binary')) {\n        p.data = nd;\n        normalized = false;\n      }\n    }\n  }\n\n  if (normalized) key._rfc4253Cache = sshbuf.toBuffer();\n\n  if (partial && typeof partial === 'object') {\n    partial.remainder = sshbuf.remainder();\n    partial.consumed = sshbuf._offset;\n  }\n\n  return new Constructor(key);\n}\n\nfunction write(key, options) {\n  assert.object(key);\n  var alg = keyTypeToAlg(key);\n  var i;\n  var algInfo = algs.info[key.type];\n  if (PrivateKey.isPrivateKey(key)) algInfo = algs.privInfo[key.type];\n  var parts = algInfo.parts;\n  var buf = new SSHBuffer({});\n  buf.writeString(alg);\n\n  for (i = 0; i < parts.length; ++i) {\n    var data = key.part[parts[i]].data;\n\n    if (algInfo.normalize !== false) {\n      if (key.type === 'ed25519') data = utils.zeroPadToLength(data, 32);else data = utils.mpNormalize(data);\n    }\n\n    if (key.type === 'ed25519' && parts[i] === 'k') data = Buffer.concat([data, key.part.A.data]);\n    buf.writeBuffer(data);\n  }\n\n  return buf.toBuffer();\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/sshpk/lib/formats/rfc4253.js"],"names":["module","exports","read","bind","undefined","readType","write","readPartial","readInternal","keyTypeToAlg","algToKeyType","assert","require","Buffer","algs","utils","Key","PrivateKey","SSHBuffer","alg","string","match","Error","key","object","type","part","curve","data","toString","partial","buf","options","from","buffer","parts","sshbuf","readString","ok","atEnd","partCount","info","length","privInfo","push","readPart","Constructor","algInfo","strictEqual","res","exec","normalized","i","p","name","slice","normalize","nd","zeroPadToLength","mpNormalize","_rfc4253Cache","toBuffer","remainder","consumed","_offset","isPrivateKey","writeString","concat","A","writeBuffer"],"mappings":"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","sourcesContent":["// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read.bind(undefined, false, undefined),\n\treadType: read.bind(undefined, false),\n\twrite: write,\n\t/* semi-private api, used by sshpk-agent */\n\treadPartial: read.bind(undefined, true),\n\n\t/* shared with ssh format */\n\treadInternal: read,\n\tkeyTypeToAlg: keyTypeToAlg,\n\talgToKeyType: algToKeyType\n};\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar SSHBuffer = require('../ssh-buffer');\n\nfunction algToKeyType(alg) {\n\tassert.string(alg);\n\tif (alg === 'ssh-dss')\n\t\treturn ('dsa');\n\telse if (alg === 'ssh-rsa')\n\t\treturn ('rsa');\n\telse if (alg === 'ssh-ed25519')\n\t\treturn ('ed25519');\n\telse if (alg === 'ssh-curve25519')\n\t\treturn ('curve25519');\n\telse if (alg.match(/^ecdsa-sha2-/))\n\t\treturn ('ecdsa');\n\telse\n\t\tthrow (new Error('Unknown algorithm ' + alg));\n}\n\nfunction keyTypeToAlg(key) {\n\tassert.object(key);\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss');\n\telse if (key.type === 'rsa')\n\t\treturn ('ssh-rsa');\n\telse if (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519');\n\telse if (key.type === 'curve25519')\n\t\treturn ('ssh-curve25519');\n\telse if (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.part.curve.data.toString());\n\telse\n\t\tthrow (new Error('Unknown key type ' + key.type));\n}\n\nfunction read(partial, type, buf, options) {\n\tif (typeof (buf) === 'string')\n\t\tbuf = Buffer.from(buf);\n\tassert.buffer(buf, 'buf');\n\n\tvar key = {};\n\n\tvar parts = key.parts = [];\n\tvar sshbuf = new SSHBuffer({buffer: buf});\n\n\tvar alg = sshbuf.readString();\n\tassert.ok(!sshbuf.atEnd(), 'key must have at least one part');\n\n\tkey.type = algToKeyType(alg);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\tif (type && type === 'private')\n\t\tpartCount = algs.privInfo[key.type].parts.length;\n\n\twhile (!sshbuf.atEnd() && parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\twhile (!partial && !sshbuf.atEnd())\n\t\tparts.push(sshbuf.readPart());\n\n\tassert.ok(parts.length >= 1,\n\t    'key must have at least one part');\n\tassert.ok(partial || sshbuf.atEnd(),\n\t    'leftover bytes at end of key');\n\n\tvar Constructor = Key;\n\tvar algInfo = algs.info[key.type];\n\tif (type === 'private' || algInfo.parts.length !== parts.length) {\n\t\talgInfo = algs.privInfo[key.type];\n\t\tConstructor = PrivateKey;\n\t}\n\tassert.strictEqual(algInfo.parts.length, parts.length);\n\n\tif (key.type === 'ecdsa') {\n\t\tvar res = /^ecdsa-sha2-(.+)$/.exec(alg);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tvar normalized = true;\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = parts[i];\n\t\tp.name = algInfo.parts[i];\n\t\t/*\n\t\t * OpenSSH stores ed25519 \"private\" keys as seed + public key\n\t\t * concat'd together (k followed by A). We want to keep them\n\t\t * separate for other formats that don't do this.\n\t\t */\n\t\tif (key.type === 'ed25519' && p.name === 'k')\n\t\t\tp.data = p.data.slice(0, 32);\n\n\t\tif (p.name !== 'curve' && algInfo.normalize !== false) {\n\t\t\tvar nd;\n\t\t\tif (key.type === 'ed25519') {\n\t\t\t\tnd = utils.zeroPadToLength(p.data, 32);\n\t\t\t} else {\n\t\t\t\tnd = utils.mpNormalize(p.data);\n\t\t\t}\n\t\t\tif (nd.toString('binary') !==\n\t\t\t    p.data.toString('binary')) {\n\t\t\t\tp.data = nd;\n\t\t\t\tnormalized = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (normalized)\n\t\tkey._rfc4253Cache = sshbuf.toBuffer();\n\n\tif (partial && typeof (partial) === 'object') {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Constructor(key));\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\n\tvar alg = keyTypeToAlg(key);\n\tvar i;\n\n\tvar algInfo = algs.info[key.type];\n\tif (PrivateKey.isPrivateKey(key))\n\t\talgInfo = algs.privInfo[key.type];\n\tvar parts = algInfo.parts;\n\n\tvar buf = new SSHBuffer({});\n\n\tbuf.writeString(alg);\n\n\tfor (i = 0; i < parts.length; ++i) {\n\t\tvar data = key.part[parts[i]].data;\n\t\tif (algInfo.normalize !== false) {\n\t\t\tif (key.type === 'ed25519')\n\t\t\t\tdata = utils.zeroPadToLength(data, 32);\n\t\t\telse\n\t\t\t\tdata = utils.mpNormalize(data);\n\t\t}\n\t\tif (key.type === 'ed25519' && parts[i] === 'k')\n\t\t\tdata = Buffer.concat([data, key.part.A.data]);\n\t\tbuf.writeBuffer(data);\n\t}\n\n\treturn (buf.toBuffer());\n}\n"]},"metadata":{},"sourceType":"script"}