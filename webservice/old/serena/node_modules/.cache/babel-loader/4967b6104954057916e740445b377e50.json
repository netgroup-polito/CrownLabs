{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nconst util = require('util');\n\nconst crypto = require('crypto');\n\nconst url = require('url');\n\nconst assert = require('assert');\n\nconst base64url = require('base64url');\n\nconst _ = require('lodash');\n\nconst OpenIdConnectError = require('./open_id_connect_error');\n\nconst {\n  BaseClient\n} = require('./client');\n\nconst random = require('./util/random');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n/**\n * @name constructor\n * @api public\n */\n\n\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false\n} = {}, verify) {\n  assert(client instanceof BaseClient, 'client must be an instance of openid-client Client');\n  assert.equal(typeof verify, 'function', 'verify must be a function');\n  assert(client.issuer && client.issuer.issuer, 'client must have an issuer with an identifier');\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = params;\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n    assert(Array.isArray(supportedMethods), 'code_challenge_methods_supported is not properly set on issuer');\n    assert(supportedMethods.length, 'issuer code_challenge_methods_supported is empty');\n\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new Error('neither S256 or plain code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string') {\n    assert(['plain', 'S256'].includes(this._usePKCE), `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n  if (!params.response_type) params.response_type = _.get(client, 'response_types[0]', 'code');\n  if (!params.redirect_uri) params.redirect_uri = _.get(client, 'redirect_uris[0]'); // TODO: only default if there's one\n\n  if (!params.scope) params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  const client = this._client;\n\n  try {\n    if (!req.session) {\n      throw new Error('authentication requires session support when using state, max_age or nonce');\n    }\n\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n    /* start authentication request */\n\n    if (_.isEmpty(reqParams)) {\n      // provide options object with extra authentication parameters\n      const params = _.defaults({}, options, this._params, {\n        state: random()\n      });\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = _.pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = base64url.encode(crypto.createHash('sha256').update(verifier).digest());\n            params.code_challenge_method = 'S256';\n            break;\n\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n\n    const session = req.session[sessionKey];\n\n    if (_.isEmpty(session)) {\n      this.error(new Error(util.format(`did not find expected authorization request details in session, req.session[\"${sessionKey}\"] is %j`, session)));\n      return;\n    }\n\n    const {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = _.defaults({}, options, {\n      redirect_uri: this._params.redirect_uri\n    });\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    };\n    let callback = client.authorizationCallback(opts.redirect_uri, reqParams, checks).then(tokenset => {\n      const result = {\n        tokenset\n      };\n      return result;\n    });\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    if (loadUserinfo) {\n      callback = callback.then(result => {\n        if (result.tokenset.access_token) {\n          const userinfoRequest = client.userinfo(result.tokenset);\n          return userinfoRequest.then(userinfo => {\n            result.userinfo = userinfo;\n            return result;\n          });\n        }\n\n        return result;\n      });\n    }\n\n    callback.then(result => {\n      const args = [result.tokenset, verified.bind(this)];\n      if (loadUserinfo) args.splice(1, 0, result.userinfo);\n      if (passReq) args.unshift(req);\n\n      this._verify(...args);\n    }).catch(error => {\n      if (error instanceof OpenIdConnectError && error.error !== 'server_error' && !error.error.startsWith('invalid')) {\n        this.fail(error);\n      } else {\n        this.error(error);\n      }\n    });\n    /* end authentication response */\n  } catch (err) {\n    this.error(err);\n  }\n};\n\nmodule.exports = OpenIDConnectStrategy;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/openid-client/lib/passport_strategy.js"],"names":["util","require","crypto","url","assert","base64url","_","OpenIdConnectError","BaseClient","random","verified","err","user","info","error","fail","success","OpenIDConnectStrategy","client","params","passReqToCallback","sessionKey","usePKCE","verify","equal","issuer","_client","_issuer","_verify","_passReqToCallback","_usePKCE","_key","parse","hostname","_params","supportedMethods","code_challenge_methods_supported","Array","isArray","length","includes","Error","name","response_type","get","redirect_uri","scope","prototype","authenticate","req","options","session","reqParams","callbackParams","isEmpty","defaults","state","nonce","pick","verifier","code_verifier","code_challenge","encode","createHash","update","digest","code_challenge_method","redirect","authorizationUrl","format","max_age","maxAge","codeVerifier","responseType","opts","checks","callback","authorizationCallback","then","tokenset","result","passReq","loadUserinfo","userinfo_endpoint","access_token","userinfoRequest","userinfo","args","bind","splice","unshift","catch","startsWith","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nconst util = require('util');\nconst crypto = require('crypto');\nconst url = require('url');\nconst assert = require('assert');\n\nconst base64url = require('base64url');\nconst _ = require('lodash');\n\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst { BaseClient } = require('./client');\nconst random = require('./util/random');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false,\n} = {}, verify) {\n  assert(client instanceof BaseClient, 'client must be an instance of openid-client Client');\n  assert.equal(typeof verify, 'function', 'verify must be a function');\n\n  assert(client.issuer && client.issuer.issuer, 'client must have an issuer with an identifier');\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = params;\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n    assert(Array.isArray(supportedMethods), 'code_challenge_methods_supported is not properly set on issuer');\n    assert(supportedMethods.length, 'issuer code_challenge_methods_supported is empty');\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new Error('neither S256 or plain code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string') {\n    assert(['plain', 'S256'].includes(this._usePKCE), `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n\n  if (!params.response_type) params.response_type = _.get(client, 'response_types[0]', 'code');\n  if (!params.redirect_uri) params.redirect_uri = _.get(client, 'redirect_uris[0]'); // TODO: only default if there's one\n  if (!params.scope) params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  const client = this._client;\n  try {\n    if (!req.session) {\n      throw new Error('authentication requires session support when using state, max_age or nonce');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    /* start authentication request */\n    if (_.isEmpty(reqParams)) {\n      // provide options object with extra authentication parameters\n      const params = _.defaults({}, options, this._params, {\n        state: random(),\n      });\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = _.pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) { // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = base64url.encode(crypto.createHash('sha256').update(verifier).digest());\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (_.isEmpty(session)) {\n      this.error(new Error(util.format(\n        `did not find expected authorization request details in session, req.session[\"${sessionKey}\"] is %j`,\n        session\n      )));\n      return;\n    }\n\n    const {\n      state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType,\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = _.defaults({}, options, {\n      redirect_uri: this._params.redirect_uri,\n    });\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    };\n\n    let callback = client.authorizationCallback(opts.redirect_uri, reqParams, checks)\n      .then((tokenset) => {\n        const result = { tokenset };\n        return result;\n      });\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    if (loadUserinfo) {\n      callback = callback.then((result) => {\n        if (result.tokenset.access_token) {\n          const userinfoRequest = client.userinfo(result.tokenset);\n          return userinfoRequest.then((userinfo) => {\n            result.userinfo = userinfo;\n            return result;\n          });\n        }\n\n        return result;\n      });\n    }\n\n    callback.then((result) => {\n      const args = [result.tokenset, verified.bind(this)];\n\n      if (loadUserinfo) args.splice(1, 0, result.userinfo);\n      if (passReq) args.unshift(req);\n\n      this._verify(...args);\n    }).catch((error) => {\n      if (error instanceof OpenIdConnectError\n            && error.error !== 'server_error'\n            && !error.error.startsWith('invalid')) {\n        this.fail(error);\n      } else {\n        this.error(error);\n      }\n    });\n    /* end authentication response */\n  } catch (err) {\n    this.error(err);\n  }\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"]},"metadata":{},"sourceType":"script"}