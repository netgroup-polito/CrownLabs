{"ast":null,"code":"'use strict';\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type = require('../type'); // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP; // Convert one by one.\n\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n    if (code > 64) continue; // Fail on illegal characters\n\n    if (code < 0) return false;\n    bitlen += 6;\n  } // If there are any bits left, source was corrupted\n\n\n  return bitlen % 8 === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n  max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = []; // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  } // Dump tail\n\n\n  tailbits = max % 4 * 6;\n\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object\n/*, style*/\n) {\n  var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  } // Dump tail\n\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/js-yaml/lib/js-yaml/type/binary.js"],"names":["NodeBuffer","_require","require","Buffer","__","Type","BASE64_MAP","resolveYamlBinary","data","code","idx","bitlen","max","length","map","indexOf","charAt","constructYamlBinary","tailbits","input","replace","bits","result","push","from","representYamlBinary","object","tail","isBinary","isBuffer","module","exports","kind","resolve","construct","predicate","represent"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"]},"metadata":{},"sourceType":"script"}