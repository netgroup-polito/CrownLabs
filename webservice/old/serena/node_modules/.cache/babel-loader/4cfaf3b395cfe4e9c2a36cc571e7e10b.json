{"ast":null,"code":"// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\nconst assert = require('assert');\n\nconst PORT = /^\\d+$/;\n\nfunction hasScheme(input) {\n  if (input.includes('://')) return true;\n  const authority = input.replace(/(\\/|\\?)/g, '#').split('#')[0];\n\n  if (authority.includes(':')) {\n    const index = authority.indexOf(':');\n    const hostOrPort = authority.slice(index + 1);\n    if (!PORT.exec(hostOrPort)) return true;\n  }\n\n  return false;\n}\n\nfunction acctSchemeAssumed(input) {\n  if (!input.includes('@')) return false;\n  const parts = input.split('@');\n  const host = parts[parts.length - 1];\n  return !(host.includes(':') || host.includes('/') || host.includes('?'));\n}\n\nfunction normalize(input) {\n  assert(input, 'nothing to normalize');\n  assert.equal(typeof input, 'string', 'input must be a string');\n  let output;\n\n  if (hasScheme(input)) {\n    output = input;\n  } else if (acctSchemeAssumed(input)) {\n    output = `acct:${input}`;\n  } else {\n    output = `https://${input}`;\n  }\n\n  return output.split('#')[0];\n}\n\nmodule.exports = normalize;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/openid-client/lib/util/webfinger_normalize.js"],"names":["assert","require","PORT","hasScheme","input","includes","authority","replace","split","index","indexOf","hostOrPort","slice","exec","acctSchemeAssumed","parts","host","length","normalize","equal","output","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMC,IAAI,GAAG,OAAb;;AAEA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,MAAIA,KAAK,CAACC,QAAN,CAAe,KAAf,CAAJ,EAA2B,OAAO,IAAP;AAE3B,QAAMC,SAAS,GAAGF,KAAK,CAACG,OAAN,CAAc,UAAd,EAA0B,GAA1B,EAA+BC,KAA/B,CAAqC,GAArC,EAA0C,CAA1C,CAAlB;;AACA,MAAIF,SAAS,CAACD,QAAV,CAAmB,GAAnB,CAAJ,EAA6B;AAC3B,UAAMI,KAAK,GAAGH,SAAS,CAACI,OAAV,CAAkB,GAAlB,CAAd;AACA,UAAMC,UAAU,GAAGL,SAAS,CAACM,KAAV,CAAgBH,KAAK,GAAG,CAAxB,CAAnB;AACA,QAAI,CAACP,IAAI,CAACW,IAAL,CAAUF,UAAV,CAAL,EAA4B,OAAO,IAAP;AAC7B;;AAED,SAAO,KAAP;AACD;;AAED,SAASG,iBAAT,CAA2BV,KAA3B,EAAkC;AAChC,MAAI,CAACA,KAAK,CAACC,QAAN,CAAe,GAAf,CAAL,EAA0B,OAAO,KAAP;AAC1B,QAAMU,KAAK,GAAGX,KAAK,CAACI,KAAN,CAAY,GAAZ,CAAd;AACA,QAAMQ,IAAI,GAAGD,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAAlB;AACA,SAAO,EAAED,IAAI,CAACX,QAAL,CAAc,GAAd,KAAsBW,IAAI,CAACX,QAAL,CAAc,GAAd,CAAtB,IAA4CW,IAAI,CAACX,QAAL,CAAc,GAAd,CAA9C,CAAP;AACD;;AAED,SAASa,SAAT,CAAmBd,KAAnB,EAA0B;AACxBJ,EAAAA,MAAM,CAACI,KAAD,EAAQ,sBAAR,CAAN;AACAJ,EAAAA,MAAM,CAACmB,KAAP,CAAa,OAAOf,KAApB,EAA2B,QAA3B,EAAqC,wBAArC;AAEA,MAAIgB,MAAJ;;AACA,MAAIjB,SAAS,CAACC,KAAD,CAAb,EAAsB;AACpBgB,IAAAA,MAAM,GAAGhB,KAAT;AACD,GAFD,MAEO,IAAIU,iBAAiB,CAACV,KAAD,CAArB,EAA8B;AACnCgB,IAAAA,MAAM,GAAI,QAAOhB,KAAM,EAAvB;AACD,GAFM,MAEA;AACLgB,IAAAA,MAAM,GAAI,WAAUhB,KAAM,EAA1B;AACD;;AAED,SAAOgB,MAAM,CAACZ,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAP;AACD;;AAEDa,MAAM,CAACC,OAAP,GAAiBJ,SAAjB","sourcesContent":["// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\n\nconst assert = require('assert');\n\nconst PORT = /^\\d+$/;\n\nfunction hasScheme(input) {\n  if (input.includes('://')) return true;\n\n  const authority = input.replace(/(\\/|\\?)/g, '#').split('#')[0];\n  if (authority.includes(':')) {\n    const index = authority.indexOf(':');\n    const hostOrPort = authority.slice(index + 1);\n    if (!PORT.exec(hostOrPort)) return true;\n  }\n\n  return false;\n}\n\nfunction acctSchemeAssumed(input) {\n  if (!input.includes('@')) return false;\n  const parts = input.split('@');\n  const host = parts[parts.length - 1];\n  return !(host.includes(':') || host.includes('/') || host.includes('?'));\n}\n\nfunction normalize(input) {\n  assert(input, 'nothing to normalize');\n  assert.equal(typeof input, 'string', 'input must be a string');\n\n  let output;\n  if (hasScheme(input)) {\n    output = input;\n  } else if (acctSchemeAssumed(input)) {\n    output = `acct:${input}`;\n  } else {\n    output = `https://${input}`;\n  }\n\n  return output.split('#')[0];\n}\n\nmodule.exports = normalize;\n"]},"metadata":{},"sourceType":"script"}