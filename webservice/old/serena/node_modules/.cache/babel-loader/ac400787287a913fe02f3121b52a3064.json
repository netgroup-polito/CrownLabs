{"ast":null,"code":"var crypto = require(\"crypto\");\n\nvar BigInteger = require(\"jsbn\").BigInteger;\n\nvar ECPointFp = require(\"./lib/ec.js\").ECPointFp;\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\nexports.ECCurves = require(\"./lib/sec.js\"); // zero prepad\n\nfunction unstupid(hex, len) {\n  return hex.length >= len ? hex : unstupid(\"0\" + hex, len);\n}\n\nexports.ECKey = function (curve, key, isPublic) {\n  var priv;\n  var c = curve();\n  var n = c.getN();\n  var bytes = Math.floor(n.bitLength() / 8);\n\n  if (key) {\n    if (isPublic) {\n      var curve = c.getCurve(); //      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n      //      var y = key.slice(bytes+1);\n      //      this.P = new ECPointFp(curve,\n      //        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n      //        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n\n      this.P = curve.decodePointHex(key.toString(\"hex\"));\n    } else {\n      if (key.length != bytes) return false;\n      priv = new BigInteger(key.toString(\"hex\"), 16);\n    }\n  } else {\n    var n1 = n.subtract(BigInteger.ONE);\n    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n    priv = r.mod(n1).add(BigInteger.ONE);\n    this.P = c.getG().multiply(priv);\n  }\n\n  if (this.P) {\n    //  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n    //  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P), \"hex\");\n  }\n\n  if (priv) {\n    this.PrivateKey = Buffer.from(unstupid(priv.toString(16), bytes * 2), \"hex\");\n\n    this.deriveSharedSecret = function (key) {\n      if (!key || !key.P) return false;\n      var S = key.P.multiply(priv);\n      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), \"hex\");\n    };\n  }\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/ecc-jsbn/index.js"],"names":["crypto","require","BigInteger","ECPointFp","Buffer","exports","ECCurves","unstupid","hex","len","length","ECKey","curve","key","isPublic","priv","c","n","getN","bytes","Math","floor","bitLength","getCurve","P","decodePointHex","toString","n1","subtract","ONE","r","randomBytes","mod","add","getG","multiply","PublicKey","from","encodeCompressedPointHex","PrivateKey","deriveSharedSecret","S","getX","toBigInteger"],"mappings":"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","sourcesContent":["var crypto = require(\"crypto\");\nvar BigInteger = require(\"jsbn\").BigInteger;\nvar ECPointFp = require(\"./lib/ec.js\").ECPointFp;\nvar Buffer = require(\"safer-buffer\").Buffer;\nexports.ECCurves = require(\"./lib/sec.js\");\n\n// zero prepad\nfunction unstupid(hex,len)\n{\n\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n}\n\nexports.ECKey = function(curve, key, isPublic)\n{\n  var priv;\n\tvar c = curve();\n\tvar n = c.getN();\n  var bytes = Math.floor(n.bitLength()/8);\n\n  if(key)\n  {\n    if(isPublic)\n    {\n      var curve = c.getCurve();\n//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n//      var y = key.slice(bytes+1);\n//      this.P = new ECPointFp(curve,\n//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n      this.P = curve.decodePointHex(key.toString(\"hex\"));\n    }else{\n      if(key.length != bytes) return false;\n      priv = new BigInteger(key.toString(\"hex\"), 16);      \n    }\n  }else{\n    var n1 = n.subtract(BigInteger.ONE);\n    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n    priv = r.mod(n1).add(BigInteger.ONE);\n    this.P = c.getG().multiply(priv);\n  }\n  if(this.P)\n  {\n//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n//  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n  }\n  if(priv)\n  {\n    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),\"hex\");\n    this.deriveSharedSecret = function(key)\n    {\n      if(!key || !key.P) return false;\n      var S = key.P.multiply(priv);\n      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n   }     \n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}