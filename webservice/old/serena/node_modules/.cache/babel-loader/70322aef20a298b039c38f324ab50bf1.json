{"ast":null,"code":"'use strict';\n/*eslint-disable no-use-before-define*/\n\nvar common = require('./common');\n\nvar YAMLException = require('./exception');\n\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n  /* BOM */\n  || 0x10000 <= c && c <= 0x10FFFF;\n} // Simplified test for values allowed after the first character in plain style.\n\n\nfunction isPlainSafe(c) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n  && c !== CHAR_COLON && c !== CHAR_SHARP;\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “\"”\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char);\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n\n    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n    if (char >= 0xD800 && char <= 0xDBFF\n    /* high surrogate */\n    ) {\n        nextChar = string.charCodeAt(i + 1);\n\n        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n        /* low surrogate */\n        ) {\n            // Combine the surrogate pair and store it escaped.\n            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n            i++;\n            continue;\n          }\n      }\n\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = state.condenseFlow ? '\"' : '';\n    if (index !== 0) pairBuffer += ', ';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n      if (block && state.dump.length !== 0) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({\n    schema: DEFAULT_SAFE_SCHEMA\n  }, options));\n}\n\nmodule.exports.dump = dump;\nmodule.exports.safeDump = safeDump;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/js-yaml/lib/js-yaml/dumper.js"],"names":["common","require","YAMLException","DEFAULT_FULL_SCHEMA","DEFAULT_SAFE_SCHEMA","_toString","Object","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_TAB","CHAR_LINE_FEED","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","compileStyleMap","schema","map","result","keys","index","length","tag","style","type","String","slice","compiledTypeMap","call","styleAliases","encodeHex","character","string","handle","toUpperCase","repeat","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","isNothing","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","c","isPrintable","isPlainSafe","isPlainSafeFirst","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","i","char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","charCodeAt","writeScalar","iskey","dump","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","nextChar","escapeSeq","writeFlowSequence","object","_result","_tag","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","represent","defaultStyle","block","objectOrArray","duplicateIndex","duplicate","arrayLevel","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","Array","isArray","input","safeDump","extend","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    && c !== CHAR_COLON\n    && c !== CHAR_SHARP;\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = state.condenseFlow ? '\"' : '';\n\n    if (index !== 0) pairBuffer += ', ';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n"]},"metadata":{},"sourceType":"script"}