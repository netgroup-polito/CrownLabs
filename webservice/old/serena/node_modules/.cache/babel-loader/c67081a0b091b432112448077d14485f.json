{"ast":null,"code":"'use strict';\n/*eslint-disable max-len*/\n\nvar common = require('./common');\n\nvar YAMLException = require('./exception');\n\nvar Type = require('./type');\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n    result.push(currentType);\n  });\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\nfunction compileMap()\n/* lists... */\n{\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {}\n  },\n      index,\n      length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\nfunction Schema(definition) {\n  this.include = definition.include || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\nSchema.DEFAULT = null;\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) {\n    return schema instanceof Schema;\n  })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) {\n    return type instanceof Type;\n  })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\nmodule.exports = Schema;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/js-yaml/lib/js-yaml/schema.js"],"names":["common","require","YAMLException","Type","compileList","schema","name","result","exclude","include","forEach","includedSchema","currentType","previousType","previousIndex","tag","kind","push","filter","type","index","indexOf","compileMap","scalar","sequence","mapping","fallback","length","collectType","arguments","Schema","definition","implicit","explicit","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","DEFAULT","create","createSchema","schemas","types","toArray","every","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n"]},"metadata":{},"sourceType":"script"}