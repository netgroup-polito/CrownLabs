{"ast":null,"code":"// Ignore warning about 'new String()'\n\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\n\nvar fs = require('fs');\n\nvar glob = require('glob');\n\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\nexports.extend = Object.assign; // Check if we're running under electron\n\nvar isElectron = Boolean(process.versions.electron); // Module globals (assume no execPath by default)\n\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024 // 64KB\n\n};\nvar config = {\n  reset: function () {\n    Object.assign(this, DEFAULT_CONFIG);\n\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  }\n};\nconfig.reset();\nexports.config = config; // Note: commands should generally consider these as read-only values.\n\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js'\n};\nexports.state = state;\ndelete process.env.OLDPWD; // initially, there's no previous directory\n// Reliably test if something is any sort of javascript object\n\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\n\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\n\nexports.log = log; // Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\n\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n\n  return msg.replace(/\\\\/g, '/');\n}\n\nexports.convertErrorOutput = convertErrorOutput; // Shows error message. Throws if config.fatal is true\n\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) {\n    // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') {\n    // no 'options'\n    options = {\n      code: _code\n    };\n  } else if (typeof _code !== 'number') {\n    // only 'msg'\n    options = {};\n  }\n\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  if (!state.errorCode) state.errorCode = options.code;\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry; // Throw an error, or log the entry\n\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: new ShellString('', state.error, state.errorCode)\n    };\n  }\n}\n\nexports.error = error; //@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`.\n\nfunction ShellString(stdout, stderr, code) {\n  var that;\n\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n\n  that.stderr = stderr;\n  that.code = code; // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString; // Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n// Throws an error when passed a string that does not start with '-':\n//   parseOptions('a', {'a':'alice'}); // throws\n\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  if (opt === '--') {\n    // This means there are no options.\n    return {};\n  } // All options are false by default\n\n\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      throw new Error(\"Options string must start with a '-'\");\n    } // e.g. chars = ['R', 'f']\n\n\n    var chars = opt.slice(1).split('');\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else {\n    // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n\n  return options;\n}\n\nexports.parseOptions = parseOptions; // Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\n\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n\n      try {\n        ret = glob.sync(listEl, config.globOptions); // if nothing matched, interpret the string literally\n\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\n\nexports.expand = expand; // Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\n\nvar buffer = typeof Buffer.alloc === 'function' ? function (len) {\n  return Buffer.alloc(len || config.bufLength);\n} : function (len) {\n  return new Buffer(len || config.bufLength);\n};\nexports.buffer = buffer; // Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\n\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\n\nexports.unlinkSync = unlinkSync; // wrappers around common.statFollowLinks and common.statNoFollowLinks that clarify intent\n// and improve readability\n\nfunction statFollowLinks() {\n  return fs.statSync.apply(fs, arguments);\n}\n\nexports.statFollowLinks = statFollowLinks;\n\nfunction statNoFollowLinks() {\n  return fs.lstatSync.apply(fs, arguments);\n}\n\nexports.statNoFollowLinks = statNoFollowLinks; // e.g. 'shelljs_a5f185d0443ca...'\n\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n\n    var hash = '';\n\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\n\nexports.randomFileName = randomFileName; // Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\n\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  return function () {\n    var retValue = null;\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0); // Log the command to stderr, if appropriate\n\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      } // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n\n\n      state.pipedValue = this && typeof this.stdout === 'string' ? this.stdout : '';\n\n      if (options.unix === false) {\n        // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else {\n        // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {// a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        } // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n\n\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n\n          accum.push(cur);\n          return accum;\n        }, []); // Convert ShellStrings (basically just String objects) to regular strings\n\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n\n          return arg;\n        }); // Expand the '~' if appropriate\n\n        var homeDir = os.homedir();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n\n          return arg;\n        }); // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        e.name = 'ShellJSInternalError';\n        throw e;\n      }\n\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput && (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\n\n\nexports.wrap = wrap; // This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\n\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\n\nexports.readFromPipe = _readFromPipe;\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: null,\n  globStart: 1,\n  pipeOnly: false,\n  wrapOutput: true,\n  unix: true\n}; // This is populated during plugin registration\n\nvar pipeMethods = []; // Register a new ShellJS command\n\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {}; // Validate options\n\n  Object.keys(wrapOptions).forEach(function (option) {\n    if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {\n      throw new Error(\"Unknown option '\" + option + \"'\");\n    }\n\n    if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {\n      throw new TypeError(\"Unsupported type '\" + typeof wrapOptions[option] + \"' for option '\" + option + \"'\");\n    }\n  }); // If an option isn't specified, use the default\n\n  wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name]) {\n    throw new Error('Command `' + name + '` already exists');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n\n  if (wrapOptions.canReceivePipe) {\n    pipeMethods.push(name);\n  }\n}\n\nexports.register = _register;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/shelljs/src/common.js"],"names":["os","require","fs","glob","shell","shellMethods","Object","create","exports","extend","assign","isElectron","Boolean","process","versions","electron","DEFAULT_CONFIG","fatal","globOptions","maxdepth","noglob","silent","verbose","execPath","bufLength","config","reset","resetForTesting","state","error","errorCode","currentCmd","env","OLDPWD","isObject","a","log","console","apply","arguments","convertErrorOutput","msg","TypeError","replace","_code","options","Error","DEFAULT_OPTIONS","continue","code","prefix","logEntry","length","retValue","ShellString","stdout","stderr","that","Array","join","String","pipeMethods","forEach","cmd","bind","parseOptions","opt","map","errorOptions","keys","letter","optName","chars","slice","split","c","optionName","key","expand","list","isArray","expanded","listEl","push","ret","sync","e","concat","buffer","Buffer","alloc","len","unlinkSync","file","chmodSync","statFollowLinks","statSync","statNoFollowLinks","lstatSync","randomFileName","randomHash","count","parseInt","Math","random","toString","hash","i","wrap","fn","args","call","pipedValue","unix","constructor","name","unshift","reduce","accum","cur","arg","homeDir","homedir","allowGlobbing","globStart","cmdOptions","wrapOutput","_readFromPipe","readFromPipe","DEFAULT_WRAP_OPTIONS","canReceivePipe","pipeOnly","_register","implementation","wrapOptions","option","hasOwnProperty","register"],"mappings":"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","sourcesContent":["// Ignore warning about 'new String()'\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\nvar fs = require('fs');\nvar glob = require('glob');\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\n\nexports.extend = Object.assign;\n\n// Check if we're running under electron\nvar isElectron = Boolean(process.versions.electron);\n\n// Module globals (assume no execPath by default)\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024, // 64KB\n};\n\nvar config = {\n  reset: function () {\n    Object.assign(this, DEFAULT_CONFIG);\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  },\n};\n\nconfig.reset();\nexports.config = config;\n\n// Note: commands should generally consider these as read-only values.\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js',\n};\nexports.state = state;\n\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\n// Reliably test if something is any sort of javascript object\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\nexports.log = log;\n\n// Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  return msg.replace(/\\\\/g, '/');\n}\nexports.convertErrorOutput = convertErrorOutput;\n\n// Shows error message. Throws if config.fatal is true\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false,\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) { // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') { // no 'options'\n    options = { code: _code };\n  } else if (typeof _code !== 'number') { // only 'msg'\n    options = {};\n  }\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n\n  if (!state.errorCode) state.errorCode = options.code;\n\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry;\n\n  // Throw an error, or log the entry\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: (new ShellString('', state.error, state.errorCode)),\n    };\n  }\n}\nexports.error = error;\n\n//@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`.\nfunction ShellString(stdout, stderr, code) {\n  var that;\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n  that.stderr = stderr;\n  that.code = code;\n  // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString;\n\n// Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n// Throws an error when passed a string that does not start with '-':\n//   parseOptions('a', {'a':'alice'}); // throws\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  if (opt === '--') {\n    // This means there are no options.\n    return {};\n  }\n\n  // All options are false by default\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      throw new Error(\"Options string must start with a '-'\");\n    }\n\n    // e.g. chars = ['R', 'f']\n    var chars = opt.slice(1).split('');\n\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else { // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n      try {\n        ret = glob.sync(listEl, config.globOptions);\n        // if nothing matched, interpret the string literally\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\nvar buffer = typeof Buffer.alloc === 'function' ?\n  function (len) {\n    return Buffer.alloc(len || config.bufLength);\n  } :\n  function (len) {\n    return new Buffer(len || config.bufLength);\n  };\nexports.buffer = buffer;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// wrappers around common.statFollowLinks and common.statNoFollowLinks that clarify intent\n// and improve readability\nfunction statFollowLinks() {\n  return fs.statSync.apply(fs, arguments);\n}\nexports.statFollowLinks = statFollowLinks;\n\nfunction statNoFollowLinks() {\n  return fs.lstatSync.apply(fs, arguments);\n}\nexports.statNoFollowLinks = statNoFollowLinks;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n    var hash = '';\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  return function () {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      // Log the command to stderr, if appropriate\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      }\n\n      // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n      state.pipedValue = (this && typeof this.stdout === 'string') ? this.stdout : '';\n\n      if (options.unix === false) { // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else { // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {\n          // a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        }\n\n        // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n          accum.push(cur);\n          return accum;\n        }, []);\n\n        // Convert ShellStrings (basically just String objects) to regular strings\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n          return arg;\n        });\n\n        // Expand the '~' if appropriate\n        var homeDir = os.homedir();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n          return arg;\n        });\n\n        // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        e.name = 'ShellJSInternalError';\n        throw e;\n      }\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput &&\n        (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n\n// This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\nexports.readFromPipe = _readFromPipe;\n\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: null,\n  globStart: 1,\n  pipeOnly: false,\n  wrapOutput: true,\n  unix: true,\n};\n\n// This is populated during plugin registration\nvar pipeMethods = [];\n\n// Register a new ShellJS command\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {};\n\n  // Validate options\n  Object.keys(wrapOptions).forEach(function (option) {\n    if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {\n      throw new Error(\"Unknown option '\" + option + \"'\");\n    }\n    if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {\n      throw new TypeError(\"Unsupported type '\" + typeof wrapOptions[option] +\n        \"' for option '\" + option + \"'\");\n    }\n  });\n\n  // If an option isn't specified, use the default\n  wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name]) {\n    throw new Error('Command `' + name + '` already exists');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n\n  if (wrapOptions.canReceivePipe) {\n    pipeMethods.push(name);\n  }\n}\nexports.register = _register;\n"]},"metadata":{},"sourceType":"script"}