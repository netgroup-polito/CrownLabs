{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink'\n  },\n  wrapOutput: false\n}); // Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\n\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32'; // Check the mtimes of the files if the '-u' flag is provided\n\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {// If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {// it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n} // Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\n\n\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {}; // Ensure there is not a run away recursive copy\n\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n  var isWindows = process.platform === 'win32'; // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n    var symlinkFull;\n\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {// it doesn't exist, so no work needs to be done\n      }\n\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n\n\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n// Checks if cureent file was created recently\n\n\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n} //@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\n\n\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  } // Get sources, dest\n\n\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest); // Dest is not existing dir, but multiple sources given\n\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  } // Dest is an existing file, but -n is given\n\n\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    var srcStat = common.statFollowLinks(src);\n\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", {\n          continue: true\n        });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, {\n            no_force: options.no_force,\n            followsymlink: options.followsymlink\n          });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n            continue: true\n          });\n        }\n\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", {\n          continue: true\n        });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\n\nmodule.exports = _cp;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/shelljs/src/cp.js"],"names":["fs","require","path","common","register","_cp","cmdOptions","wrapOutput","copyFileSync","srcFile","destFile","options","existsSync","error","isWindows","process","platform","update","statFollowLinks","mtime","statSync","e","statNoFollowLinks","isSymbolicLink","followsymlink","unlinkSync","symlinkFull","readlinkSync","symlinkSync","buf","buffer","bufLength","length","bytesRead","pos","fdr","fdw","openSync","code","readSync","writeSync","closeSync","chmodSync","mode","cpdirSyncRecursive","sourceDir","destDir","currentDepth","opts","config","maxdepth","mkdirSync","files","readdirSync","i","srcFileStat","cpcheckcycle","console","isDirectory","no_force","log","checkDir","checkRecentCreated","sources","index","lookedSource","slice","some","src","basename","cyclecheck","sourcerealpath","realpathSync","symlinkrealpath","re","RegExp","test","dest","noFollowsymlink","recursive","arguments","call","destExists","destStat","isFile","ShellString","forEach","srcIndex","continue","srcStat","newDest","join","dirname","thisDest","normalize","thisDestExists","relative","state","errorCode","module","exports"],"mappings":"AAAA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAD,CAApB;;AAEAE,MAAM,CAACC,QAAP,CAAgB,IAAhB,EAAsBC,GAAtB,EAA2B;AACzBC,EAAAA,UAAU,EAAE;AACV,SAAK,WADK;AAEV,SAAK,UAFK;AAGV,SAAK,QAHK;AAIV,SAAK,WAJK;AAKV,SAAK,WALK;AAMV,SAAK,eANK;AAOV,SAAK;AAPK,GADa;AAUzBC,EAAAA,UAAU,EAAE;AAVa,CAA3B,E,CAaA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,QAA/B,EAAyCC,OAAzC,EAAkD;AAChD,MAAI,CAACX,EAAE,CAACY,UAAH,CAAcH,OAAd,CAAL,EAA6B;AAC3BN,IAAAA,MAAM,CAACU,KAAP,CAAa,8CAA8CJ,OAA3D;AACD;;AAED,MAAIK,SAAS,GAAGC,OAAO,CAACC,QAAR,KAAqB,OAArC,CALgD,CAOhD;;AACA,MAAI;AACF,QAAIL,OAAO,CAACM,MAAR,IAAkBd,MAAM,CAACe,eAAP,CAAuBT,OAAvB,EAAgCU,KAAhC,GAAwCnB,EAAE,CAACoB,QAAH,CAAYV,QAAZ,EAAsBS,KAApF,EAA2F;AACzF;AACD;AACF,GAJD,CAIE,OAAOE,CAAP,EAAU,CACV;AACD;;AAED,MAAIlB,MAAM,CAACmB,iBAAP,CAAyBb,OAAzB,EAAkCc,cAAlC,MAAsD,CAACZ,OAAO,CAACa,aAAnE,EAAkF;AAChF,QAAI;AACFrB,MAAAA,MAAM,CAACmB,iBAAP,CAAyBZ,QAAzB;AACAP,MAAAA,MAAM,CAACsB,UAAP,CAAkBf,QAAlB,EAFE,CAE2B;AAC9B,KAHD,CAGE,OAAOW,CAAP,EAAU,CACV;AACD;;AAED,QAAIK,WAAW,GAAG1B,EAAE,CAAC2B,YAAH,CAAgBlB,OAAhB,CAAlB;AACAT,IAAAA,EAAE,CAAC4B,WAAH,CAAeF,WAAf,EAA4BhB,QAA5B,EAAsCI,SAAS,GAAG,UAAH,GAAgB,IAA/D;AACD,GAVD,MAUO;AACL,QAAIe,GAAG,GAAG1B,MAAM,CAAC2B,MAAP,EAAV;AACA,QAAIC,SAAS,GAAGF,GAAG,CAACG,MAApB;AACA,QAAIC,SAAS,GAAGF,SAAhB;AACA,QAAIG,GAAG,GAAG,CAAV;AACA,QAAIC,GAAG,GAAG,IAAV;AACA,QAAIC,GAAG,GAAG,IAAV;;AAEA,QAAI;AACFD,MAAAA,GAAG,GAAGnC,EAAE,CAACqC,QAAH,CAAY5B,OAAZ,EAAqB,GAArB,CAAN;AACD,KAFD,CAEE,OAAOY,CAAP,EAAU;AACV;AACAlB,MAAAA,MAAM,CAACU,KAAP,CAAa,4CAA4CJ,OAA5C,GAAsD,GAAnE;AACD;;AAED,QAAI;AACF2B,MAAAA,GAAG,GAAGpC,EAAE,CAACqC,QAAH,CAAY3B,QAAZ,EAAsB,GAAtB,CAAN;AACD,KAFD,CAEE,OAAOW,CAAP,EAAU;AACV;AACAlB,MAAAA,MAAM,CAACU,KAAP,CAAa,sDAAsDQ,CAAC,CAACiB,IAAxD,GAA+D,IAA/D,GAAsE5B,QAAnF;AACD;;AAED,WAAOuB,SAAS,KAAKF,SAArB,EAAgC;AAC9BE,MAAAA,SAAS,GAAGjC,EAAE,CAACuC,QAAH,CAAYJ,GAAZ,EAAiBN,GAAjB,EAAsB,CAAtB,EAAyBE,SAAzB,EAAoCG,GAApC,CAAZ;AACAlC,MAAAA,EAAE,CAACwC,SAAH,CAAaJ,GAAb,EAAkBP,GAAlB,EAAuB,CAAvB,EAA0BI,SAA1B;AACAC,MAAAA,GAAG,IAAID,SAAP;AACD;;AAEDjC,IAAAA,EAAE,CAACyC,SAAH,CAAaN,GAAb;AACAnC,IAAAA,EAAE,CAACyC,SAAH,CAAaL,GAAb;AAEApC,IAAAA,EAAE,CAAC0C,SAAH,CAAahC,QAAb,EAAuBP,MAAM,CAACe,eAAP,CAAuBT,OAAvB,EAAgCkC,IAAvD;AACD;AACF,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BC,SAA5B,EAAuCC,OAAvC,EAAgDC,YAAhD,EAA8DC,IAA9D,EAAoE;AAClE,MAAI,CAACA,IAAL,EAAWA,IAAI,GAAG,EAAP,CADuD,CAGlE;;AACA,MAAID,YAAY,IAAI5C,MAAM,CAAC8C,MAAP,CAAcC,QAAlC,EAA4C;AAC5CH,EAAAA,YAAY;AAEZ,MAAIjC,SAAS,GAAGC,OAAO,CAACC,QAAR,KAAqB,OAArC,CAPkE,CASlE;AACA;;AACA,MAAI;AACFhB,IAAAA,EAAE,CAACmD,SAAH,CAAaL,OAAb;AACD,GAFD,CAEE,OAAOzB,CAAP,EAAU;AACV;AACA,QAAIA,CAAC,CAACiB,IAAF,KAAW,QAAf,EAAyB,MAAMjB,CAAN;AAC1B;;AAED,MAAI+B,KAAK,GAAGpD,EAAE,CAACqD,WAAH,CAAeR,SAAf,CAAZ;;AAEA,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACpB,MAA1B,EAAkCsB,CAAC,EAAnC,EAAuC;AACrC,QAAI7C,OAAO,GAAGoC,SAAS,GAAG,GAAZ,GAAkBO,KAAK,CAACE,CAAD,CAArC;AACA,QAAI5C,QAAQ,GAAGoC,OAAO,GAAG,GAAV,GAAgBM,KAAK,CAACE,CAAD,CAApC;AACA,QAAIC,WAAW,GAAGpD,MAAM,CAACmB,iBAAP,CAAyBb,OAAzB,CAAlB;AAEA,QAAIiB,WAAJ;;AACA,QAAIsB,IAAI,CAACxB,aAAT,EAAwB;AACtB,UAAIgC,YAAY,CAACX,SAAD,EAAYpC,OAAZ,CAAhB,EAAsC;AACpC;AACAgD,QAAAA,OAAO,CAAC5C,KAAR,CAAc,mBAAd;AACAa,QAAAA,WAAW,GAAG1B,EAAE,CAAC2B,YAAH,CAAgBlB,OAAhB,CAAd;AACAT,QAAAA,EAAE,CAAC4B,WAAH,CAAeF,WAAf,EAA4BhB,QAA5B,EAAsCI,SAAS,GAAG,UAAH,GAAgB,IAA/D;AACA;AACD;AACF;;AACD,QAAIyC,WAAW,CAACG,WAAZ,EAAJ,EAA+B;AAC7B;AACAd,MAAAA,kBAAkB,CAACnC,OAAD,EAAUC,QAAV,EAAoBqC,YAApB,EAAkCC,IAAlC,CAAlB;AACD,KAHD,MAGO,IAAIO,WAAW,CAAChC,cAAZ,MAAgC,CAACyB,IAAI,CAACxB,aAA1C,EAAyD;AAC9DE,MAAAA,WAAW,GAAG1B,EAAE,CAAC2B,YAAH,CAAgBlB,OAAhB,CAAd;;AACA,UAAI;AACFN,QAAAA,MAAM,CAACmB,iBAAP,CAAyBZ,QAAzB;AACAP,QAAAA,MAAM,CAACsB,UAAP,CAAkBf,QAAlB,EAFE,CAE2B;AAC9B,OAHD,CAGE,OAAOW,CAAP,EAAU,CACV;AACD;;AACDrB,MAAAA,EAAE,CAAC4B,WAAH,CAAeF,WAAf,EAA4BhB,QAA5B,EAAsCI,SAAS,GAAG,UAAH,GAAgB,IAA/D;AACD,KATM,MASA,IAAIyC,WAAW,CAAChC,cAAZ,MAAgCyB,IAAI,CAACxB,aAAzC,EAAwD;AAC7D+B,MAAAA,WAAW,GAAGpD,MAAM,CAACe,eAAP,CAAuBT,OAAvB,CAAd;;AACA,UAAI8C,WAAW,CAACG,WAAZ,EAAJ,EAA+B;AAC7Bd,QAAAA,kBAAkB,CAACnC,OAAD,EAAUC,QAAV,EAAoBqC,YAApB,EAAkCC,IAAlC,CAAlB;AACD,OAFD,MAEO;AACLxC,QAAAA,YAAY,CAACC,OAAD,EAAUC,QAAV,EAAoBsC,IAApB,CAAZ;AACD;AACF,KAPM,MAOA;AACL;AACA,UAAIhD,EAAE,CAACY,UAAH,CAAcF,QAAd,KAA2BsC,IAAI,CAACW,QAApC,EAA8C;AAC5CxD,QAAAA,MAAM,CAACyD,GAAP,CAAW,6BAA6BR,KAAK,CAACE,CAAD,CAA7C;AACD,OAFD,MAEO;AACL9C,QAAAA,YAAY,CAACC,OAAD,EAAUC,QAAV,EAAoBsC,IAApB,CAAZ;AACD;AACF;AACF,GA9DiE,CA8DhE;AAEF;AACA;;;AACA,MAAIa,QAAQ,GAAG1D,MAAM,CAACe,eAAP,CAAuB2B,SAAvB,CAAf;AACA7C,EAAAA,EAAE,CAAC0C,SAAH,CAAaI,OAAb,EAAsBe,QAAQ,CAAClB,IAA/B;AACD,C,CAAC;AAEF;;;AACA,SAASmB,kBAAT,CAA4BC,OAA5B,EAAqCC,KAArC,EAA4C;AAC1C,MAAIC,YAAY,GAAGF,OAAO,CAACC,KAAD,CAA1B;AACA,SAAOD,OAAO,CAACG,KAAR,CAAc,CAAd,EAAiBF,KAAjB,EAAwBG,IAAxB,CAA6B,UAAUC,GAAV,EAAe;AACjD,WAAOlE,IAAI,CAACmE,QAAL,CAAcD,GAAd,MAAuBlE,IAAI,CAACmE,QAAL,CAAcJ,YAAd,CAA9B;AACD,GAFM,CAAP;AAGD;;AAED,SAAST,YAAT,CAAsBX,SAAtB,EAAiCpC,OAAjC,EAA0C;AACxC,MAAI8C,WAAW,GAAGpD,MAAM,CAACmB,iBAAP,CAAyBb,OAAzB,CAAlB;;AACA,MAAI8C,WAAW,CAAChC,cAAZ,EAAJ,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAI+C,UAAU,GAAGnE,MAAM,CAACe,eAAP,CAAuBT,OAAvB,CAAjB;;AACA,QAAI6D,UAAU,CAACZ,WAAX,EAAJ,EAA8B;AAC5B,UAAIa,cAAc,GAAGvE,EAAE,CAACwE,YAAH,CAAgB3B,SAAhB,CAArB;AACA,UAAI4B,eAAe,GAAGzE,EAAE,CAACwE,YAAH,CAAgB/D,OAAhB,CAAtB;AACA,UAAIiE,EAAE,GAAG,IAAIC,MAAJ,CAAWF,eAAX,CAAT;;AACA,UAAIC,EAAE,CAACE,IAAH,CAAQL,cAAR,CAAJ,EAA6B;AAC3B,eAAO,IAAP;AACD;AACF;AACF;;AACD,SAAO,KAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASlE,GAAT,CAAaM,OAAb,EAAsBoD,OAAtB,EAA+Bc,IAA/B,EAAqC;AACnC;AACA,MAAIlE,OAAO,CAACa,aAAZ,EAA2B;AACzBb,IAAAA,OAAO,CAACmE,eAAR,GAA0B,KAA1B;AACD;;AACD,MAAI,CAACnE,OAAO,CAACoE,SAAT,IAAsB,CAACpE,OAAO,CAACmE,eAAnC,EAAoD;AAClDnE,IAAAA,OAAO,CAACa,aAAR,GAAwB,IAAxB;AACD,GAPkC,CASnC;;;AACA,MAAIwD,SAAS,CAAChD,MAAV,GAAmB,CAAvB,EAA0B;AACxB7B,IAAAA,MAAM,CAACU,KAAP,CAAa,gCAAb;AACD,GAFD,MAEO;AACLkD,IAAAA,OAAO,GAAG,GAAGG,KAAH,CAASe,IAAT,CAAcD,SAAd,EAAyB,CAAzB,EAA4BA,SAAS,CAAChD,MAAV,GAAmB,CAA/C,CAAV;AACA6C,IAAAA,IAAI,GAAGG,SAAS,CAACA,SAAS,CAAChD,MAAV,GAAmB,CAApB,CAAhB;AACD;;AAED,MAAIkD,UAAU,GAAGlF,EAAE,CAACY,UAAH,CAAciE,IAAd,CAAjB;AACA,MAAIM,QAAQ,GAAGD,UAAU,IAAI/E,MAAM,CAACe,eAAP,CAAuB2D,IAAvB,CAA7B,CAlBmC,CAoBnC;;AACA,MAAI,CAAC,CAACK,UAAD,IAAe,CAACC,QAAQ,CAACzB,WAAT,EAAjB,KAA4CK,OAAO,CAAC/B,MAAR,GAAiB,CAAjE,EAAoE;AAClE7B,IAAAA,MAAM,CAACU,KAAP,CAAa,4CAAb;AACD,GAvBkC,CAyBnC;;;AACA,MAAIqE,UAAU,IAAIC,QAAQ,CAACC,MAAT,EAAd,IAAmCzE,OAAO,CAACgD,QAA/C,EAAyD;AACvD,WAAO,IAAIxD,MAAM,CAACkF,WAAX,CAAuB,EAAvB,EAA2B,EAA3B,EAA+B,CAA/B,CAAP;AACD;;AAEDtB,EAAAA,OAAO,CAACuB,OAAR,CAAgB,UAAUlB,GAAV,EAAemB,QAAf,EAAyB;AACvC,QAAI,CAACvF,EAAE,CAACY,UAAH,CAAcwD,GAAd,CAAL,EAAyB;AACvB,UAAIA,GAAG,KAAK,EAAZ,EAAgBA,GAAG,GAAG,IAAN,CADO,CACK;;AAC5BjE,MAAAA,MAAM,CAACU,KAAP,CAAa,gCAAgCuD,GAA7C,EAAkD;AAAEoB,QAAAA,QAAQ,EAAE;AAAZ,OAAlD;AACA,aAHuB,CAGf;AACT;;AACD,QAAIC,OAAO,GAAGtF,MAAM,CAACe,eAAP,CAAuBkD,GAAvB,CAAd;;AACA,QAAI,CAACzD,OAAO,CAACmE,eAAT,IAA4BW,OAAO,CAAC/B,WAAR,EAAhC,EAAuD;AACrD,UAAI,CAAC/C,OAAO,CAACoE,SAAb,EAAwB;AACtB;AACA5E,QAAAA,MAAM,CAACU,KAAP,CAAa,yBAAyBuD,GAAzB,GAA+B,GAA5C,EAAiD;AAAEoB,UAAAA,QAAQ,EAAE;AAAZ,SAAjD;AACD,OAHD,MAGO;AACL;AACA;AACA,YAAIE,OAAO,GAAIP,QAAQ,IAAIA,QAAQ,CAACzB,WAAT,EAAb,GACVxD,IAAI,CAACyF,IAAL,CAAUd,IAAV,EAAgB3E,IAAI,CAACmE,QAAL,CAAcD,GAAd,CAAhB,CADU,GAEVS,IAFJ;;AAIA,YAAI;AACF1E,UAAAA,MAAM,CAACe,eAAP,CAAuBhB,IAAI,CAAC0F,OAAL,CAAaf,IAAb,CAAvB;AACAjC,UAAAA,kBAAkB,CAACwB,GAAD,EAAMsB,OAAN,EAAe,CAAf,EAAkB;AAAE/B,YAAAA,QAAQ,EAAEhD,OAAO,CAACgD,QAApB;AAA8BnC,YAAAA,aAAa,EAAEb,OAAO,CAACa;AAArD,WAAlB,CAAlB;AACD,SAHD,CAGE,OAAOH,CAAP,EAAU;AACV;AACAlB,UAAAA,MAAM,CAACU,KAAP,CAAa,8BAA8BgE,IAA9B,GAAqC,8BAAlD;AACD;AACF;AACF,KAnBD,MAmBO;AACL;AAEA;AACA;AACA,UAAIgB,QAAQ,GAAGhB,IAAf;;AACA,UAAIM,QAAQ,IAAIA,QAAQ,CAACzB,WAAT,EAAhB,EAAwC;AACtCmC,QAAAA,QAAQ,GAAG3F,IAAI,CAAC4F,SAAL,CAAejB,IAAI,GAAG,GAAP,GAAa3E,IAAI,CAACmE,QAAL,CAAcD,GAAd,CAA5B,CAAX;AACD;;AAED,UAAI2B,cAAc,GAAG/F,EAAE,CAACY,UAAH,CAAciF,QAAd,CAArB;;AACA,UAAIE,cAAc,IAAIjC,kBAAkB,CAACC,OAAD,EAAUwB,QAAV,CAAxC,EAA6D;AAC3D;AACA,YAAI,CAAC5E,OAAO,CAACgD,QAAb,EAAuB;AACrBxD,UAAAA,MAAM,CAACU,KAAP,CAAa,sCAAsCgF,QAAtC,GAAiD,UAAjD,GAA8DzB,GAA9D,GAAoE,GAAjF,EAAsF;AAAEoB,YAAAA,QAAQ,EAAE;AAAZ,WAAtF;AACD;;AACD;AACD;;AAED,UAAIO,cAAc,IAAIpF,OAAO,CAACgD,QAA9B,EAAwC;AACtC,eADsC,CAC9B;AACT;;AAED,UAAIzD,IAAI,CAAC8F,QAAL,CAAc5B,GAAd,EAAmByB,QAAnB,MAAiC,EAArC,EAAyC;AACvC;AACA1F,QAAAA,MAAM,CAACU,KAAP,CAAa,MAAMgF,QAAN,GAAiB,SAAjB,GAA6BzB,GAA7B,GAAmC,qBAAhD,EAAuE;AAAEoB,UAAAA,QAAQ,EAAE;AAAZ,SAAvE;AACA;AACD;;AAEDhF,MAAAA,YAAY,CAAC4D,GAAD,EAAMyB,QAAN,EAAgBlF,OAAhB,CAAZ;AACD;AACF,GAzDD,EA9BmC,CAuF/B;;AAEJ,SAAO,IAAIR,MAAM,CAACkF,WAAX,CAAuB,EAAvB,EAA2BlF,MAAM,CAAC8F,KAAP,CAAapF,KAAxC,EAA+CV,MAAM,CAAC8F,KAAP,CAAaC,SAA5D,CAAP;AACD;;AACDC,MAAM,CAACC,OAAP,GAAiB/F,GAAjB","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink',\n  },\n  wrapOutput: false,\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", { continue: true });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = (destStat && destStat.isDirectory()) ?\n            path.join(dest, path.basename(src)) :\n            dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n        }\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", { continue: true });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n"]},"metadata":{},"sourceType":"script"}