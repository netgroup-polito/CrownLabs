{"ast":null,"code":"/**\n * deps/ecc/math.js - Elliptic Curve Math\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\"use strict\"; // Basic Javascript Elliptic Curve implementation\n// Ported loosely from BouncyCastle's Java EC code\n// Only Fp curves implemented for now\n\nvar BigInteger = require(\"../../deps/forge\").jsbn.BigInteger; // ----------------\n// Helpers\n\n\nfunction nbi() {\n  return new BigInteger(null);\n} // ----------------\n// Barrett modular reduction\n// constructor\n\n\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);else if (x.compareTo(this.m) < 0) return x;else {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n}\n\nfunction barrettRevert(x) {\n  return x;\n} // x = x mod m (HAC 14.42)\n\n\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t - 1, this.r2);\n\n  if (x.t > this.m.t + 1) {\n    x.t = this.m.t + 1;\n    x.clamp();\n  }\n\n  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\n  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\n  x.subTo(this.r2, x);\n\n  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n} // r = x^2 mod m; x != r\n\n\nfunction barrettSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n} // r = x*y mod m; x,y != r\n\n\nfunction barrettMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo; // ----------------\n// ECFieldElementFp\n// constructor\n\nfunction ECFieldElementFp(q, x) {\n  this.x = x; // TODO if(x.compareTo(q) >= 0) error\n\n  this.p = q;\n}\n\nfunction feFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n\n  return this.p.equals(other.p) && this.x.equals(other.x);\n}\n\nfunction feFpToBigInteger() {\n  return this.x;\n}\n\nfunction feFpNegate() {\n  return new ECFieldElementFp(this.p, this.x.negate().mod(this.p));\n}\n\nfunction feFpAdd(b) {\n  return new ECFieldElementFp(this.p, this.x.add(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSubtract(b) {\n  return new ECFieldElementFp(this.p, this.x.subtract(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpMultiply(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSquare() {\n  return new ECFieldElementFp(this.p, this.x.pow(2).mod(this.p));\n}\n\nfunction feFpDivide(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger().modInverse(this.p)).mod(this.p));\n}\n\nECFieldElementFp.prototype.equals = feFpEquals;\nECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;\nECFieldElementFp.prototype.negate = feFpNegate;\nECFieldElementFp.prototype.add = feFpAdd;\nECFieldElementFp.prototype.subtract = feFpSubtract;\nECFieldElementFp.prototype.multiply = feFpMultiply;\nECFieldElementFp.prototype.square = feFpSquare;\nECFieldElementFp.prototype.divide = feFpDivide; // ----------------\n// ECPointFp\n// constructor\n\nfunction ECPointFp(curve, x, y, z) {\n  this.curve = curve;\n  this.x = x;\n  this.y = y; // Projective coordinates: either zinv == null or z * zinv == 1\n  // z and zinv are just BigIntegers, not fieldElements\n\n  if (!z) {\n    this.z = BigInteger.ONE;\n  } else {\n    this.z = z;\n  }\n\n  this.zinv = null; //TODO: compression flag\n}\n\nfunction pointFpGetX() {\n  if (!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n\n  var r = this.x.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpGetY() {\n  if (!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n\n  var r = this.y.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n\n  if (this.isInfinity()) {\n    return other.isInfinity();\n  }\n\n  if (other.isInfinity()) {\n    return this.isInfinity();\n  }\n\n  var u, v; // u = Y2 * Z1 - Y1 * Z2\n\n  u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.p);\n\n  if (!u.equals(BigInteger.ZERO)) {\n    return false;\n  } // v = X2 * Z1 - X1 * Z2\n\n\n  v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  return v.equals(BigInteger.ZERO);\n}\n\nfunction pointFpIsInfinity() {\n  if (this.x == null && this.y == null) {\n    return true;\n  }\n\n  return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);\n}\n\nfunction pointFpNegate() {\n  return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\n}\n\nfunction pointFpAdd(b) {\n  if (this.isInfinity()) {\n    return b;\n  }\n\n  if (b.isInfinity()) {\n    return this;\n  } // u = Y2 * Z1 - Y1 * Z2\n\n\n  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.p); // v = X2 * Z1 - X1 * Z2\n\n  var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.p);\n\n  if (BigInteger.ZERO.equals(v)) {\n    if (BigInteger.ZERO.equals(u)) {\n      return this.twice(); // this == b, so double\n    }\n\n    return this.curve.getInfinity(); // this = -b, so infinity\n  }\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n  var v2 = v.pow(2);\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.pow(2).multiply(this.z); // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p); // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p); // z3 = v^3 * z1 * z2\n\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\nfunction pointFpTwice() {\n  if (this.isInfinity()) {\n    return this;\n  }\n\n  if (this.y.toBigInteger().signum() === 0) {\n    return this.curve.getInfinity();\n  } // TODO: optimized handling of constants\n\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n  var y1z1 = y1.multiply(this.z);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a.toBigInteger(); // w = 3 * x1^2 + a * z1^2\n\n  var w = x1.pow(2).multiply(THREE);\n\n  if (!BigInteger.ZERO.equals(a)) {\n    w = w.add(this.z.pow(2).multiply(a));\n  }\n\n  w = w.mod(this.curve.p); //this.curve.reduce(w);\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n\n  var x3 = w.pow(2).subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p); // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(2).multiply(w)).mod(this.curve.p); // z3 = 8 * (y1 * z1)^3\n\n  var z3 = y1z1.pow(2).multiply(y1z1).shiftLeft(3).mod(this.curve.p);\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n} // Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\n\n\nfunction pointFpMultiply(k) {\n  if (this.isInfinity()) {\n    return this;\n  }\n\n  if (k.signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n  var neg = this.negate();\n  var R = this;\n  var i;\n\n  for (i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n} // Compute this*j + x*k (simultaneous multiplication)\n\n\nfunction pointFpMultiplyTwo(j, x, k) {\n  var i;\n\n  if (j.bitLength() > k.bitLength()) {\n    i = j.bitLength() - 1;\n  } else {\n    i = k.bitLength() - 1;\n  }\n\n  var R = this.curve.getInfinity();\n  var both = this.add(x);\n\n  while (i >= 0) {\n    R = R.twice();\n\n    if (j.testBit(i)) {\n      if (k.testBit(i)) {\n        R = R.add(both);\n      } else {\n        R = R.add(this);\n      }\n    } else {\n      if (k.testBit(i)) {\n        R = R.add(x);\n      }\n    }\n\n    --i;\n  }\n\n  return R;\n}\n\nECPointFp.prototype.getX = pointFpGetX;\nECPointFp.prototype.getY = pointFpGetY;\nECPointFp.prototype.equals = pointFpEquals;\nECPointFp.prototype.isInfinity = pointFpIsInfinity;\nECPointFp.prototype.negate = pointFpNegate;\nECPointFp.prototype.add = pointFpAdd;\nECPointFp.prototype.twice = pointFpTwice;\nECPointFp.prototype.multiply = pointFpMultiply;\nECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo; // ----------------\n// ECCurveFp\n// constructor\n\nfunction ECCurveFp(p, a, b) {\n  this.p = p;\n  this.a = this.fromBigInteger(a);\n  this.b = this.fromBigInteger(b);\n  this.infinity = new ECPointFp(this, null, null);\n  this.reducer = new Barrett(this.p);\n}\n\nfunction curveFpgetP() {\n  return this.p;\n}\n\nfunction curveFpGetA() {\n  return this.a;\n}\n\nfunction curveFpGetB() {\n  return this.b;\n}\n\nfunction curveFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n\n  return this.p.equals(other.p) && this.a.equals(other.a) && this.b.equals(other.b);\n}\n\nfunction curveFpContains(pt) {\n  // y^2 = x^3 + a*x + b mod p\n  var x = pt.getX().toBigInteger(),\n      y = pt.getY().toBigInteger(),\n      a = this.a.toBigInteger(),\n      b = this.b.toBigInteger(),\n      p = this.p;\n  var left = y.pow(2).mod(p),\n      right = x.pow(3).add(a.multiply(x)).add(b).mod(p);\n  return left.equals(right);\n}\n\nfunction curveFpGetInfinity() {\n  return this.infinity;\n}\n\nfunction curveFpFromBigInteger(x) {\n  return new ECFieldElementFp(this.p, x);\n}\n\nfunction curveReduce(x) {\n  this.reducer.reduce(x);\n} // for now, work with hex strings because they're easier in JS\n\n\nfunction curveFpDecodePointHex(s) {\n  switch (parseInt(s.substring(0, 2), 16)) {\n    // first byte\n    case 0:\n      return this.infinity;\n\n    case 2:\n    case 3:\n      // point compression not supported yet\n      return null;\n\n    case 4:\n    case 6:\n    case 7:\n      var len = (s.length - 2) / 2;\n      var xHex = s.substr(2, len);\n      var yHex = s.substr(len + 2, len);\n      return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));\n\n    default:\n      // unsupported\n      return null;\n  }\n}\n\nfunction curveFpEncodePointHex(p) {\n  if (p.isInfinity()) {\n    return \"00\";\n  }\n\n  var xHex = p.getX().toBigInteger().toString(16);\n  var yHex = p.getY().toBigInteger().toString(16);\n  var oLen = this.getP().toString(16).length;\n\n  if (oLen % 2 !== 0) {\n    oLen++;\n  }\n\n  while (xHex.length < oLen) {\n    xHex = \"0\" + xHex;\n  }\n\n  while (yHex.length < oLen) {\n    yHex = \"0\" + yHex;\n  }\n\n  return \"04\" + xHex + yHex;\n}\n\nECCurveFp.prototype.getP = curveFpgetP;\nECCurveFp.prototype.getA = curveFpGetA;\nECCurveFp.prototype.getB = curveFpGetB;\nECCurveFp.prototype.equals = curveFpEquals;\nECCurveFp.prototype.contains = curveFpContains;\nECCurveFp.prototype.getInfinity = curveFpGetInfinity;\nECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;\nECCurveFp.prototype.reduce = curveReduce;\nECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;\nECCurveFp.prototype.encodePointHex = curveFpEncodePointHex; // Exports\n\nmodule.exports = {\n  ECFieldElementFp: ECFieldElementFp,\n  ECPointFp: ECPointFp,\n  ECCurveFp: ECCurveFp\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/deps/ecc/math.js"],"names":["BigInteger","require","jsbn","nbi","Barrett","m","r2","q3","ONE","dlShiftTo","t","mu","divide","barrettConvert","x","s","mod","compareTo","r","copyTo","reduce","barrettRevert","barrettReduce","drShiftTo","clamp","multiplyUpperTo","multiplyLowerTo","dAddOffset","subTo","barrettSqrTo","squareTo","barrettMulTo","y","multiplyTo","prototype","convert","revert","mulTo","sqrTo","ECFieldElementFp","q","p","feFpEquals","other","equals","feFpToBigInteger","feFpNegate","negate","feFpAdd","b","add","toBigInteger","feFpSubtract","subtract","feFpMultiply","multiply","feFpSquare","pow","feFpDivide","modInverse","square","ECPointFp","curve","z","zinv","pointFpGetX","fromBigInteger","pointFpGetY","pointFpEquals","isInfinity","u","v","ZERO","pointFpIsInfinity","pointFpNegate","pointFpAdd","twice","getInfinity","THREE","x1","y1","v2","v3","x1v2","zu2","x3","shiftLeft","y3","z3","pointFpTwice","signum","y1z1","y1sqz1","a","w","pointFpMultiply","k","e","h","neg","R","i","bitLength","hBit","testBit","eBit","pointFpMultiplyTwo","j","both","getX","getY","multiplyTwo","ECCurveFp","infinity","reducer","curveFpgetP","curveFpGetA","curveFpGetB","curveFpEquals","curveFpContains","pt","left","right","curveFpGetInfinity","curveFpFromBigInteger","curveReduce","curveFpDecodePointHex","parseInt","substring","len","length","xHex","substr","yHex","curveFpEncodePointHex","toString","oLen","getP","getA","getB","contains","decodePointHex","encodePointHex","module","exports"],"mappings":"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","sourcesContent":["/**\n * deps/ecc/math.js - Elliptic Curve Math\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\"use strict\";\n\n// Basic Javascript Elliptic Curve implementation\n// Ported loosely from BouncyCastle's Java EC code\n// Only Fp curves implemented for now\n\nvar BigInteger = require(\"../../deps/forge\").jsbn.BigInteger;\n\n// ----------------\n// Helpers\n\nfunction nbi() {\n  return new BigInteger(null);\n}\n\n// ----------------\n// Barrett modular reduction\n\n// constructor\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// ----------------\n// ECFieldElementFp\n\n// constructor\nfunction ECFieldElementFp(q, x) {\n  this.x = x;\n  // TODO if(x.compareTo(q) >= 0) error\n  this.p = q;\n}\n\nfunction feFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.x.equals(other.x));\n}\n\nfunction feFpToBigInteger() {\n  return this.x;\n}\n\nfunction feFpNegate() {\n  return new ECFieldElementFp(this.p, this.x.negate().mod(this.p));\n}\n\nfunction feFpAdd(b) {\n  return new ECFieldElementFp(this.p, this.x.add(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSubtract(b) {\n  return new ECFieldElementFp(this.p, this.x.subtract(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpMultiply(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSquare() {\n  return new ECFieldElementFp(this.p, this.x.pow(2).mod(this.p));\n}\n\nfunction feFpDivide(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger().modInverse(this.p)).mod(this.p));\n}\n\nECFieldElementFp.prototype.equals = feFpEquals;\nECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;\nECFieldElementFp.prototype.negate = feFpNegate;\nECFieldElementFp.prototype.add = feFpAdd;\nECFieldElementFp.prototype.subtract = feFpSubtract;\nECFieldElementFp.prototype.multiply = feFpMultiply;\nECFieldElementFp.prototype.square = feFpSquare;\nECFieldElementFp.prototype.divide = feFpDivide;\n\n// ----------------\n// ECPointFp\n\n// constructor\nfunction ECPointFp(curve, x, y, z) {\n  this.curve = curve;\n  this.x = x;\n  this.y = y;\n  // Projective coordinates: either zinv == null or z * zinv == 1\n  // z and zinv are just BigIntegers, not fieldElements\n  if (!z) {\n    this.z = BigInteger.ONE;\n  } else {\n    this.z = z;\n  }\n  this.zinv = null;\n  //TODO: compression flag\n}\n\nfunction pointFpGetX() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.x.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpGetY() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.y.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  if (this.isInfinity()) {\n    return other.isInfinity();\n  }\n  if (other.isInfinity()) {\n    return this.isInfinity();\n  }\n  var u, v;\n  // u = Y2 * Z1 - Y1 * Z2\n  u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  if (!u.equals(BigInteger.ZERO)) {\n    return false;\n  }\n  // v = X2 * Z1 - X1 * Z2\n  v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  return v.equals(BigInteger.ZERO);\n}\n\nfunction pointFpIsInfinity() {\n  if ((this.x == null) && (this.y == null)) {\n    return true;\n  }\n  return (this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO));\n}\n\nfunction pointFpNegate() {\n    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\n}\n\nfunction pointFpAdd(b) {\n  if (this.isInfinity()) {\n    return b;\n  }\n  if (b.isInfinity()) {\n    return this;\n  }\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.p);\n  // v = X2 * Z1 - X1 * Z2\n  var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.p);\n\n  if (BigInteger.ZERO.equals(v)) {\n    if (BigInteger.ZERO.equals(u)) {\n      return this.twice(); // this == b, so double\n    }\n    return this.curve.getInfinity(); // this = -b, so infinity\n  }\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var v2 = v.pow(2);\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.pow(2).multiply(this.z);\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p);\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p);\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\nfunction pointFpTwice() {\n  if(this.isInfinity()) {\n    return this;\n  }\n  if (this.y.toBigInteger().signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  // TODO: optimized handling of constants\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var y1z1 = y1.multiply(this.z);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a.toBigInteger();\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.pow(2).multiply(THREE);\n  if (!BigInteger.ZERO.equals(a)) {\n    w = w.add(this.z.pow(2).multiply(a));\n  }\n  w = w.mod(this.curve.p);\n  //this.curve.reduce(w);\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.pow(2).subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(2).multiply(w)).mod(this.curve.p);\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(2).multiply(y1z1).shiftLeft(3).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nfunction pointFpMultiply(k) {\n  if (this.isInfinity()) {\n    return this;\n  }\n  if (k.signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n\n  var neg = this.negate();\n  var R = this;\n\n  var i;\n  for(i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nfunction pointFpMultiplyTwo(j, x, k) {\n  var i;\n  if (j.bitLength() > k.bitLength()) {\n    i = j.bitLength() - 1;\n  } else {\n    i = k.bitLength() - 1;\n  }\n\n  var R = this.curve.getInfinity();\n  var both = this.add(x);\n  while (i >= 0) {\n    R = R.twice();\n    if (j.testBit(i)) {\n      if (k.testBit(i)) {\n        R = R.add(both);\n      }\n      else {\n        R = R.add(this);\n      }\n    }\n    else {\n      if (k.testBit(i)) {\n        R = R.add(x);\n      }\n    }\n    --i;\n  }\n\n  return R;\n}\n\nECPointFp.prototype.getX = pointFpGetX;\nECPointFp.prototype.getY = pointFpGetY;\nECPointFp.prototype.equals = pointFpEquals;\nECPointFp.prototype.isInfinity = pointFpIsInfinity;\nECPointFp.prototype.negate = pointFpNegate;\nECPointFp.prototype.add = pointFpAdd;\nECPointFp.prototype.twice = pointFpTwice;\nECPointFp.prototype.multiply = pointFpMultiply;\nECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;\n\n// ----------------\n// ECCurveFp\n\n// constructor\nfunction ECCurveFp(p, a, b) {\n  this.p = p;\n  this.a = this.fromBigInteger(a);\n  this.b = this.fromBigInteger(b);\n  this.infinity = new ECPointFp(this, null, null);\n  this.reducer = new Barrett(this.p);\n}\n\nfunction curveFpgetP() {\n  return this.p;\n}\n\nfunction curveFpGetA() {\n  return this.a;\n}\n\nfunction curveFpGetB() {\n  return this.b;\n}\n\nfunction curveFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.a.equals(other.a) && this.b.equals(other.b));\n}\n\nfunction curveFpContains(pt) {\n  // y^2 = x^3 + a*x + b mod p\n  var x = pt.getX().toBigInteger(),\n      y = pt.getY().toBigInteger(),\n      a = this.a.toBigInteger(),\n      b = this.b.toBigInteger(),\n      p = this.p;\n\n  var left = y.pow(2).mod(p),\n      right = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n\n  return left.equals(right);\n}\n\nfunction curveFpGetInfinity() {\n  return this.infinity;\n}\n\nfunction curveFpFromBigInteger(x) {\n  return new ECFieldElementFp(this.p, x);\n}\n\nfunction curveReduce(x) {\n  this.reducer.reduce(x);\n}\n\n// for now, work with hex strings because they're easier in JS\nfunction curveFpDecodePointHex(s) {\n  switch (parseInt(s.substring(0, 2), 16)) {\n    // first byte\n    case 0:\n      return this.infinity;\n    case 2:\n    case 3:\n      // point compression not supported yet\n      return null;\n    case 4:\n    case 6:\n    case 7:\n      var len = (s.length - 2) / 2;\n      var xHex = s.substr(2, len);\n      var yHex = s.substr(len + 2, len);\n\n      return new ECPointFp(this,\n                           this.fromBigInteger(new BigInteger(xHex, 16)),\n                           this.fromBigInteger(new BigInteger(yHex, 16)));\n\n    default: // unsupported\n      return null;\n    }\n}\n\nfunction curveFpEncodePointHex(p) {\n  if (p.isInfinity()) {\n    return \"00\";\n  }\n  var xHex = p.getX().toBigInteger().toString(16);\n  var yHex = p.getY().toBigInteger().toString(16);\n  var oLen = this.getP().toString(16).length;\n  if ((oLen % 2) !== 0) {\n    oLen++;\n  }\n  while (xHex.length < oLen) {\n    xHex = \"0\" + xHex;\n  }\n  while (yHex.length < oLen) {\n    yHex = \"0\" + yHex;\n  }\n  return \"04\" + xHex + yHex;\n}\n\nECCurveFp.prototype.getP = curveFpgetP;\nECCurveFp.prototype.getA = curveFpGetA;\nECCurveFp.prototype.getB = curveFpGetB;\nECCurveFp.prototype.equals = curveFpEquals;\nECCurveFp.prototype.contains = curveFpContains;\nECCurveFp.prototype.getInfinity = curveFpGetInfinity;\nECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;\nECCurveFp.prototype.reduce = curveReduce;\nECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;\nECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;\n\n// Exports\nmodule.exports = {\n  ECFieldElementFp: ECFieldElementFp,\n  ECPointFp: ECPointFp,\n  ECCurveFp: ECCurveFp\n};\n"]},"metadata":{},"sourceType":"script"}