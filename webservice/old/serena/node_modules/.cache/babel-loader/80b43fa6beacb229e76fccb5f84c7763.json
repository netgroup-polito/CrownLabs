{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar Transform = require('stream').Transform;\n\nvar inherits = require('inherits');\n\nfunction throwIfNotStringOrBuffer(val, prefix) {\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\n    throw new TypeError(prefix + ' must be a string or a buffer');\n  }\n}\n\nfunction HashBase(blockSize) {\n  Transform.call(this);\n  this._block = Buffer.allocUnsafe(blockSize);\n  this._blockSize = blockSize;\n  this._blockOffset = 0;\n  this._length = [0, 0, 0, 0];\n  this._finalized = false;\n}\n\ninherits(HashBase, Transform);\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null;\n\n  try {\n    this.update(chunk, encoding);\n  } catch (err) {\n    error = err;\n  }\n\n  callback(error);\n};\n\nHashBase.prototype._flush = function (callback) {\n  var error = null;\n\n  try {\n    this.push(this.digest());\n  } catch (err) {\n    error = err;\n  }\n\n  callback(error);\n};\n\nHashBase.prototype.update = function (data, encoding) {\n  throwIfNotStringOrBuffer(data, 'Data');\n  if (this._finalized) throw new Error('Digest already called');\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data\n\n  var block = this._block;\n  var offset = 0;\n\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];\n\n    this._update();\n\n    this._blockOffset = 0;\n  }\n\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length\n\n\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry;\n    carry = this._length[j] / 0x0100000000 | 0;\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry;\n  }\n\n  return this;\n};\n\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented');\n};\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called');\n  this._finalized = true;\n\n  var digest = this._digest();\n\n  if (encoding !== undefined) digest = digest.toString(encoding); // reset state\n\n  this._block.fill(0);\n\n  this._blockOffset = 0;\n\n  for (var i = 0; i < 4; ++i) this._length[i] = 0;\n\n  return digest;\n};\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented');\n};\n\nmodule.exports = HashBase;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/hash-base/index.js"],"names":["Buffer","require","Transform","inherits","throwIfNotStringOrBuffer","val","prefix","isBuffer","TypeError","HashBase","blockSize","call","_block","allocUnsafe","_blockSize","_blockOffset","_length","_finalized","prototype","_transform","chunk","encoding","callback","error","update","err","_flush","push","digest","data","Error","from","block","offset","length","i","_update","j","carry","_digest","undefined","toString","fill","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nvar Buffer = require('safe-buffer').Buffer\nvar Transform = require('stream').Transform\nvar inherits = require('inherits')\n\nfunction throwIfNotStringOrBuffer (val, prefix) {\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\n    throw new TypeError(prefix + ' must be a string or a buffer')\n  }\n}\n\nfunction HashBase (blockSize) {\n  Transform.call(this)\n\n  this._block = Buffer.allocUnsafe(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\ninherits(HashBase, Transform)\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null\n  try {\n    this.update(chunk, encoding)\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype._flush = function (callback) {\n  var error = null\n  try {\n    this.push(this.digest())\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype.update = function (data, encoding) {\n  throwIfNotStringOrBuffer(data, 'Data')\n  if (this._finalized) throw new Error('Digest already called')\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n  // consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] / 0x0100000000) | 0\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented')\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called')\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n\n  // reset state\n  this._block.fill(0)\n  this._blockOffset = 0\n  for (var i = 0; i < 4; ++i) this._length[i] = 0\n\n  return digest\n}\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented')\n}\n\nmodule.exports = HashBase\n"]},"metadata":{},"sourceType":"script"}