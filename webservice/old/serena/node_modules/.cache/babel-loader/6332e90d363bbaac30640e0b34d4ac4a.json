{"ast":null,"code":"/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */\nvar forge = require('./forge');\n\nrequire('./util'); // shortcut for pem API\n\n\nvar pem = module.exports = forge.pem = forge.pem || {};\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */\n\npem.encode = function (msg, options) {\n  options = options || {};\n  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n'; // encode special headers\n\n  var header;\n\n  if (msg.procType) {\n    header = {\n      name: 'Proc-Type',\n      values: [String(msg.procType.version), msg.procType.type]\n    };\n    rval += foldHeader(header);\n  }\n\n  if (msg.contentDomain) {\n    header = {\n      name: 'Content-Domain',\n      values: [msg.contentDomain]\n    };\n    rval += foldHeader(header);\n  }\n\n  if (msg.dekInfo) {\n    header = {\n      name: 'DEK-Info',\n      values: [msg.dekInfo.algorithm]\n    };\n\n    if (msg.dekInfo.parameters) {\n      header.values.push(msg.dekInfo.parameters);\n    }\n\n    rval += foldHeader(header);\n  }\n\n  if (msg.headers) {\n    // encode all other headers\n    for (var i = 0; i < msg.headers.length; ++i) {\n      rval += foldHeader(msg.headers[i]);\n    }\n  } // terminate header\n\n\n  if (msg.procType) {\n    rval += '\\r\\n';\n  } // add body\n\n\n  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\n  rval += '-----END ' + msg.type + '-----\\r\\n';\n  return rval;\n};\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */\n\n\npem.decode = function (str) {\n  var rval = []; // split string into PEM messages (be lenient w/EOF on BEGIN line)\n\n  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n  var rCRLF = /\\r?\\n/;\n  var match;\n\n  while (true) {\n    match = rMessage.exec(str);\n\n    if (!match) {\n      break;\n    }\n\n    var msg = {\n      type: match[1],\n      procType: null,\n      contentDomain: null,\n      dekInfo: null,\n      headers: [],\n      body: forge.util.decode64(match[3])\n    };\n    rval.push(msg); // no headers\n\n    if (!match[2]) {\n      continue;\n    } // parse headers\n\n\n    var lines = match[2].split(rCRLF);\n    var li = 0;\n\n    while (match && li < lines.length) {\n      // get line, trim any rhs whitespace\n      var line = lines[li].replace(/\\s+$/, ''); // RFC2822 unfold any following folded lines\n\n      for (var nl = li + 1; nl < lines.length; ++nl) {\n        var next = lines[nl];\n\n        if (!/\\s/.test(next[0])) {\n          break;\n        }\n\n        line += next;\n        li = nl;\n      } // parse header\n\n\n      match = line.match(rHeader);\n\n      if (match) {\n        var header = {\n          name: match[1],\n          values: []\n        };\n        var values = match[2].split(',');\n\n        for (var vi = 0; vi < values.length; ++vi) {\n          header.values.push(ltrim(values[vi]));\n        } // Proc-Type must be the first header\n\n\n        if (!msg.procType) {\n          if (header.name !== 'Proc-Type') {\n            throw new Error('Invalid PEM formatted message. The first ' + 'encapsulated header must be \"Proc-Type\".');\n          } else if (header.values.length !== 2) {\n            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' + 'header must have two subfields.');\n          }\n\n          msg.procType = {\n            version: values[0],\n            type: values[1]\n          };\n        } else if (!msg.contentDomain && header.name === 'Content-Domain') {\n          // special-case Content-Domain\n          msg.contentDomain = values[0] || '';\n        } else if (!msg.dekInfo && header.name === 'DEK-Info') {\n          // special-case DEK-Info\n          if (header.values.length === 0) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must have at least one subfield.');\n          }\n\n          msg.dekInfo = {\n            algorithm: values[0],\n            parameters: values[1] || null\n          };\n        } else {\n          msg.headers.push(header);\n        }\n      }\n\n      ++li;\n    }\n\n    if (msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\n      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n    }\n  }\n\n  if (rval.length === 0) {\n    throw new Error('Invalid PEM formatted message.');\n  }\n\n  return rval;\n};\n\nfunction foldHeader(header) {\n  var rval = header.name + ': '; // ensure values with CRLF are folded\n\n  var values = [];\n\n  var insertSpace = function (match, $1) {\n    return ' ' + $1;\n  };\n\n  for (var i = 0; i < header.values.length; ++i) {\n    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n  }\n\n  rval += values.join(',') + '\\r\\n'; // do folding\n\n  var length = 0;\n  var candidate = -1;\n\n  for (var i = 0; i < rval.length; ++i, ++length) {\n    if (length > 65 && candidate !== -1) {\n      var insert = rval[candidate];\n\n      if (insert === ',') {\n        ++candidate;\n        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\n      } else {\n        rval = rval.substr(0, candidate) + '\\r\\n' + insert + rval.substr(candidate + 1);\n      }\n\n      length = i - candidate - 1;\n      candidate = -1;\n      ++i;\n    } else if (rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\n      candidate = i;\n    }\n  }\n\n  return rval;\n}\n\nfunction ltrim(str) {\n  return str.replace(/^\\s+/, '');\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/pem.js"],"names":["forge","require","pem","module","exports","encode","msg","options","rval","type","header","procType","name","values","String","version","foldHeader","contentDomain","dekInfo","algorithm","parameters","push","headers","i","length","util","encode64","body","maxline","decode","str","rMessage","rHeader","rCRLF","match","exec","decode64","lines","split","li","line","replace","nl","next","test","vi","ltrim","Error","insertSpace","$1","join","candidate","insert","substr"],"mappings":"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","sourcesContent":["/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */\npem.encode = function(msg, options) {\n  options = options || {};\n  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\n\n  // encode special headers\n  var header;\n  if(msg.procType) {\n    header = {\n      name: 'Proc-Type',\n      values: [String(msg.procType.version), msg.procType.type]\n    };\n    rval += foldHeader(header);\n  }\n  if(msg.contentDomain) {\n    header = {name: 'Content-Domain', values: [msg.contentDomain]};\n    rval += foldHeader(header);\n  }\n  if(msg.dekInfo) {\n    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};\n    if(msg.dekInfo.parameters) {\n      header.values.push(msg.dekInfo.parameters);\n    }\n    rval += foldHeader(header);\n  }\n\n  if(msg.headers) {\n    // encode all other headers\n    for(var i = 0; i < msg.headers.length; ++i) {\n      rval += foldHeader(msg.headers[i]);\n    }\n  }\n\n  // terminate header\n  if(msg.procType) {\n    rval += '\\r\\n';\n  }\n\n  // add body\n  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\n\n  rval += '-----END ' + msg.type + '-----\\r\\n';\n  return rval;\n};\n\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */\npem.decode = function(str) {\n  var rval = [];\n\n  // split string into PEM messages (be lenient w/EOF on BEGIN line)\n  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n  var rCRLF = /\\r?\\n/;\n  var match;\n  while(true) {\n    match = rMessage.exec(str);\n    if(!match) {\n      break;\n    }\n\n    var msg = {\n      type: match[1],\n      procType: null,\n      contentDomain: null,\n      dekInfo: null,\n      headers: [],\n      body: forge.util.decode64(match[3])\n    };\n    rval.push(msg);\n\n    // no headers\n    if(!match[2]) {\n      continue;\n    }\n\n    // parse headers\n    var lines = match[2].split(rCRLF);\n    var li = 0;\n    while(match && li < lines.length) {\n      // get line, trim any rhs whitespace\n      var line = lines[li].replace(/\\s+$/, '');\n\n      // RFC2822 unfold any following folded lines\n      for(var nl = li + 1; nl < lines.length; ++nl) {\n        var next = lines[nl];\n        if(!/\\s/.test(next[0])) {\n          break;\n        }\n        line += next;\n        li = nl;\n      }\n\n      // parse header\n      match = line.match(rHeader);\n      if(match) {\n        var header = {name: match[1], values: []};\n        var values = match[2].split(',');\n        for(var vi = 0; vi < values.length; ++vi) {\n          header.values.push(ltrim(values[vi]));\n        }\n\n        // Proc-Type must be the first header\n        if(!msg.procType) {\n          if(header.name !== 'Proc-Type') {\n            throw new Error('Invalid PEM formatted message. The first ' +\n              'encapsulated header must be \"Proc-Type\".');\n          } else if(header.values.length !== 2) {\n            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' +\n              'header must have two subfields.');\n          }\n          msg.procType = {version: values[0], type: values[1]};\n        } else if(!msg.contentDomain && header.name === 'Content-Domain') {\n          // special-case Content-Domain\n          msg.contentDomain = values[0] || '';\n        } else if(!msg.dekInfo && header.name === 'DEK-Info') {\n          // special-case DEK-Info\n          if(header.values.length === 0) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n              'header must have at least one subfield.');\n          }\n          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};\n        } else {\n          msg.headers.push(header);\n        }\n      }\n\n      ++li;\n    }\n\n    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\n      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n        'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n    }\n  }\n\n  if(rval.length === 0) {\n    throw new Error('Invalid PEM formatted message.');\n  }\n\n  return rval;\n};\n\nfunction foldHeader(header) {\n  var rval = header.name + ': ';\n\n  // ensure values with CRLF are folded\n  var values = [];\n  var insertSpace = function(match, $1) {\n    return ' ' + $1;\n  };\n  for(var i = 0; i < header.values.length; ++i) {\n    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n  }\n  rval += values.join(',') + '\\r\\n';\n\n  // do folding\n  var length = 0;\n  var candidate = -1;\n  for(var i = 0; i < rval.length; ++i, ++length) {\n    if(length > 65 && candidate !== -1) {\n      var insert = rval[candidate];\n      if(insert === ',') {\n        ++candidate;\n        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\n      } else {\n        rval = rval.substr(0, candidate) +\n          '\\r\\n' + insert + rval.substr(candidate + 1);\n      }\n      length = (i - candidate - 1);\n      candidate = -1;\n      ++i;\n    } else if(rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\n      candidate = i;\n    }\n  }\n\n  return rval;\n}\n\nfunction ltrim(str) {\n  return str.replace(/^\\s+/, '');\n}\n"]},"metadata":{},"sourceType":"script"}