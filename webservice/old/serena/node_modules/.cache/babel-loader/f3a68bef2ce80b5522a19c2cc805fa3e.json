{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst execa = require(\"execa\");\n\nclass ExecAuth {\n  constructor() {\n    this.tokenCache = {};\n    this.execFn = execa.sync;\n  }\n\n  isAuthProvider(user) {\n    if (!user) {\n      return false;\n    }\n\n    if (user.exec) {\n      return true;\n    }\n\n    if (!user.authProvider) {\n      return false;\n    }\n\n    return user.authProvider.name === 'exec' || !!(user.authProvider.config && user.authProvider.config.exec);\n  }\n\n  applyAuthentication(user, opts) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const credential = this.getCredential(user);\n\n      if (!credential) {\n        return;\n      }\n\n      if (credential.status.clientCertificateData) {\n        opts.cert = credential.status.clientCertificateData;\n      }\n\n      if (credential.status.clientKeyData) {\n        opts.key = credential.status.clientKeyData;\n      }\n\n      const token = this.getToken(credential);\n\n      if (token) {\n        if (!opts.headers) {\n          opts.headers = [];\n        }\n\n        opts.headers.Authorization = `Bearer ${token}`;\n      }\n    });\n  }\n\n  getToken(credential) {\n    if (!credential) {\n      return null;\n    }\n\n    if (credential.status.token) {\n      return credential.status.token;\n    }\n\n    return null;\n  }\n\n  getCredential(user) {\n    // TODO: Add a unit test for token caching.\n    const cachedToken = this.tokenCache[user.name];\n\n    if (cachedToken) {\n      const date = Date.parse(cachedToken.status.expirationTimestamp);\n\n      if (date > Date.now()) {\n        return cachedToken;\n      }\n\n      this.tokenCache[user.name] = null;\n    }\n\n    let exec = null;\n\n    if (user.authProvider && user.authProvider.config) {\n      exec = user.authProvider.config.exec;\n    }\n\n    if (user.exec) {\n      exec = user.exec;\n    }\n\n    if (!exec) {\n      return null;\n    }\n\n    if (!exec.command) {\n      throw new Error('No command was specified for exec authProvider!');\n    }\n\n    let opts = {};\n\n    if (exec.env) {\n      const env = process.env;\n      exec.env.forEach(elt => env[elt.name] = elt.value);\n      opts = Object.assign({}, opts, {\n        env\n      });\n    }\n\n    const result = this.execFn(exec.command, exec.args, opts);\n\n    if (result.code === 0) {\n      const obj = JSON.parse(result.stdout);\n      this.tokenCache[user.name] = obj;\n      return obj;\n    }\n\n    throw new Error(result.stderr);\n  }\n\n}\n\nexports.ExecAuth = ExecAuth;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/@kubernetes/client-node/dist/exec_auth.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","execa","ExecAuth","constructor","tokenCache","execFn","sync","isAuthProvider","user","exec","authProvider","name","config","applyAuthentication","opts","__awaiter","credential","getCredential","status","clientCertificateData","cert","clientKeyData","key","token","getToken","headers","Authorization","cachedToken","date","Date","parse","expirationTimestamp","now","command","Error","env","process","forEach","elt","assign","result","args","code","obj","JSON","stdout","stderr"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst execa = require(\"execa\");\nclass ExecAuth {\n    constructor() {\n        this.tokenCache = {};\n        this.execFn = execa.sync;\n    }\n    isAuthProvider(user) {\n        if (!user) {\n            return false;\n        }\n        if (user.exec) {\n            return true;\n        }\n        if (!user.authProvider) {\n            return false;\n        }\n        return (user.authProvider.name === 'exec' || !!(user.authProvider.config && user.authProvider.config.exec));\n    }\n    applyAuthentication(user, opts) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const credential = this.getCredential(user);\n            if (!credential) {\n                return;\n            }\n            if (credential.status.clientCertificateData) {\n                opts.cert = credential.status.clientCertificateData;\n            }\n            if (credential.status.clientKeyData) {\n                opts.key = credential.status.clientKeyData;\n            }\n            const token = this.getToken(credential);\n            if (token) {\n                if (!opts.headers) {\n                    opts.headers = [];\n                }\n                opts.headers.Authorization = `Bearer ${token}`;\n            }\n        });\n    }\n    getToken(credential) {\n        if (!credential) {\n            return null;\n        }\n        if (credential.status.token) {\n            return credential.status.token;\n        }\n        return null;\n    }\n    getCredential(user) {\n        // TODO: Add a unit test for token caching.\n        const cachedToken = this.tokenCache[user.name];\n        if (cachedToken) {\n            const date = Date.parse(cachedToken.status.expirationTimestamp);\n            if (date > Date.now()) {\n                return cachedToken;\n            }\n            this.tokenCache[user.name] = null;\n        }\n        let exec = null;\n        if (user.authProvider && user.authProvider.config) {\n            exec = user.authProvider.config.exec;\n        }\n        if (user.exec) {\n            exec = user.exec;\n        }\n        if (!exec) {\n            return null;\n        }\n        if (!exec.command) {\n            throw new Error('No command was specified for exec authProvider!');\n        }\n        let opts = {};\n        if (exec.env) {\n            const env = process.env;\n            exec.env.forEach((elt) => (env[elt.name] = elt.value));\n            opts = Object.assign({}, opts, { env });\n        }\n        const result = this.execFn(exec.command, exec.args, opts);\n        if (result.code === 0) {\n            const obj = JSON.parse(result.stdout);\n            this.tokenCache[user.name] = obj;\n            return obj;\n        }\n        throw new Error(result.stderr);\n    }\n}\nexports.ExecAuth = ExecAuth;\n//# sourceMappingURL=exec_auth.js.map"]},"metadata":{},"sourceType":"script"}