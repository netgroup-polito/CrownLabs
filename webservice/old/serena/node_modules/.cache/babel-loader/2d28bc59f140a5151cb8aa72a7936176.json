{"ast":null,"code":"/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar ecUtil = require(\"./ec-util.js\"),\n    helpers = require(\"./helpers.js\"),\n    sha = require(\"./sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n\n    case \"SHA-384\":\n      return \"P-384\";\n\n    case \"SHA-512\":\n      return \"P-521\";\n\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, false);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // sign hash\n\n    promise = promise.then(function (result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, false);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      result = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function (key, pdata) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createSign(nodeHash));\n      promise = promise.then(function (sign) {\n        sign.update(pdata);\n        return sign;\n      });\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n\n        case \"512\":\n          size = 66;\n          break;\n\n        default:\n          size = 32;\n      }\n\n      promise = promise.then(function (sign) {\n        return ecUtil.derToConcat(sign.sign(ecUtil.convertToPEM(key, true)), size);\n      });\n      promise = promise.then(function (result) {\n        return {\n          data: pdata,\n          mac: result\n        };\n      });\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata, mac\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, true);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // verify hash\n\n    promise = promise.then(function (result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata, mac\n  /* , props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, true);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function (key, pdata, mac\n    /* , props */\n    ) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n\n        case \"512\":\n          size = 66;\n          break;\n\n        default:\n          size = 32;\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));\n      promise = promise.then(function (verify) {\n        verify.update(pdata);\n        verify.end();\n        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));\n      });\n      promise = promise.then(function (result) {\n        if (!result) {\n          throw new Error(\"verification failed\");\n        }\n\n        return {\n          data: pdata,\n          mac,\n          valid: true\n        };\n      });\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n} // ### Public API\n\n\nvar ecdsa = {}; // * [name].sign\n// * [name].verify\n\n[\"ES256\", \"ES384\", \"ES512\"].forEach(function (name) {\n  var hash = name.replace(/ES(\\d+)/g, function (m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\nmodule.exports = ecdsa;","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/lib/algorithms/ecdsa.js"],"names":["ecUtil","require","helpers","sha","idealCurve","hash","Error","ecdsaSignFN","curve","fallback","key","pdata","crv","Promise","reject","pk","convertToForge","promise","digest","then","result","sign","Buffer","concat","r","s","data","mac","webcrypto","convertToJWK","alg","name","namedCurve","subtleCrypto","importKey","from","nodejs","nodeHash","toLowerCase","replace","nodeCrypto","getHashes","indexOf","resolve","createSign","update","size","slice","derToConcat","convertToPEM","setupFallback","ecdsaVerifyFN","len","length","rs","verify","valid","createVerify","end","concatToDer","ecdsa","forEach","m","module","exports"],"mappings":"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","sourcesContent":["/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar ecUtil = require(\"./ec-util.js\"),\n    helpers = require(\"./helpers.js\"),\n    sha = require(\"./sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n    case \"SHA-384\":\n      return \"P-384\";\n    case \"SHA-512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, false);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // sign hash\n    promise = promise.then(function(result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, false);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [ \"sign\" ]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createSign(nodeHash));\n      promise = promise.then(function (sign) {\n        sign.update(pdata);\n        return sign;\n      });\n\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      promise = promise.then(function (sign) {\n        return ecUtil.derToConcat(sign.sign(ecUtil.convertToPEM(key, true)), size);\n      });\n\n      promise = promise.then(function (result) {\n        return {\n          data: pdata,\n          mac: result\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, true);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // verify hash\n    promise = promise.then(function(result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata, mac /* , props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, true);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata, mac /* , props */) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var size;\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));\n      promise = promise.then(function (verify) {\n        verify.update(pdata);\n        verify.end();\n        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));\n      });\n      promise = promise.then(function (result) {\n        if (!result) {\n          throw new Error(\"verification failed\");\n        }\n        return {\n          data: pdata,\n          mac,\n          valid: true\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\nvar ecdsa = {};\n\n// * [name].sign\n// * [name].verify\n[\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n].forEach(function(name) {\n  var hash = name.replace(/ES(\\d+)/g, function(m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\n\nmodule.exports = ecdsa;\n"]},"metadata":{},"sourceType":"script"}