{"ast":null,"code":"var parseKeys = require('parse-asn1');\n\nvar mgf = require('./mgf');\n\nvar xor = require('./xor');\n\nvar BN = require('bn.js');\n\nvar crt = require('browserify-rsa');\n\nvar createHash = require('create-hash');\n\nvar withPublic = require('./withPublic');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function privateDecrypt(privateKey, enc, reverse) {\n  var padding;\n\n  if (privateKey.padding) {\n    padding = privateKey.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n\n  var key = parseKeys(privateKey);\n  var k = key.modulus.byteLength();\n\n  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error');\n  }\n\n  var msg;\n\n  if (reverse) {\n    msg = withPublic(new BN(enc), key);\n  } else {\n    msg = crt(enc, key);\n  }\n\n  var zBuffer = Buffer.alloc(k - msg.length);\n  msg = Buffer.concat([zBuffer, msg], k);\n\n  if (padding === 4) {\n    return oaep(key, msg);\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    return msg;\n  } else {\n    throw new Error('unknown padding');\n  }\n};\n\nfunction oaep(key, msg) {\n  var k = key.modulus.byteLength();\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();\n  var hLen = iHash.length;\n\n  if (msg[0] !== 0) {\n    throw new Error('decryption error');\n  }\n\n  var maskedSeed = msg.slice(1, hLen + 1);\n  var maskedDb = msg.slice(hLen + 1);\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen));\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1));\n\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error');\n  }\n\n  var i = hLen;\n\n  while (db[i] === 0) {\n    i++;\n  }\n\n  if (db[i++] !== 1) {\n    throw new Error('decryption error');\n  }\n\n  return db.slice(i);\n}\n\nfunction pkcs1(key, msg, reverse) {\n  var p1 = msg.slice(0, 2);\n  var i = 2;\n  var status = 0;\n\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++;\n      break;\n    }\n  }\n\n  var ps = msg.slice(2, i - 1);\n\n  if (p1.toString('hex') !== '0002' && !reverse || p1.toString('hex') !== '0001' && reverse) {\n    status++;\n  }\n\n  if (ps.length < 8) {\n    status++;\n  }\n\n  if (status) {\n    throw new Error('decryption error');\n  }\n\n  return msg.slice(i);\n}\n\nfunction compare(a, b) {\n  a = Buffer.from(a);\n  b = Buffer.from(b);\n  var dif = 0;\n  var len = a.length;\n\n  if (a.length !== b.length) {\n    dif++;\n    len = Math.min(a.length, b.length);\n  }\n\n  var i = -1;\n\n  while (++i < len) {\n    dif += a[i] ^ b[i];\n  }\n\n  return dif;\n}","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/public-encrypt/privateDecrypt.js"],"names":["parseKeys","require","mgf","xor","BN","crt","createHash","withPublic","Buffer","module","exports","privateDecrypt","privateKey","enc","reverse","padding","key","k","modulus","byteLength","length","cmp","Error","msg","zBuffer","alloc","concat","oaep","pkcs1","iHash","update","digest","hLen","maskedSeed","slice","maskedDb","seed","db","compare","i","p1","status","ps","toString","a","b","from","dif","len","Math","min"],"mappings":"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","sourcesContent":["var parseKeys = require('parse-asn1')\nvar mgf = require('./mgf')\nvar xor = require('./xor')\nvar BN = require('bn.js')\nvar crt = require('browserify-rsa')\nvar createHash = require('create-hash')\nvar withPublic = require('./withPublic')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function privateDecrypt (privateKey, enc, reverse) {\n  var padding\n  if (privateKey.padding) {\n    padding = privateKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n\n  var key = parseKeys(privateKey)\n  var k = key.modulus.byteLength()\n  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error')\n  }\n  var msg\n  if (reverse) {\n    msg = withPublic(new BN(enc), key)\n  } else {\n    msg = crt(enc, key)\n  }\n  var zBuffer = Buffer.alloc(k - msg.length)\n  msg = Buffer.concat([zBuffer, msg], k)\n  if (padding === 4) {\n    return oaep(key, msg)\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    return msg\n  } else {\n    throw new Error('unknown padding')\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  if (msg[0] !== 0) {\n    throw new Error('decryption error')\n  }\n  var maskedSeed = msg.slice(1, hLen + 1)\n  var maskedDb = msg.slice(hLen + 1)\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen))\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1))\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error')\n  }\n  var i = hLen\n  while (db[i] === 0) {\n    i++\n  }\n  if (db[i++] !== 1) {\n    throw new Error('decryption error')\n  }\n  return db.slice(i)\n}\n\nfunction pkcs1 (key, msg, reverse) {\n  var p1 = msg.slice(0, 2)\n  var i = 2\n  var status = 0\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++\n      break\n    }\n  }\n  var ps = msg.slice(2, i - 1)\n\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {\n    status++\n  }\n  if (ps.length < 8) {\n    status++\n  }\n  if (status) {\n    throw new Error('decryption error')\n  }\n  return msg.slice(i)\n}\nfunction compare (a, b) {\n  a = Buffer.from(a)\n  b = Buffer.from(b)\n  var dif = 0\n  var len = a.length\n  if (a.length !== b.length) {\n    dif++\n    len = Math.min(a.length, b.length)\n  }\n  var i = -1\n  while (++i < len) {\n    dif += (a[i] ^ b[i])\n  }\n  return dif\n}\n"]},"metadata":{},"sourceType":"script"}