{"ast":null,"code":"/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nvar _crypto = null;\n\nif (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n/* PRNG API */\n\n\nvar prng = module.exports = forge.prng = forge.prng || {};\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\n\nprng.create = function (plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  }; // create 32 entropy pools (each is a message digest)\n\n  var md = plugin.md;\n  var pools = new Array(32);\n\n  for (var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n\n  ctx.pools = pools; // entropy pools are written to cyclically, starting at index 0\n\n  ctx.pool = 0;\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n\n  ctx.generate = function (count, callback) {\n    // do synchronously\n    if (!callback) {\n      return ctx.generateSync(count);\n    } // simple generator using counter-based CBC\n\n\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer(); // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n\n    ctx.key = null;\n    generate();\n\n    function generate(err) {\n      if (err) {\n        return callback(err);\n      } // sufficient bytes generated\n\n\n      if (b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      } // if amount of data generated is greater than 1 MiB, trigger reseed\n\n\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if (ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function () {\n          _reseed(generate);\n        });\n      } // generate the random bytes\n\n\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes); // generate bytes for a new key and seed\n\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n      forge.util.setImmediate(generate);\n    }\n  };\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n\n\n  ctx.generateSync = function (count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed; // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n\n    ctx.key = null;\n    var b = forge.util.createBuffer();\n\n    while (b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if (ctx.key === null) {\n        _reseedSync();\n      } // generate the random bytes\n\n\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes); // generate bytes for a new key and seed\n\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n\n\n  function _reseed(callback) {\n    if (ctx.pools[0].messageLength >= 32) {\n      _seed();\n\n      return callback();\n    } // not enough seed data...\n\n\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.seedFile(needed, function (err, bytes) {\n      if (err) {\n        return callback(err);\n      }\n\n      ctx.collect(bytes);\n\n      _seed();\n\n      callback();\n    });\n  }\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n\n\n  function _reseedSync() {\n    if (ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    } // not enough seed data...\n\n\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n\n    _seed();\n  }\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n\n\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1; // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n    // create a plugin-based message digest\n\n    var md = ctx.plugin.md.create(); // consume current key bytes\n\n    md.update(ctx.keyBytes); // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n\n    var _2powK = 1;\n\n    for (var k = 0; k < 32; ++k) {\n      if (ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n\n      _2powK = _2powK << 1;\n    } // get digest for key bytes\n\n\n    ctx.keyBytes = md.digest().getBytes(); // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes(); // update state\n\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n\n\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n\n    if (_crypto && _crypto.getRandomValues) {\n      getRandomValues = function (arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n\n    if (getRandomValues) {\n      while (b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n\n        try {\n          getRandomValues(entropy);\n\n          for (var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch (e) {\n          /* only ignore QuotaExceededError */\n          if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    } // be sad and add some weak random data\n\n\n    if (b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n\n      while (b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF; // consume lower 3 bytes of seed\n\n        for (var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(String.fromCharCode(next & 0xFF));\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  } // initialize seed file APIs\n\n\n  if (_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function (needed, callback) {\n      _crypto.randomBytes(needed, function (err, bytes) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, bytes.toString());\n      });\n    }; // use nodejs sync API\n\n\n    ctx.seedFileSync = function (needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function (needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    ctx.seedFileSync = defaultSeedFile;\n  }\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n\n\n  ctx.collect = function (bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n\n    for (var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n    }\n  };\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n\n\n  ctx.collectInt = function (i, n) {\n    var bytes = '';\n\n    for (var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode(i >> x & 0xFF);\n    }\n\n    ctx.collect(bytes);\n  };\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n\n\n  ctx.registerWorker = function (worker) {\n    // worker receives random bytes\n    if (worker === self) {\n      ctx.seedFile = function (needed, callback) {\n        function listener(e) {\n          var data = e.data;\n\n          if (data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n\n        self.addEventListener('message', listener);\n        self.postMessage({\n          forge: {\n            prng: {\n              needed: needed\n            }\n          }\n        });\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function (e) {\n        var data = e.data;\n\n        if (data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function (err, bytes) {\n            worker.postMessage({\n              forge: {\n                prng: {\n                  err: err,\n                  bytes: bytes\n                }\n              }\n            });\n          });\n        }\n      }; // TODO: do we need to remove the event listener when the worker dies?\n\n\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};","map":{"version":3,"sources":["/home/s41m0n/Documents/University/Turin/YearII/CrownLabs/frontend/node_modules/node-jose/node_modules/node-forge/lib/prng.js"],"names":["forge","require","_crypto","util","isNodejs","options","usePureJavaScript","process","versions","prng","module","exports","create","plugin","ctx","key","seed","time","reseeds","generated","keyBytes","md","pools","Array","i","pool","generate","count","callback","generateSync","cipher","increment","formatKey","formatSeed","b","createBuffer","err","length","getBytes","nextTick","_reseed","bytes","putBytes","setImmediate","_reseedSync","messageLength","_seed","needed","seedFile","collect","seedFileSync","update","_2powK","k","digest","start","seedBytes","defaultSeedFile","getRandomValues","globalScope","crypto","msCrypto","arr","Math","max","min","entropy","Uint32Array","floor","putInt32","e","QuotaExceededError","hi","lo","next","random","putByte","String","fromCharCode","randomBytes","toString","substr","collectInt","n","x","registerWorker","worker","self","listener","data","removeEventListener","addEventListener","postMessage"],"mappings":"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","sourcesContent":["/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nvar _crypto = null;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n  !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function(plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for(var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function(count, callback) {\n    // do synchronously\n    if(!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n\n    generate();\n\n    function generate(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if(b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function() {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function(count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n\n    var b = forge.util.createBuffer();\n    while(b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if(ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.seedFile(needed, function(err, bytes) {\n      if(err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if(ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for(var k = 0; k < 32; ++k) {\n      if(ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if(_crypto && _crypto.getRandomValues) {\n      getRandomValues = function(arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n    if(getRandomValues) {\n      while(b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for(var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch(e) {\n          /* only ignore QuotaExceededError */\n          if(!(typeof QuotaExceededError !== 'undefined' &&\n            e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if(b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while(b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for(var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(String.fromCharCode(next & 0xFF));\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if(_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function(needed, callback) {\n      _crypto.randomBytes(needed, function(err, bytes) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function(needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function(needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch(e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function(bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for(var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function(i, n) {\n    var bytes = '';\n    for(var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode((i >> x) & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function(worker) {\n    // worker receives random bytes\n    if(worker === self) {\n      ctx.seedFile = function(needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if(data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({forge: {prng: {needed: needed}}});\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function(e) {\n        var data = e.data;\n        if(data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};\n"]},"metadata":{},"sourceType":"script"}